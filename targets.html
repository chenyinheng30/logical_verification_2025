<!DOCTYPE html>
<head>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
  MathJax = {
    options: {
      skipHtmlTags: {
        '[-]': ['code', 'pre']  // 从跳过列表中移除 'code' 和 'pre'
      }
    }
  }
</script>
<style>
body {
	box-sizing: border-box;
	min-width: 200px;
	max-width: 980px;
	margin: 0 auto;
	padding: 45px;
}
@media (prefers-color-scheme: dark) {
	body {
		background-color: #0d1117;
	}
}
#toc-container {
    position: fixed;
    left: 20px;
    top: 20px;
    background: #f8f9fa;
    padding: 15px;
    border: 1px solid #dee2e6;
    border-radius: 5px;
    max-width: 250px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
#toc-container h2 {
    margin-top: 0;
    font-size: 1.2em;
    color: #343a40;
}
#toc {
    list-style-type: none;
    padding-left: 0;
}
#toc ul {
    list-style-type: none;
    padding-left: 15px;
}
#toc a {
    color: #495057;
    text-decoration: none;
    display: block;
    padding: 3px 0;
}
#toc a:hover {
    color: #007bff;
}
/* 内容区域样式 */
#content {
    margin-left: 300px;
    padding: 20px;
}
/* 响应式设计 */
@media (max-width: 768px) {
    #toc-container {
        position: static;
        max-width: 100%;
        margin-bottom: 20px;
    }
    
    #content {
        margin-left: 0;
    }
}
</style>
</head>
<body>
<div id="toc-container">
    <h2>目录</h2>
    <div id="toc"></div>
</div>
<div>
<h1>前言</h1>
<p>形式化证明辅助工具是专为帮助用户完成计算机验证证明而设计的软件。我们通常称其为证明辅助器或交互式定理证明器，但曾有沮丧的学生戏称其为"证明阻碍兽"，而语音识别软件偶尔会将"定理证明器"误听为"恐惧改善器"。特此提醒。</p>

<p>严谨的形式化证明 交互式定理证明有其专用术语体系，首当其冲便是"证明"这一概念。形式化证明是指用逻辑形式体系表述的逻辑论证。此处的"形式化"特指"基于逻辑"或"逻辑化"的含义。逻辑学家——研究逻辑的数学家们——早在计算机出现前数十年就已在纸上进行形式化证明，但如今的形式化证明几乎总是借助证明辅助工具来完成。</p>


<p>相比之下，非形式化证明是数学家通常所说的证明。这类证明常在<span class="math">\(\mathrm{ET}_{\mathrm{E}} \mathrm{X}\)</span>或黑板上完成，也被称为"纸笔证明"。其详细程度差异很大，诸如"显然"、"不难看出"、"不失一般性"等表述将部分证明负担转嫁给读者。严格证明则是一种极其详尽的非形式化证明。</p>


<p>证明助手的主要优势在于，它们能借助精确逻辑帮助构建高度可信、无歧义的数学陈述证明。这类工具可用于证明任意高阶结论，远超出玩具示例和逻辑谜题的范畴。形式化证明还有助于学生理解有效定义与有效证明的构成要素。正如斯科特·阿伦森所言：<span class="math">\({ }^{1}\)</span></p>


<p>我至今仍记得不得不批改数百份试卷的经历，学生们要么一开始就假设需要证明的结论成立，要么在纸上写满不知所云的内容，指望在混乱中偶然蒙对几个正确答案。</p>

<p>当我们发展新理论时，形式化证明能帮助我们探索其内涵。在推广、重构或修改现有证明时，它们如同编译器辅助开发正确程序般发挥作用。这类证明具有高度可信性，便于他人审阅。此外，形式化证明可构成验证计算工具（如经过验证的计算机代数系统）的基础。</p>

<p>成功案例 在数学和计算机科学领域，证明助手已取得多项成功案例。数学形式化方面的一些里程碑成果包括：Gonthier等人完成的四色定理证明、Gonthier团队完成的奇数阶定理证明、Hales团队完成的开普勒猜想证明，以及Buzzard团队定义的完美胚空间。该领域最早的研究由Nicolaas de Bruijn及其同事于20世纪60年代在AUTOMATH系统中开展。<span class="math">\({ }^{2}\)</span></p>


<p>包括AMD和英特尔在内的少数公司已开始使用证明辅助工具验证其芯片设计。在学术界，里程碑式的成果包括操作系统内核seL4和CertiKOS的形式化验证，以及经过验证的编译器CompCert、JinjaThreads和CakeML的开发。</p>


<p>证明助手 目前全球有数十种正在开发或使用的证明助手。以下按逻辑基础分类列出主要系统：</p>
<ul>
<li>集合论：Isabelle/ZF, Metamath, Mizar;</li>
<li>简单类型论：HOL4, HOL Light, Isabelle/HOL;</li>
<li>依值类型论：Agda, Coq, Lean, Matita, PVS;</li>
<li>类Lisp一阶逻辑：ACL2。</li>
</ul>


<p>关于证明助手和交互式定理证明的历史，我们推荐参考Harrison、Urban和Wiedijk所著信息量丰富的章节。</p>


<p>Lean Lean是由莱昂纳多·德·穆拉（微软研究院）自2012年起主导开发的证明辅助工具。其数学库mathlib最初由杰里米·阿维加德（卡内基梅隆大学）领导开发，现由用户社区维护和扩展。<span class="math">\({ }^{3}\)</span></p>


<p>本指南使用Lean版本v4.14.0、mathlib修订版4bbdccd9c5f862bf以及收集在名为LoVelib小型库中的若干扩展。<span class="math">\({ }^{4}\)</span> 尽管这是一个研究项目且存在某些不完善之处，但Lean仍具备以下适合教授交互式定理证明的特性：</p>
<ul>
<li>其基于归纳构造演算（一种依赖类型论）的逻辑系统具有高度表达力且非常有趣</li>
<li>通过经典公理和商类型扩展，使其适用于数学验证</li>
<li>包含便捷的元编程框架，可用于编写自定义证明自动化程序</li>
<li>通过Visual Studio Code插件提供现代化用户界面</li>
<li>拥有可读性高、相当完整的文档体系</li>
<li>完全开源</li>
</ul>

<p>Lean的核心库仅包含基础代数定义，更多定义可在mathlib中找到。尽管名为数学库，mathlib远不止于此；正如现代证明助手的应有之义，它在Lean核心库之上提供了大量基础自动化功能。</p>
<p>本指南 本指南最初是为阿姆斯特丹自由大学硕士课程《逻辑验证》（LoVe）设计的配套教材。其主要目标是教授交互式定理证明技术。Lean是实现这一目标的工具，而非目的本身。因此，本指南并非全面的Lean教程——为此我们推荐《Lean 4中的定理证明》。本指南也不能替代练习和作业的实践。定理证明不是旁观者的运动，唯有通过实践才能真正掌握。</p>

<p>具体而言，本指南旨在帮助你</p>
<ul>
<li>掌握交互式定理证明的基础理论与技术；</li>
<li>学习如何将逻辑作为精确语言来建模系统并陈述其属性；</li>
<li>熟悉证明助手成功应用的某些领域，如函数式编程、命令式编程语言语义学及数学领域；</li>
<li>培养可应用于大型项目（无论是个人项目、硕士/博士项目还是工业项目）的实践技能；</li>
<li>能够迁移到其他证明助手并应用所学知识；</li>
<li>充分理解该领域，从而开始阅读国际会议（如CPP认证程序与证明会议、ITP交互式定理证明会议）或期刊（如JAR自动推理杂志）发表的相关学术论文。掌握Lean后，应能轻松迁移到基于依赖类型论的其他证明助手（如Agda或Coq），或基于简单类型论的系统（如HOL4或Isabelle/HOL）。</li>
</ul>


<p>本指南与高德纳的《TgXbook》有一个共同的重要特点：它并不总是讲述真相。为了简化阐述，文中会提出一些关于Lean的基本但错误的断言。这些陈述大多会在后续章节中得到修正。正如高德纳所言，我们相信"这种刻意隐瞒真相的技巧实际上会让你更容易理解核心概念。当你掌握了一个简单但不完全正确的规则后，再补充学习该规则的例外情况就会容易得多。"</p>


<p>本指南配套的Lean文件可在公开代码库中获取。<span class="math">\({ }^{5}\)</span> 文件命名规则与本书章节对应：例如LoVe07_EffectfulProgramming_Demo.lean是第7章《效应式编程》的主文件（课堂讲解版本），LoVe07_EffectfulProgramming_ExerciseSheet.lean是习题集，LoVe07_EffectfulProgramming_HomeworkSheet.lean则是作业集。</p>

<p>我们深深感谢《Lean 4中的定理证明》和《Concrete Semantics: With Isabelle/HOL》的作者们，是他们教会了我们Lean和编程语言语义学。本指南中融入了他们的诸多思想。</p>

<p>感谢Robert Lewis和Assia Mahboubi对本指南结构与重点提出的宝贵意见。感谢Kiran Gopinathan和Ilya Sergey分享第二章脚注3中的轶事并允许我们转述。感谢Daniel Fabian设计了本指南首个平板优化版本。感谢Paul Chisholm为相关Lean文件撰写部分注释。感谢Pietro Monticone在Lean和mathlib演进过程中协助维护Lean文件更新。感谢Mark Summerfield提供的诸多文本建议。最后，感谢Chris Bailey、Kevin Buzzard、Paul Chisholm、Dominique Danco、Raufs Dunamalijevs、Wan Fokkink、Lina Gerlach、Robert Lewis、Antonius Danny Reyes、Robert Schütz、Kristina Sojakova、Patrick Thomas、Balazs Toth、Huub Vromen、Floris Westerman、Wijnand van Woerkom和Yiming Xu指出早期版本中的排版错误及更严重问题。若您发现本文错误，敬请告知。<span class="math">\({ }^{6}\)</span></p>

<table>
<thead>
<tr>
  <th style="text-align:center"><span class="math">\(\neg\)</span></th>
  <th style="text-align:center">\not</th>
  <th style="text-align:center"><span class="math">\(\wedge\)</span></th>
  <th style="text-align:center">\and</th>
  <th style="text-align:center"><span class="math">\(\checkmark\)</span></th>
  <th style="text-align:center">\or</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><span class="math">\(\rightarrow\)</span></td>
  <td style="text-align:center">-&gt;</td>
  <td style="text-align:center"><span class="math">\(\leftrightarrow\)</span></td>
  <td style="text-align:center">&lt;-&gt;</td>
  <td style="text-align:center"><span class="math">\(\forall\)</span></td>
  <td style="text-align:center">\fo</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\exists\)</span></td>
  <td style="text-align:center">\ex</td>
  <td style="text-align:center"><span class="math">\(\leq\)</span></td>
  <td style="text-align:center">&lt;=</td>
  <td style="text-align:center"><span class="math">\(\geq\)</span></td>
  <td style="text-align:center">&gt;=</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\neq\)</span></td>
  <td style="text-align:center">\neq</td>
  <td style="text-align:center"><span class="math">\(\approx\)</span></td>
  <td style="text-align:center">\</td>
  <td style="text-align:center"><span class="math">\(\times\)</span></td>
  <td style="text-align:center">\x</td>
</tr>
<tr>
  <td style="text-align:center">○</td>
  <td style="text-align:center">\circ</td>
  <td style="text-align:center"><span class="math">\(\emptyset\)</span></td>
  <td style="text-align:center">\empty</td>
  <td style="text-align:center"><span class="math">\(\cup\)</span></td>
  <td style="text-align:center">\union</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\cap\)</span></td>
  <td style="text-align:center">\intersect</td>
  <td style="text-align:center"><span class="math">\(\in\)</span></td>
  <td style="text-align:center">\in</td>
  <td style="text-align:center">;</td>
  <td style="text-align:center">\downleftharpoon</td>
</tr>
<tr>
  <td style="text-align:center">○</td>
  <td style="text-align:center">\bigcirc</td>
  <td style="text-align:center"><span class="math">\(\leftarrow\)</span></td>
  <td style="text-align:center">&lt;-</td>
  <td style="text-align:center"><span class="math">\(\mapsto\)</span></td>
  <td style="text-align:center">\mapsto</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\Rightarrow\)</span></td>
  <td style="text-align:center">=&gt;</td>
  <td style="text-align:center"><span class="math">\(\Longrightarrow\)</span></td>
  <td style="text-align:center">==&gt;</td>
  <td style="text-align:center"><span class="math">\(\|\)</span></td>
  <td style="text-align:center">
<span class="math">\(\backslash[\)</span> [</td>
</tr>
<tr>
  <td style="text-align:center">]</td>
  <td style="text-align:center">]]</td>
  <td style="text-align:center"><span class="math">\(\alpha\)</span></td>
  <td style="text-align:center">\a</td>
  <td style="text-align:center"><span class="math">\(\beta\)</span></td>
  <td style="text-align:center">\b</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\gamma\)</span></td>
  <td style="text-align:center">\g</td>
  <td style="text-align:center"><span class="math">\(\varepsilon\)</span></td>
  <td style="text-align:center">\e</td>
  <td style="text-align:center"><span class="math">\(\sigma\)</span></td>
  <td style="text-align:center">\s</td>
</tr>
<tr>
  <td style="text-align:center">○</td>
  <td style="text-align:center">\0</td>
  <td style="text-align:center">1</td>
  <td style="text-align:center">\1</td>
  <td style="text-align:center">2</td>
  <td style="text-align:center">\2</td>
</tr>
<tr>
  <td style="text-align:center">3</td>
  <td style="text-align:center">\3</td>
  <td style="text-align:center">4</td>
  <td style="text-align:center">\4</td>
  <td style="text-align:center">5</td>
  <td style="text-align:center">\5</td>
</tr>
<tr>
  <td style="text-align:center">6</td>
  <td style="text-align:center">\6</td>
  <td style="text-align:center">7</td>
  <td style="text-align:center">\7</td>
  <td style="text-align:center">8</td>
  <td style="text-align:center">\8</td>
</tr>
<tr>
  <td style="text-align:center">9</td>
  <td style="text-align:center">\9</td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
</tr>
</tbody>
</table>

<p>特殊符号 本指南假设您将使用Visual Studio Code及其"lean4"扩展来编辑.lean文件。Visual Studio Code允许您通过输入反斜杠<span class="math">\(\backslash\)</span>后跟ASCII标识符来输入Unicode符号。例如，<span class="math">\(\rightarrow, \forall\)</span>或<span class="math">\(\in\)</span>可以通过键入<span class="math">\(\backslash-&gt;\)</span>、<span class="math">\(\backslash\)</span> fo或<span class="math">\(\backslash\)</span> in并按Tab键或空格键输入。我们将自由使用这些符号表示法。作为参考，我们提供了本指南中使用的主要非ASCII符号列表，并为每个符号提供其ASCII表示形式之一。在Visual Studio Code中按住Control或Command键的同时将鼠标悬停在符号上，您将看到输入该符号的不同方式。</p>


<h1>第一部分：基础</h1>
<h2>第一章：类型与项</h2>
<p>我们将从学习Lean的基础知识开始这段旅程，首先了解项（也称为表达式）及其类型。</p>


<p>Lean的逻辑基础是一种称为归纳构造演算的丰富逻辑体系，它支持依赖类型。Lean的逻辑受到<span class="math">\(\lambda\)</span>演算的启发，并类似于Haskell、OCaml和Standard ML等类型化函数式编程语言。即使您未曾使用过这些语言，也能从现代编程语言（如C++、Java、Python）中识别出许多相似概念。初步近似而言：</p>

<pre><code>fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
</code></pre>

<p>Lean <span class="math">\(=\)</span> 函数式编程 + 逻辑
如果你的背景是数学，你可能已经掌握了函数式编程的大部分核心概念，只是名称有所不同。例如，Haskell程序</p>

<div class="math">$$
f i b(n)= \begin{cases}0 &amp; \text { if } n=0 \\ 1 &amp; \text { if } n=1 \\ f i b(n-2)+f i b(n-1) &amp; \text { if } n \geq 2\end{cases}
$$</div>

<p>与数学定义高度吻合</p>


<p>在本章中，我们将研究范围限定于不含依赖类型的Lean语言片段，称为简单类型论（或高阶逻辑）。这大致对应于通过等号运算符(=)扩展的简单类型<span class="math">\(\lambda\)</span>演算。作为一种抽象且高度简化的编程语言版本，其函数调用机制预示了函数式编程的雏形。</p>


<h3>1.1 类型系统</h3>
<p>类型可以是基本类型如<span class="math">\(\mathbb{Z}, \mathbb{Q}\)</span>和Bool，或是全函数类型<span class="math">\(\sigma \rightarrow \tau\)</span>（其中<span class="math">\(\sigma\)</span>与<span class="math">\(\tau\)</span>本身也是类型）。类型系统规定了表达式可能求值的范围，这种约束机制在数学中通常是隐式遵循的。理论上数学家可以写出<span class="math">\(1 \in 2\)</span>这样的表达式，但类型规范会将其标记为明显的错误。从语义角度看，类型可视为集合。我们通常将<span class="math">\(\mathbb{Z}\)</span>、<span class="math">\(\mathbb{Q}\)</span>和Bool类型定义为精确对应数学家的整数/有理数概念和计算机科学家的布尔值，函数箭头<span class="math">\((\rightarrow)\)</span>也遵循类似原则。但需注意，尽管存在相似性，Lean与数学语言存在本质区别——Lean的类型虽可解释为集合，但其本身并非集合。</p>


<p>高阶类型是指包含在<span class="math">\(\rightarrow\)</span>箭头左侧嵌套的类型，例如类型<span class="math">\((\mathbb{Z} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Q}\)</span>。这类类型的值是接受其他函数作为参数的函数。因此，<span class="math">\((\mathbb{Z} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Q}\)</span>表示一种一元函数的类型，该函数以<span class="math">\(\mathbb{Z} \rightarrow \mathbb{Z}\)</span>类型的函数为参数，并返回<span class="math">\(\mathbb{Q}\)</span>类型的值。</p>


<h3>1.2 项</h3>
<p>简单类型论中的项（或称表达式）由以下成分构成：</p>
<ul>
<li>常量 c；</li>
<li>变量 <span class="math">\(x\)</span>；</li>
<li>应用式 t u；</li>
<li>匿名函数 fun <span class="math">\(x \mapsto t\)</span>（亦称<span class="math">\(\lambda\)</span>-表达式）。</li>
</ul>

<p>在上文中，<span class="math">\(t\)</span> 和 <span class="math">\(u\)</span> 表示任意项。我们也可以用 <span class="math">\(t: \sigma\)</span> 表示项 <span class="math">\(t\)</span> 具有类型 <span class="math">\(\sigma\)</span>。</p>

<p>让我们逐一回顾各类项：</p>
<ul>
<li>常量<span class="math">\(c: \sigma\)</span>是类型为<span class="math">\(\sigma\)</span>的符号，其含义在当前全局上下文中固定。例如算术理论可能包含常量：<span class="math">\(\theta: \mathbb{Z}, 1: \mathbb{Z}\)</span>、绝对值函数<span class="math">\(: \mathbb{Z} \rightarrow \mathbb{N}\)</span>、平方函数<span class="math">\(: \mathbb{N} \rightarrow \mathbb{N}\)</span>以及素数谓词<span class="math">\(: \mathbb{N} \rightarrow\)</span> Bool。常量包括函数（如绝对值）和谓词（如素数）。</li>
<li>变量<span class="math">\(x: \sigma\)</span>可分为绑定变量或自由变量。绑定变量指向匿名函数fun <span class="math">\(x: \sigma \mapsto t\)</span>中封装它的输入参数<span class="math">\(x\)</span>；而自由变量则在局部上下文中声明——这个概念将在下文解释。</li>
<li>应用式<span class="math">\(t u\)</span>（其中<span class="math">\(t: \sigma \rightarrow \tau\)</span>且<span class="math">\(u: \sigma\)</span>）是类型为<span class="math">\(\tau\)</span>的项，表示将函数<span class="math">\(t\)</span>作用于参数<span class="math">\(u\)</span>的结果。例如若<span class="math">\(t\)</span>为绝对值函数且<span class="math">\(u\)</span>为<span class="math">\(\theta\)</span>，则该应用式为abs <span class="math">\(\theta\)</span>。除非参数是复杂项（如prime (abs <span class="math">\(\theta\)</span> )），否则无需添加括号。</li>
<li>给定项<span class="math">\(t: \tau\)</span>，匿名函数fun <span class="math">\(x: \sigma \mapsto t\)</span>表示类型为<span class="math">\(\sigma \rightarrow \tau\)</span>的全函数，它将每个类型为<span class="math">\(\sigma\)</span>的输入值<span class="math">\(x\)</span>映射到函数体<span class="math">\(t\)</span>（其中<span class="math">\(x\)</span>可能在<span class="math">\(t\)</span>中出现）。因此fun <span class="math">\(x: \mathbb{Z} \mapsto\)</span> square (abs <span class="math">\(x\)</span> )表示将<span class="math">\(\theta\)</span>映射到square (abs <span class="math">\(\theta\)</span> )，将1映射到square (abs 1 )等的函数。变量<span class="math">\(x\)</span>被称为由fun绑定，因此fun被称为绑定符。对数学家而言，更熟悉的语法可能是<span class="math">\(x \mapsto\)</span> square (abs <span class="math">\(x\)</span> )这种不含fun关键字的表达。</li>
</ul>


<p>常量与变量在句法结构上看似相似，但本质截然不同。常量是全局声明的，而变量则通过fun或其他绑定器在局部引入。</p>

<div class="math">$$
\begin{aligned}
&amp; (\text { fun } n: \mathbb{N} \mapsto n) 4 \text { yields } 4 \\
&amp; \text { (fun } n: \mathbb{N} \mapsto \text { square (square } n \text { ) }) 5 \text { yields square (square 5) } \\
&amp; \text { (fun } y: \mathbb{Z} \mapsto 1) \theta \text { yields } 1 \\
&amp; (\text { fun } x: \mathbb{Z} \mapsto(\text { fun } y: \mathbb{Z} \mapsto x)) 1 \text { yields fun } y: \mathbb{Z} \mapsto 1
\end{aligned}
$$</div>

<p>函数应用与匿名函数互为镜像：匿名函数用于"构造"函数，而函数应用则用于"解构"函数。若将二者结合会发生什么？当我们将类型为<span class="math">\(\sigma\)</span>的参数<span class="math">\(u\)</span>应用于匿名函数fun <span class="math">\(x: \sigma \mapsto t[x]\)</span>时（其中<span class="math">\(t[x]\)</span>表示可能包含<span class="math">\(x\)</span>的某个项），我们将得到项<span class="math">\(t[u]\)</span>。（这是简化后的理解。实际上，若<span class="math">\(t[x]\)</span>含有绑定符，则需重命名绑定变量以避免捕获u的自由变量。在Lean中，这种重命名会自动完成。）以下是应用匿名函数的几个示例：</p>


<p>虽然我们的函数是一元的（即只接受一个参数），但可以通过嵌套fun表达式，使用一种称为柯里化（currying）的巧妙技术来构建多元函数。例如，fun <span class="math">\(x: \sigma \mapsto\)</span> (fun <span class="math">\(y: \tau \mapsto x\)</span> )表示一个类型为<span class="math">\(\sigma \rightarrow(\tau \rightarrow \sigma)\)</span>的函数，它接受两个参数并返回第一个参数。严格来说，<span class="math">\(\sigma \rightarrow(\tau \rightarrow \sigma)\)</span>接受单个参数并返回一个函数，该函数随后再接受一个参数。</p>


<p>函数应用遵循相同规则：若<span class="math">\(\mathrm{K}:=(\)</span> fun <span class="math">\(x: \mathbb{Z} \mapsto(\)</span> fun <span class="math">\(y: \mathbb{Z} \mapsto x))\)</span>，则<span class="math">\(K_{1}=(\)</span> fun <span class="math">\(y: \mathbb{Z} \mapsto 1)\)</span>且<span class="math">\((K 1) \theta=1\)</span>。函数<span class="math">\(K\)</span>在<span class="math">\(K 1\)</span>中仅接受单一参数，此时称为部分应用，因为它仍可接收额外参数。</p>

<div class="math">$$
\begin{aligned}
\sigma \rightarrow \tau \rightarrow v \text { for } &amp; \sigma \rightarrow(\tau \rightarrow v) \\
t u v \text { for } &amp; (t u) v \\
\text { fun } x: \sigma \mapsto \text { fun } y: \tau \mapsto t \text { for } &amp; \text { fun } x: \sigma \mapsto(\text { fun } y: \tau \mapsto t)
\end{aligned}
$$</div>

<p>柯里化是个非常有用的概念，因此我们将省略大多数括号，直接写作</p>

<div class="math">$$
\begin{aligned}
&amp; \text { fun }(x: \sigma)(y: \tau) \mapsto t \text { for fun } x: \sigma \mapsto \text { fun } y: \tau \mapsto t \\
&amp; \text { fun } x y: \sigma \mapsto t \text { for fun }(x: \sigma)(y: \sigma) \mapsto t
\end{aligned}
$$</div>

<p>我们还将使用以下缩写：</p>

<div class="math">$$
\text { fun } x \mapsto t \text { for fun } x: \sigma \mapsto t
$$</div>

<p>此外，在匿名函数fun <span class="math">\(x: \sigma \mapsto t\)</span>中，通常可以省略类型标注: <span class="math">\(\sigma\)</span>，直接写作</p>


<p>随后Lean会尝试根据函数体<span class="math">\(t\)</span>及匿名函数所处的上下文来推断类型。类型推断能简化符号表示并减少击键次数。</p>


<p>在数学中，通常以中缀语法书写二元运算符（例如<span class="math">\(x+y\)</span>）。此类表示法在Lean中同样适用，作为柯里化函数应用的语法糖（例如add <span class="math">\(x y\)</span>）。</p>

<pre><code>opaque a : <span class="math">\(\mathbb{Z}\)</span>
opaque b : <span class="math">\(\mathbb{Z}\)</span>
opaque <span class="math">\(f: \mathbb{Z} \rightarrow \mathbb{Z}\)</span>
opaque g : <span class="math">\(\mathbb{Z} \rightarrow \mathbb{Z} \rightarrow \mathbb{Z}\)</span>
#check fun <span class="math">\(x: \mathbb{Z} \mapsto g(f(g a x))(g x b)\)</span>
#check fun <span class="math">\(x \mapsto g(f(g a x))(g x b)\)</span>
</code></pre>

<p>在Lean中工作的一种方式是使用opaque命令声明所需的类型和常量。考虑以下声明：</p>


<p>前四行声明了四个常量（<span class="math">\(a, b, f, g\)</span>），可用于构建项。最后两行使用#check命令对项进行类型检查并显示其类型。若采用传统数学符号，最后一行对应的项应写作<span class="math">\(x \mapsto g(f(g(a, x)), g(x, b))\)</span>。井号前缀表示诊断命令：这类命令对调试很有用，但通常不会保留在Lean文件中。</p>


<h3>1.3 类型检查与类型推断</h3>
<p>当Lean解析一个项时，会检查该项是否良类型化。在此过程中，若省略了绑定变量的类型（例如fun <span class="math">\(x \mapsto\)</span> square (square <span class="math">\(x\)</span> )中的<span class="math">\(x\)</span>类型），系统会尝试推断其类型。</p>


<p>对于简单类型理论而言，类型检查和类型推断是可判定问题。但诸如重载（允许多个常量复用同一名称，例如<span class="math">\(\theta: \mathbb{N}\)</span>与<span class="math">\(\theta: \mathbb{R}\)</span>）等高级特性可能导致不可判定性。Lean采用一种务实的、面向计算机科学的方法，当存在多种可能类型时，假定数字<span class="math">\(\theta, 1,2, \ldots\)</span>具有<span class="math">\(\mathbb{N}\)</span>类型。</p>


<p>Lean的类型系统可表述为一个形式系统。形式系统由判断（judgments）和用于生成判断的推导规则构成。类型判断的形式为<span class="math">\(C \vdash t: \sigma\)</span>，表示在局部上下文C中，项<span class="math">\(t\)</span>具有类型<span class="math">\(\sigma\)</span>。例如，判断<span class="math">\(\vdash\)</span> abs <span class="math">\(: \mathbb{Z} \rightarrow \mathbb{N}\)</span>表明常量abs在空局部上下文中具有类型<span class="math">\(\mathbb{Z} \rightarrow \mathbb{N}\)</span>。</p>


<p>局部上下文给出了<span class="math">\(t\)</span>中未被fun绑定的变量类型，用于追踪<span class="math">\(t\)</span>外部绑定器所绑定的变量。若同一变量<span class="math">\(x\)</span>被多次绑定，最后一次出现会遮蔽之前的绑定。例如，判断式<span class="math">\(x: \mathbb{Z}, y: \mathbb{N}, y: \mathbb{Z} \vdash y: \mathbb{Z}\)</span>表明在局部上下文<span class="math">\(x: \mathbb{Z}, y: \mathbb{N}, y: \mathbb{Z}\)</span>中，变量<span class="math">\(y\)</span>具有类型<span class="math">\(\mathbb{Z}\)</span>。</p>


<p>对于简单类型理论，类型判断由四条类型规则生成，每种项对应一条规则：</p>


<p><img src="img-0.jpeg" alt="img-0.jpeg"></p>

<p>每条规则包含零个或多个前提（位于水平线上方）、一个结论（位于线下）以及可能存在的侧边条件（位于右侧）。前提是类型判断语句，而侧边条件则是针对规则中出现的数学变量所设定的任意数学条件。为了展示前提，我们需要持续向上进行推导，稍后将看到具体示例。至于侧边条件，我们可以运用数学的全部工具集来证明其成立。</p>

<p>前两条标记为Cst和VAR的规则没有前提条件，但包含必须满足的侧边条件才能使规则生效。最后两条规则以一个或两个判断作为前提，并生成新的判断。FUN是唯一会修改局部上下文的规则：当我们进入匿名函数体<span class="math">\(t\)</span>时，需要记录绑定变量<span class="math">\(x\)</span>的存在及其类型，以便在<span class="math">\(t\)</span>中遇到<span class="math">\(x\)</span>时能正确处理。</p>


<p>我们可以利用这套规则系统，通过逆向（即自底向上）的方式应用这些规则，构建类型判断的形式推导，从而证明给定项是良类型的。与自然树类似，推导树的根部位于底部。被推导的判断出现在根部，每个分支都以无前提规则的应用结束。规则应用通过水平线和标签表示。以下类型推导证明了项 fun <span class="math">\(x: \mathbb{Z} \mapsto\)</span> abs <span class="math">\(x\)</span> 在任意局部上下文 C 中具有类型 <span class="math">\(\mathbb{Z} \rightarrow \mathbb{N}\)</span>：</p>

<p><img src="img-1.jpeg" alt="img-1.jpeg"></p>

<p>自底向上阅读证明时，请注意局部上下文如何被贯穿传递，以及如何通过FUN规则进行扩展。该规则将fun绑定的变量移至局部上下文中，使得在推导树更高处可以应用VAR规则。若变量<span class="math">\(x\)</span>已在C中声明，则在进入fun表达式后会被<span class="math">\(x: \mathbb{Z}\)</span>所遮蔽。</p>


<p>综上所述，该类型系统由推导规则组成，这些规则可以（1）用数学变量的任意值实例化，并（2）连接起来形成推导树。</p>

<p>以下是第二个示例，这次从空的本地上下文开始：</p>
<p><img src="img-2.jpeg" alt="img-2.jpeg"></p>

<p>目前的两个示例都是良类型的。如果我们从一个不良类型的项开始，或者在推导树根部的判断中指定了错误的类型或上下文，我们将发现无法完成推导。一个推导过程构成了对某个项在给定上下文中是良类型且具有指定类型的证明。</p>

<p>上述类型系统仅检查项是否良类型化，并不验证类型本身的良构性。例如，给定一元类型构造器List，List <span class="math">\(\mathbb{Z}\)</span>（整数列表的类型）是良构的，而<span class="math">\(\mathbb{Z}\)</span> List和List List则是非良构的。对于简单类型理论，良构性检查很简单：只应使用已声明的类型构造器，且每个<span class="math">\(n\)</span>元类型构造器必须恰好传入<span class="math">\(n\)</span>个类型参数。</p>

<h3>1.4 类型栖居问题</h3>
<p>给定类型<span class="math">\(\sigma\)</span>，类型栖居问题在于在空局部上下文中寻找该类型的"栖居者"——即类型为<span class="math">\(\sigma\)</span>的项。这看似无意义的练习，但正如我们将在第4章看到的，该问题与寻找命题证明密切相关。"寻找类型为<span class="math">\(\sigma\)</span>的项"这类看似愚蠢的练习，实则是掌握定理证明的良好训练。</p>


<p>尽管该问题在一般情况下是不可判定的，但通过正确的策略我们可以取得很大进展。要构造给定类型的项，可从占位符 _ 开始，递归应用以下两个步骤的组合：</p>
<ol>
<li>若类型形如<span class="math">\(\sigma \rightarrow \tau\)</span>，可能的居民是一个匿名函数，形式为 fun <span class="math">\(x: \sigma \mapsto-\)</span>，其中 _ 是类型为<span class="math">\(\tau\)</span>的缺失项的占位符。Lean会将 _ 标记为错误；如果在Visual Studio Code中悬停其上，工具提示会显示缺失项的类型以及局部上下文中声明的任何变量。</li>
<li>给定类型<span class="math">\(\sigma\)</span>（可能是函数类型），可以使用任何常量c或变量<span class="math">\(x\)</span>（其类型为<span class="math">\(\tau_{1} \rightarrow \cdots \rightarrow \tau_{n} \rightarrow \sigma\)</span>）来构建类型为<span class="math">\(\sigma\)</span>的项。对于每个参数，需要放置占位符，得到 c _ ... 或 <span class="math">\(x_{-} \ldots\)</span>。这些占位符可通过相同策略递归消除。</li>
</ol>

<div class="math">$$
(\alpha \rightarrow \beta \rightarrow \gamma) \rightarrow((\beta \rightarrow \alpha) \rightarrow \beta) \rightarrow \alpha \rightarrow \gamma
$$</div>

<p>作为示例，我们将应用该策略来寻找一个类型为</p>

<div class="math">$$
\sigma:=\alpha \rightarrow \beta \rightarrow \gamma \text { and } \tau:=\left((\beta \rightarrow \alpha) \rightarrow \beta\right) \rightarrow \alpha \rightarrow \gamma
$$</div>

<p>最初，只有步骤1适用，其中</p>


<p>（请注意<span class="math">\(\rightarrow\)</span>是右结合的。）这将生成项fun <span class="math">\(f \mapsto-\)</span>，其类型正确但留有占位符。由于参数<span class="math">\(f\)</span>具有函数类型<span class="math">\(\sigma\)</span>，使用名称<span class="math">\(f\)</span>是合理的。接着我们递归处理类型为<span class="math">\(\tau\)</span>的占位符，此时仍只能应用步骤1，最终得到项fun <span class="math">\(\mathrm{f} g \mapsto-\)</span>，其中<span class="math">\(g\)</span>的类型为<span class="math">\((\beta \rightarrow \alpha) \rightarrow \beta\)</span>而占位符类型为<span class="math">\(\alpha \rightarrow \gamma\)</span>。第三次应用步骤1后得到fun <span class="math">\(f g\)</span> a <span class="math">\(\mapsto-\)</span>，此处a的类型为<span class="math">\(\alpha\)</span>，占位符类型为<span class="math">\(\gamma\)</span>。</p>

<div class="math">$$
\mathrm{f}: \alpha \rightarrow \beta \rightarrow \gamma, \mathrm{~g}:(\beta \rightarrow \alpha) \rightarrow \beta, \mathrm{a}: \alpha
$$</div>

<p>此时，步骤1已不再适用。让我们看看步骤2是否可行。占位符周围的上下文包含以下变量：</p>


<p>回想我们正试图构造一个类型为<span class="math">\(\gamma\)</span>的项。唯一可用于实现此目标的变量是<span class="math">\(f\)</span>：它接受两个参数并返回一个类型为<span class="math">\(\gamma\)</span>的值。因此我们将占位符替换为项<span class="math">\(f_{-}\)</span>，其中两个新占位符代表缺失的参数。将所有内容整合后，现在得到的项是fun <span class="math">\(\mathrm{f} g \mathrm{a} \mapsto \mathrm{f}_{\text {_ }}\)</span>。</p>


<p>根据f的类型，占位符的类型分别为<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>。第一个占位符容易填充，再次应用步骤2，只需直接提供类型为<span class="math">\(\alpha\)</span>的a且无需参数。对于第二个占位符，我们通过变量<span class="math">\(g\)</span>应用步骤2，这是<span class="math">\(\beta \mathrm{s}\)</span>的唯一来源。由于<span class="math">\(g\)</span>需要一个参数，我们必须提供一个占位符。这意味着当前项为fun <span class="math">\(\mathrm{f} g \mathrm{a} \mapsto \mathrm{f} \mathrm{a}\left(\mathrm{g}_{-}\right)\)</span>。</p>


<p>我们即将完成。唯一剩下的占位符类型是<span class="math">\(\beta \rightarrow \alpha\)</span>，这正是g的参数类型。应用步骤1，我们将占位符替换为fun b <span class="math">\(\mapsto-\)</span>，其中_的类型为<span class="math">\(\alpha\)</span>。这里我们可以直接填入a。最终得到的项是fun <span class="math">\(\mathrm{f} g \mathrm{a} \mapsto \mathrm{f} \mathrm{a}(\mathrm{g}\)</span> (fun b <span class="math">\(\mapsto\)</span> a))。</p>


<p>上述推导过程虽然繁琐但具有确定性：在每一步中，要么适用步骤1要么适用步骤2，但不会同时适用。不过这种情况在更普遍的情形下并不总是成立。</p>


<p>对于其他某些类型，我们可能会遇到死胡同而需要回溯，也可能完全失败且无处可回溯。</p>

<p>核心思想在于术语应始终保持语法正确。在Visual Studio Code中，我们唯一应该看到的红色下划线应仅出现在占位符下方。一般而言，软件开发的一个良好原则是：从一个可编译的程序开始，进行尽可能小的修改以获得新的可编译程序，如此循环直至程序完成。</p>

<h3>1.5 本章新引入的Lean结构摘要</h3>
<p>在本章及大多数其他章节末尾，我们会简要总结本章引入的结构。部分语法具有多重含义，这些将逐步介绍。详细信息请参阅《Lean 4手册》、《Lean 4定理证明教程》以及mathlib文档<span class="math">\({ }^{1}\)</span>。</p>


<h4>诊断命令</h4>
<p>#check 检查并打印项的类型</p>


<h4>声明</h4>
<p>opaque用于声明一个未指定的新常量或类型</p>

<h2>第二章：程序与定理</h2>
<p>我们将继续学习Lean的基础知识，重点探讨程序与定理，但暂不涉及具体证明过程。特别地，我们将回顾如何定义新类型和函数，以及如何将这些元素的预期性质表述为定理。</p>

<h3>2.1 类型定义</h3>
<p>Lean归纳演算的一个显著特征是其对归纳类型的内置支持。归纳类型是一种通过应用称为构造子的特殊常量来构建值的类型。归纳类型是用简洁方式表示程序中无环数据的有效手段。您可能在其他名称下了解过它们，这些名称大体上是同义的，包括代数数据类型、归纳数据类型、自由生成数据类型、递归数据类型以及数据类型。</p>

<pre><code>inductive Nat : Type where
    | zero : Nat
    | succ : Nat -&gt; Nat
</code></pre>

<h3>2.1.1 自然数的定义</h3>
<p>归纳类型的"Hello, World!"示例是表示自然数的Nat类型(<span class="math">\(\mathbb{N}\)</span>)。在Lean中，它可以被定义如下：</p>


<p>第一行向世界宣告我们正在引入一个名为Nat的新类型，旨在表示自然数。第二行和第三行声明了两个新的构造子：Nat.zero : Nat 和 Nat.succ : Nat <span class="math">\(\rightarrow\)</span> Nat，它们可用于构建Nat类型的值。遵循计算机科学和逻辑学中的既定惯例，计数从零开始。第二个构造子使得这个归纳定义变得有趣——它需要一个Nat类型的参数来生成一个Nat类型的值。这些项</p>


<p>Nat. zero&lt;br&gt;Nat.succ Nat. zero&lt;br&gt;Nat.succ (Nat.succ Nat. zero)&lt;br&gt;<span class="math">\(\vdots\)</span>表示自然数类型Nat的不同值——零、它的后继数、后继数的后继数，以此类推。这种表示法称为一元计数法（或称皮亚诺数，得名于逻辑学家朱塞佩·皮亚诺）。关于Lean中皮亚诺数的另一种解释（以及一些精彩的电子游戏图形），可参阅凯文·巴扎德的文章《计算机能证明定理吗？》1</p>

<pre><code>inductive type-name (params 1 : type 1) ... (params k : type k) : Type
    where
    | constructor-name : constructor-type
        \vdots
    | constructor-name : constructor-type
</code></pre>

<p>类型声明的一般格式为</p>

<p>对于自然数，可以指示Lean使用熟悉的名称<span class="math">\(\theta,1,2, \ldots\)</span>，事实上预定义的<span class="math">\(\mathbb{N}\)</span>类型就提供了此类语法糖。但使用更冗长的表示法能更清晰地展现Lean的类型定义机制。</p>
<p>在本章附带的Lean文件中，Nat的定义位于一个由namespace MyNat和end MyNat限定的命名空间内，以将其作用域限制在文件的部分区域。在end MyNat之后，任何出现的Nat、Nat.zero或Nat.succ都将指向Lean预定义的自然数类型。同样地，整个文件被置于LoVe命名空间中，以避免与现有Lean库发生名称冲突。</p>
<pre><code>inductive LoVe.MyNat.Nat : Type
number of parameters: 0
constructors:
LoVe.MyNat.Nat.zero : Nat
LoVe.MyNat.Nat.succ : Nat <span class="math">\(\rightarrow\)</span> Nat
</code></pre>
<p>我们可以在Lean中随时使用#print命令查看之前的定义。例如，在MyNat命名空间内执行#print Nat会显示以下信息：</p>

<p>本指南对自然数的侧重体现了其偏向计算机科学的诸多特点之一。数论学者更关注整数<span class="math">\(\mathbb{Z}\)</span>和有理数<span class="math">\(\mathbb{Q}\)</span>；分析学家则倾向于研究实数<span class="math">\(\mathbb{R}\)</span>和复数<span class="math">\(\mathbb{C}\)</span>。但自然数在计算机科学中无处不在，且作为归纳类型具有极其简洁的定义。如第12章所示，它们还可用于构建其他类型。</p>

<pre><code>inductive AExp : Type where
    | num : <span class="math">\(\mathbb{Z} \rightarrow\)</span> AExp
    | var : String <span class="math">\(\rightarrow\)</span> AExp
    | add : AExp <span class="math">\(\rightarrow\)</span> AExp <span class="math">\(\rightarrow\)</span> AExp
    | sub : AExp <span class="math">\(\rightarrow\)</span> AExp <span class="math">\(\rightarrow\)</span> AExp
    | mul : AExp <span class="math">\(\rightarrow\)</span> AExp <span class="math">\(\rightarrow\)</span> AExp
    | div : AExp <span class="math">\(\rightarrow\)</span> AExp <span class="math">\(\rightarrow\)</span> AExp
</code></pre>

<h4>2.1.2 算术表达式的定义</h4>
<p>我们的下一个示例使用整数。若要规范一个计算器程序或编程语言，我们可能需要定义一个类型来表示作为抽象语法树的算术表达式。该示例展示了如何在Lean中实现这一点：</p>

<p>从数学角度而言，该定义等价于通过以下形成规则归纳地定义类型AExp：</p>
<ol>
<li>对于每个整数<span class="math">\(i\)</span>，项AExp.num <span class="math">\(i\)</span>都是AExp值。（直观上，构造器AExp.num将整数"装箱"为算术表达式。）</li>
<li>对于每个字符串<span class="math">\(x\)</span>，项AExp.var <span class="math">\(x\)</span>都是AExp值。</li>
<li>若<span class="math">\(e_{1}\)</span>和<span class="math">\(e_{2}\)</span>是AExp值，则AExp.add <span class="math">\(e_{1} e_{2}\)</span>、AExp.sub <span class="math">\(e_{1} e_{2}\)</span>、AExp.mul <span class="math">\(e_{1} e_{2}\)</span>和AExp.div <span class="math">\(e_{1} e_{2}\)</span>也都是AExp值。上述定义是完备的——AExp唯一可能的值就是通过规则1至3构建的那些值。此外，通过不同形成规则构建的AExp值互不相同。Joseph Goguen用"无冗余、无混淆"这句格言概括了归纳类型的这两个特性。</li>
</ol>
<pre><code>public interface AExp { }
public class Num implements AExp {
    public int num;
    public Num(int num) { this.num = num; }
}
public class Var implements AExp {
    public String var;
    public Var(String var) { this.var = var; }
}
public class Add implements AExp {
    public AExp left;
    public AExp right;
    public Add(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
public class Sub implements AExp {
    public AExp left;
    public AExp right;
    public Sub(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
public class Mul implements AExp {
    public AExp left;

    public AExp right;
    public Mul(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
public class Div implements AExp {
    public AExp left;
    public AExp right;
    public Div(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
</code></pre>

<p>将上述简洁的Lean语言AExp规范与实现相同功能的Java程序进行对比可能颇具启发意义。该程序由一个接口和六个实现类组成，分别对应AExp类型及其六个构造器：</p>

<pre><code>class AExp:
    pass
class Num(AExp):
    def __init__(self, num):
        self.num = num
class Var(AExp):
    def __init__(self, var):
        self.var = var
class Add(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
class Sub(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
class Mul(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
class Div(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
</code></pre>
<p>在Python中，类声明如下所示：</p>
<pre><code>inductive List ( <span class="math">\(\alpha\)</span> : Type) where
    | nil : List <span class="math">\(\alpha\)</span>
    | cons : <span class="math">\(\alpha \rightarrow\)</span> List <span class="math">\(\alpha \rightarrow\)</span> List <span class="math">\(\alpha\)</span>
</code></pre>

<h4>2.1.3 列表的定义</h4>
<p>接下来我们考虑有限列表的类型：</p>


<p>该类型是多态的：它通过类型<span class="math">\(\alpha\)</span>进行参数化，我们可以用具体类型来实例化。例如，List <span class="math">\(\mathbb{Z}\)</span>表示整数列表的类型，而List (List <span class="math">\(\mathbb{R}\)</span>)则表示实数列表的列表的类型。类型构造器List接受一个类型作为参数并返回一个类型。与Java中的泛型和C++中的模板类似，多态性是一种提供参数化类型的机制。</p>

<pre><code>#check List.nil
#check List.cons
</code></pre>

<p>以下命令展示了构造函数的类型：</p>

<pre><code>List.nil : List ?m.2396
List.cons : ?m.2397\mathrm{ -&gt; List ?m.2397 -&gt; List ?m.2397
</code></pre>

<p>输出结果与我们预期的有所不同：</p>


<p>即便我们尝试将自身限制在Lean语言的某个片段中，Lean仍经常在输出中向我们展示更高级的构造，例如上文中的?m.2396和?m.2397。我们的建议是保持一种灵活的态度：不必担心第一次接触时未能完全理解所有内容。运用你的常识与想象力。最重要的是，切勿犹豫提问。</p>

<div class="math">$$
\begin{aligned}
 \text { []} & \text{ for List.nil } \\
 \mathrm{x}:: \mathrm{xs} & \text{ for List.cons x xs } \\
 {\left[\mathrm{x}_{1}, \ldots, \mathrm{x}_{n}\right]} &\text{ for } \mathrm{x}_{1}:: \ldots:: \mathrm{x}_{n}::[] \text { }
\end{aligned}
$$</div>

<p>Lean的内置列表为编写列表提供了语法糖：</p>


<p>::运算符与所有其他二元运算符一样，其结合优先级低于函数应用。因此，<span class="math">\(f x\)</span> :: List.reverse ys会被解析为(<span class="math">\(f x\)</span>) :: (List.reverse ys)。良好的编程实践应避免不必要的括号，它们会迅速降低代码可读性。此外，在中缀运算符周围添加空格以暗示正确的优先级也很重要。</p>


<p>函数式程序员常使用诸如<span class="math">\(x \mathrm{~s}, \mathrm{ys}, \mathrm{zs}\)</span>这样的名称表示列表，尽管Lean中也常见使用1。列表包含多个元素，因此复数形式很自然。猫的列表可能被称为cats；猫列表的列表则可能称为catss。当非空列表以头部和尾部形式呈现时，我们通常写作<span class="math">\(x\)</span> :: xs或cat :: cats。</p>


<h3>2.2 函数定义</h3>
<p>若仅需声明函数，可使用opaque命令（1.2节）。但通常我们需要定义函数行为，这时可以使用def命令。由于Lean植根于函数式编程，函数被定义为求值到结果的数学表达式，而非修改状态的命令式程序。因此，递归（而非while或for循环）成为遍历数据的主要机制。</p>

<pre><code>def fib : <span class="math">\(\mathbb{N} \rightarrow \mathbb{N}\)</span>
    | 0 =&gt; 0
    | 1 =&gt; 1
    | <span class="math">\(n+2=&gt;\)</span> fib <span class="math">\((n+1)+\)</span> fib <span class="math">\(n\)</span>
</code></pre>

<h3>2.2.1 自然数递归</h3>
<p>让我们通过一个简单示例来理解递归的工作原理。Lean中斐波那契数列的定义如下：</p>


<p>左侧的模式对应于函数的参数。此处，<span class="math">\(f i b\)</span>被声明为接收一个类型为<span class="math">\(\mathbb{N}\)</span>的参数，因此我们对单个自然数进行模式匹配。当输入符合给定形式时，对应的模式会被触发。例如，若输入为1，则模式1与之匹配，并计算对应的右侧表达式。若输入为5，则模式<span class="math">\(n+2\)</span>被触发（其中<span class="math">\(n:=3\)</span>），随后将<span class="math">\(n\)</span>设为3计算右侧表达式，得到fib <span class="math">\(4+\)</span> fib 3。</p>

<pre><code>def name (params <span class="math">\({ }_{1}:\)</span> type <span class="math">\(_{1}\)</span> ) ... (params <span class="math">\(_{m}:\)</span> type <span class="math">\(_{m}\)</span> ) : type
    | patterns <span class="math">\(_{1}=&gt;\)</span> result <span class="math">\(_{1}\)</span>
      <span class="math">\(\vdots\)</span>
    | patterns <span class="math">\(_{n}=&gt;\)</span> result <span class="math">\(_{n}\)</span>
</code></pre>

<p>递归定义的一般格式为</p>


<p>参数params<span class="math">\(_{1}\)</span>至params<span class="math">\(_{m}\)</span>不可进行模式匹配，仅能对类型声明中其余参数进行匹配。若单行提供多个模式，则需用逗号分隔。模式可包含变量，这些变量将在对应右侧表达式中可见，构造器亦可包含其中。</p>

<pre><code>def add : <span class="math">\(\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}\)</span>
    | m, Nat.zero =&gt; m
    | m, Nat.succ n =&gt; Nat.succ (add m n)
</code></pre>

<p>自然数的基本算术运算，如加法、乘法和幂运算，可以通过递归来定义。当然，这些运算在Lean中已有定义（如+、*和^），但它们仍是很好的练习。我们从加法开始：</p>


<p>我们同时对两个参数进行模式匹配，区分第二种参数为零和非零的情况。每次对add的递归调用都会从第二个参数中剥离一个Nat.succ构造子。除了Nat.zero和Nat.succ n，Lean还允许我们使用语法糖形式0和<span class="math">\(n+1\)</span>来表示。</p>

<pre><code>#eval add 2 7
#reduce add 2 7
</code></pre>

<p>我们可以使用#eval或#reduce命令来评估应用add函数于数字后的结果：</p>

<p>两个命令在Visual Studio Code中都会输出9。#eval采用优化过的解释器执行，而#reduce使用Lean的推理内核，效率相对较低。</p>

<p>在每次定义函数时提供若干测试是良好的实践，这能确保其行为符合预期。你甚至可以将#eval或#reduce调用保留在Lean文件中作为文档。</p>

<pre><code>def mul : <span class="math">\(\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}\)</span>
    | _, Nat.zero =&gt; Nat.zero
    | m, Nat.succ n =&gt; add m (mul m n)
</code></pre>

<p>乘法的定义与加法类似：</p>


<p>下划线(_)表示未使用的变量。我们本可以命名（例如m），但使用_能更好地表明我们的意图。</p>

<pre><code>\#eval mul 27
</code></pre>
<p>下方的 #eval 命令如期打印出 14：</p>
<pre><code>def power : N -&gt; N -&gt; N
    | _, Nat.zero =&gt; 1
    | m, Nat.succ n =&gt; mul m (power m n)
</code></pre>

<p>幂运算（"<span class="math">\(m\)</span>的<span class="math">\(n\)</span>次方"）可以通过多种方式定义。我们的第一个提案在结构上与乘法的定义完全相同：</p>

<pre><code>def powerParam (m : N) : N -&gt; N
    | Nat.zero =&gt; 1
    | Nat.succ n =&gt; mul m (powerParam m n)
</code></pre>

<p>由于第一个参数<span class="math">\(m\)</span>在递归调用中保持不变（即幂运算<span class="math">\(m n\)</span>），我们可以将其提取出来并置于函数名旁边作为参数，放在冒号之前以引入函数的类型（不包含参数m）：</p>


<p>从外部看，这两种定义并无区别。事实上，我们已经在列表构造器（第2.1节）的类型参数<span class="math">\(\alpha\)</span>中见过这种语法。</p>

<pre><code>def iter (\alpha\mathrm : Type) (z : \alpha)(f : \alpha -&gt; \alpha): N -&gt; \alpha
    | Nat.zero =&gt; z
    | Nat.succ n =&gt; f (iter \alpha\mathrm{ z f n)
def powerIter (m n : N) : N :=
    iter N 1 (mul m) n
</code></pre>

<p>另一种可能的定义方式是先引入一个通用迭代器，然后使用正确的参数调用它：</p>

<div class="math">$$
\underbrace{f(f(\cdots(f z) \cdots))}_{n \text { times }}
$$</div>

<p>iter函数接收一个类型<span class="math">\(\alpha\)</span>、一个"零"值<span class="math">\(z\)</span>、一个一元函数<span class="math">\(f\)</span>以及一个自然数<span class="math">\(n\)</span>，并计算</p>

<div class="math">$$
\underbrace{\operatorname{mul} m(\operatorname{mul} m(\cdots(\operatorname{mul} m 1) \cdots))}_{n \text { times }}
$$</div>
<p>这是高阶函数的一个示例：该函数以另一个函数（此处为<span class="math">\(f\)</span>）作为参数。在函数式编程中，函数与其他对象一视同仁，既可作为参数传递，也可作为函数返回值。此处我们使用iter函数计算<span class="math">\(m\)</span>的<span class="math">\(n\)</span>次幂，表达式为</p>
<pre><code>def name (params: : type ; ... (params: : type
    result
</code></pre>
<p>最后要注意的是，powerIter的定义并非递归形式。对于没有模式匹配的非递归函数，其语法结构非常简单：</p>

<h4>2.2.2 算术表达式的递归处理</h4>
<p>回到算术表达式的类型定义，如果我们要在Java中实现eval函数，很可能会将其作为AExp接口的一部分，并在每个子类中实现。对于Add、Sub、Mul和Div操作，我们会递归地对左右对象调用eval方法。</p>

<pre><code>def eval (env : String <span class="math">\(\rightarrow \mathbb{Z}\)</span> ) : AExp <span class="math">\(\rightarrow \mathbb{Z}\)</span>
    | AExp.num i <span class="math">\(\quad=&gt;\)</span> i
    | AExp.var <span class="math">\(x \quad=&gt;\)</span> env <span class="math">\(x\)</span>
    | AExp.add <span class="math">\(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\)</span> eval env <span class="math">\(\mathrm{e}_{1}+\)</span> eval env <span class="math">\(\mathrm{e}_{2}\)</span>
    | AExp.sub <span class="math">\(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\)</span> eval env <span class="math">\(\mathrm{e}_{1}-\)</span> eval env <span class="math">\(\mathrm{e}_{2}\)</span>
    | AExp.mul <span class="math">\(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\)</span> eval env <span class="math">\(\mathrm{e}_{1}+\)</span> eval env <span class="math">\(\mathrm{e}_{2}\)</span>
    | AExp.div <span class="math">\(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\)</span> eval env <span class="math">\(\mathrm{e}_{1} /\)</span> eval env <span class="math">\(\mathrm{e}_{2}\)</span>
</code></pre>

<p>在Lean中，语法非常简洁。我们定义一个单一函数，并通过模式匹配来区分六种情况：</p>


<p>注意这个函数是高阶的：它接受一个表示变量赋值"环境"的函数env。该环境在AExp.var情形中用于求取变量值，并在递归情形（AExp.add、AExp.sub、AExp.mul和AExp.div）中贯穿传递。</p>

<pre><code>#eval eval (fun x \mapsto 7) (AExp.div (AExp.var "y") (AExp.num 0))
</code></pre>

<p>或许您对AExp.div情况下的除以零问题有所顾虑。让我们通过#eval来看看它的表现，这里使用将所有变量赋值为7的环境：</p>


<p>输出结果为0。在Lean中，除法被巧妙地定义为全函数，当分母为零时返回零值。关于为何这种设计不会引发问题的清晰解释，可参阅Buzzard的博客。<span class="math">\({ }^{2}\)</span></p>

<pre><code>def append ( }\alpha\mathrm{ : Type) : List }\alpha\mathrm{ -&gt; List }\alpha\mathrm{ -&gt; List }\alpha
    | List.nil, ys =&gt; ys
    | List.cons x xs, ys =&gt; List.cons x (append }\alpha\mathrm{ xs ys)
</code></pre>

<h3>2.2.3 列表递归</h3>
<p>列表的递归函数可以用类似方式定义：</p>

<pre><code>#eval append N [3, 1] [4, 1, 5]
#eval append _ [3, 1] [4, 1, 5]
</code></pre>

<p>append函数接受三个参数：一个类型为<span class="math">\(\alpha\)</span>的参数和两个类型为List <span class="math">\(\alpha\)</span>的列表。</p>

<p>通过传入占位符_，我们让Lean根据另外两个参数的类型推断出类型<span class="math">\(\mathbb{N}\)</span>。</p>
<pre><code>def appendImplicit { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; List }\alpha\mathrm{ -&gt; List }\alpha
    | List.nil, ys =&gt; ys
    | List.cons x xs, ys =&gt; List.cons x (appendImplicit xs ys)
</code></pre>

<p>若要将类型参数<span class="math">\(\alpha\)</span>设为隐式，可将其置于花括号{ }中：</p>

<pre><code>def appendPretty { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow List }\alpha\mathrm{ List }\alpha
    | [], ys =&gt; ys
    | x :: xs, ys =&gt; x :: appendPretty xs ys
</code></pre>

<p>#eval appendImplicit <span class="math">\([3,1][4,1,5]\)</span>使用@符号（<span class="math">\(\square\)</span>）可使隐式参数显式化。这在指导Lean解析器时偶尔是必要的。
#eval @appendImplicit <span class="math">\(\mathbb{N}[3,1][4,1,5]\)</span>
#eval @appendImplicit _ [3, 1] [4, 1, 5]
我们可以在定义中使用语法糖，包括<span class="math">\(\Rightarrow\)</span>左侧的模式匹配和右侧表达式：</p>

<pre><code>def reverse { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow List }\alpha
    | [] =&gt; []
    | x :: xs =&gt; reverse xs ++ [x]
</code></pre>
<p>在Lean的标准库中，append函数是一个名为++的中缀运算符。我们可以用它来定义一个反转列表的函数：</p>

<h3>2.3 定理陈述</h3>
<p>使Lean同时成为证明助手和编程语言的关键在于，我们能够针对所定义的类型和常量陈述定理，并证明其成立。在交互式定理证明中，术语定理（theorem）、引理（lemma）、推论（corollary）、事实（fact）、性质（property）和真命题（true statement）基本可互换使用。同理，命题（proposition）、逻辑公式（logical formula）和陈述（statement）在此语境下也具有相同含义。</p>

<p>在Lean中，命题只是Prop类型的项。这与一阶逻辑形成鲜明对比，传统上一阶逻辑在语法上会区分项和公式。可被证明的命题称为定理（或引理、推论等）；否则称为非定理或假命题。数学家有时将"命题"作为定理的同义词使用（例如"命题3.14"），但在形式逻辑中命题也可能为假。</p>
<pre><code>theorem add_comm (m n : N) :
    add m n = add n m :=
    sorry
theorem add_assoc (l m n : N) :
    add (add l m) n = add l (add m n) :=
    sorry
theorem mul_comm (m n : N) :
    mul m n = mul n m :=
    sorry
theorem mul_assoc (l m n : N) :
    mul (mul l m) n = mul l (mul m n) :=
    sorry

theorem mul_add (l m n : N) :
    mul l (add m n) = add (mul l m) (mul l n) :=
    sorry
theorem reverse_reverse { }\alpha\mathrm{ : Type} (xs : List }\alpha\mathrm{ ) :
    reverse (reverse xs) = xs :=
    sorry
</code></pre>
<p>以下是关于第2.2节中定义的加法、乘法及列表反转操作的真命题示例：</p>
<pre><code>theorem name (params; : type; ) ... (paramsm : type m):
    statement :=
    proof
</code></pre>
<p>通用格式为</p>

<p>符号:=用于分隔定理陈述与其证明。定理的语法与不带模式匹配的def命令非常相似，其中用statement替代type，用proof替代result。在上述示例中，我们使用标记sorry作为实际证明的占位符。这个标记字面上是对未来读者和Lean系统缺失证明的致歉，同时也是需要我们消除的隐患。在第三、四章中，我们将学习如何实现这一点。</p>

<pre><code>opaque a : <span class="math">\(\mathbb{Z}\)</span>
opaque b : <span class="math">\(\mathbb{Z}\)</span>
axiom a_less_b :
    <span class="math">\(a&lt;b\)</span>
</code></pre>
<p>使用sorry作为证明的定理命令的直观语义是："这个命题应该是可证明的，但我尚未完成证明过程——抱歉。"有时，我们想表达一个相关的概念，即"让我们假设这个命题成立"。为此，Lean提供了axiom命令，该命令常与opaque配合使用。例如：</p>
<pre><code>axiom name (params; : type; ) ... (paramsm : type m):
    statement
</code></pre>

<p>在执行opaque命令后，我们除了a和b的类型外无法获取其更多信息。该公理指定了它们应具备的属性。该命令的通用格式为</p>


<p>公理是危险的，因为它们可能导致逻辑不一致，从而推导出False。例如，如果我们添加第二条公理声明a &gt; b，就能轻易推导出False。交互式定理证明的历史充斥着不一致的公理。众多轶事之一：在2020年"经过验证的程序与证明"会议上，一篇投稿论文因存在有缺陷的公理而被拒稿，其中一位评审委员从该公理推导出了False。<span class="math">\({ }^{3}\)</span>因此，我们通常应避免使用公理。</p>

<p>从Lean的视角来看，带有sorry标记的定理本质上等同于公理，可能破坏逻辑一致性。为避免误解，最好仅将sorry作为开发证明时的临时措施，而非替代更明确、诚实的公理声明。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">#eval</th>
  <th style="text-align:left">executes a term using an optimized interpreter</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">#print</td>
  <td style="text-align:left">prints the definition of a constant</td>
</tr>
<tr>
  <td style="text-align:left">#reduce</td>
  <td style="text-align:left">executes a term using Lean's inference kernel</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
  <th style="text-align:left">axiom</th>
  <th style="text-align:left">states an axiom</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">def</td>
  <td style="text-align:left">defines a new constant</td>
</tr>
<tr>
  <td style="text-align:left">inductive</td>
  <td style="text-align:left">introduces a type and its constructors</td>
</tr>
<tr>
  <td style="text-align:left">namespace ... end</td>
  <td style="text-align:left">collects declarations in a named scope</td>
</tr>
<tr>
  <td style="text-align:left">theorem</td>
  <td style="text-align:left">states a theorem and its proof</td>
</tr>
</tbody>
</table>
<h3>2.4 新引入的Lean构造诊断命令摘要</h3>
<h4>声明</h4>
<h4>证明命令</h4>
<p>sorry<br>表示缺失的证明或定义</p>

<h2>第3章：逆向证明</h2>
<p>策略（tactic）是一种作用于目标（即待证明命题）的过程，它要么完全证明该命题，要么生成新的子目标，亦或失败。当我们陈述定理时，定理陈述即为初始目标。当所有（子）目标通过合适的策略被消除后，证明即告完成。这里描述的大多数策略在《Lean 4中的定理证明》第5章中有更详细的说明。</p>

<p>策略是一种逆向证明机制，它们从目标出发，逆向追溯到已证定理。考虑定理<span class="math">\(a, a \rightarrow b\)</span>和<span class="math">\(b \rightarrow c\)</span>以及目标<span class="math">\(\vdash c\)</span>（如同类型判断，目标通过符号<span class="math">\(\vdash\)</span>标识）。非正式的逆向证明过程如下：</p>

<p>要证明<span class="math">\(c\)</span>，根据<span class="math">\(b \rightarrow c\)</span>，只需证明<span class="math">\(b\)</span>即可。
要证明<span class="math">\(b\)</span>，根据<span class="math">\(a \rightarrow b\)</span>，只需证明<span class="math">\(a\)</span>即可。
要证明<span class="math">\(a\)</span>，我们直接使用已知定理<span class="math">\(a\)</span>。
逆向证明的标志性特征就是"只需证明"这个短语。注意我们如何从一个目标推进到另一个目标（<span class="math">\(\vdash c, \vdash b, \vdash a\)</span>），直到没有待证目标为止。相比之下，正向证明会从定理a出发，逐步推导出目标定理c：</p>


<p>由<span class="math">\(a\)</span>和<span class="math">\(a \rightarrow b\)</span>可得<span class="math">\(b\)</span>；再由<span class="math">\(b\)</span>和<span class="math">\(b \rightarrow c\)</span>即得所求的<span class="math">\(c\)</span>。正向证明仅操作定理而非目标，我们将在第四章更深入地研究正向证明。</p>


<p>非形式化证明有时会采用混合风格的写法。只要通过"要证明……，只需证明……"等措辞明确标识出逆向推导步骤，这种写法是可行的。在目标命题前加上<span class="math">\(\vdash\)</span>符号可能有助于提醒这些主张尚未得证。</p>

<p>您可能熟悉的另一种证明表达形式是自然演绎法。与上述证明对应的自然演绎推导如下：</p>
<p><img src="img-3.jpeg" alt="img-3.jpeg"></p>
<p>当从上至下阅读时，该推导对应正向证明；当从下至上阅读时，则对应逆向证明。</p>

<h3>3.1 策略模式</h3>
<p>在第2章中，每当需要证明时，我们仅使用sorry占位符。对于策略式证明，我们现在将通过by进入策略模式。在此模式下，可以调用一系列策略。</p>


<p>策略作用于目标，该目标由待证明的命题<span class="math">\(Q\)</span>和局部上下文C组成。局部上下文包含形如<span class="math">\(x: \sigma\)</span>的变量声明和形如<span class="math">\(h: P\)</span>的假设。我们用<span class="math">\(C \vdash Q\)</span>表示一个目标，其中<span class="math">\(C\)</span>是变量和假设的列表，<span class="math">\(Q\)</span>是目标命题。</p>

<pre><code>theorem fst_of_two_props :
    Ya b : Prop, a -&gt; b -&gt; a :=
    by
        intro a b
        intro ha hb
        apply ha
</code></pre>
<p>为了使内容更具体，请考虑以下Lean示例：</p>
<p>注意蕴含箭头<span class="math">\(\rightarrow\)</span>是右结合的；这意味着<span class="math">\(a \rightarrow b \rightarrow a\)</span>等同于<span class="math">\(a \rightarrow(b \rightarrow a)\)</span>。直观地说，该陈述的含义是"a蕴含b蕴含a"，等价于"a且b蕴含a"。</p>

<p>我们将逐行回顾这个证明过程。关键字by表示我们进入策略模式，在此模式下可以通过策略来指定证明步骤。随后列出的策略每行一个，且所有策略保持相同的缩进级别。</p>

<div class="math">$$
\vdash \forall a b: \text { Prop, } a \rightarrow b \rightarrow a
$$</div>
<p>如果将光标置于by关键字上，Visual Studio Code会显示当前目标仅为原始定理陈述：</p>
<div class="math">$$
a b: \text { Prop } \vdash a \rightarrow b \rightarrow a
$$</div>

<p>接下来，策略
intro a b
告诉Lean固定两个自由变量<span class="math">\(a\)</span>和<span class="math">\(b\)</span>，对应同名绑定变量。该策略模拟了数学家在纸上的工作方式：要证明一个<span class="math">\(\forall\)</span>量化的命题，只需针对绑定变量的任意固定值进行证明即可。此时目标变为</p>


<p>其中命题<span class="math">\(a\)</span>和<span class="math">\(b\)</span>已在目标局部上下文中声明，位于<span class="math">\(\vdash\)</span>符号左侧。我们通常会像本例这样为自由变量和绑定变量使用相同名称，但这并非强制要求。一般而言，最佳实践是使用唯一名称并避免遮蔽已有变量。</p>


<p>除了使用一次带有两个变量名的intro调用外，我们也可以分两次调用intro，即先执行intro a再执行intro b。一般而言，每次带有<span class="math">\(n\)</span>个参数的intro调用会提取接下来的<span class="math">\(n\)</span>个量化变量。</p>

<p>intro策略不仅限于处理量化变量。在我们的证明脚本中，intro ha hb 指示Lean将前提条件<span class="math">\(a\)</span>和<span class="math">\(b\)</span>（来自<span class="math">\(a \rightarrow b \rightarrow\)</span>）移至局部上下文，并将这些假设分别命名为ha和hb。</p>
<div class="math">$$
a b: \text { Prop, ha : a, hb : b } \vdash a
$$</div>

<p>事实上，要证明一个蕴含式，只需将其左侧作为假设并证明其右侧即可。因此目标变为</p>


<p>习惯上会为假设名称添加前缀<span class="math">\(h\)</span>。最终，通过使用策略
apply ha
指示Lean将名为ha的假设a与目标<span class="math">\(\vdash\)</span> a进行匹配。由于a在语法上与自身完全一致，因此匹配成功。至此证明完成。</p>


<p>非正式地说，以类似纸笔数学的风格，我们可以将证明写作如下：</p>


<p>设<span class="math">\(a\)</span>和<span class="math">\(b\)</span>为命题。假设(ha) a与(hb) b为真。为证明a，我们使用假设ha。（数学家可能会用(1)、(2)等数字标签而非描述性名称来标记假设。）</p>

<pre><code>theorem fst_of_two_props_params (a b : Prop) (ha : a) (hb : b) :
    a :=
    by apply ha
</code></pre>

<p>回到Lean证明中，我们可以通过将变量和假设声明为定理参数来避免引入intro调用，如下所示：</p>

<div class="math">$$
a b: \text { Prop, ha : a, hb : b } \vdash a
$$</div>

<p>目标是</p>


<p>该定理的所有参数在上下文中立即可用。通过应用ha即可完成目标证明，正如我们之前的示例所示。</p>

<pre><code>theorem prop_comp (a b c : Prop) (hab : a -&gt; b) (hbc : b -&gt; c) :
    a -&gt; c :=
    by
        intro ha
        apply hbc
        apply hab
        apply ha
</code></pre>

<p>以下是一个连续多次应用apply的示例：</p>


<p>戴上数学家的思维帽，我们可以将上述证明过程表述如下：
假设（ha）a为真。
要证明c，根据假设hbc只需证明b。
要证明b，根据假设hab只需证明a。
要证明a，我们直接使用假设ha。</p>


<h3>3.2 基础策略</h3>
<p>intro和apply策略是战术式证明的核心工具。其他基础策略包括exact、assumption、rfl以及ac_rfl。只要我们足够耐心，不依赖更强大的自动化证明工具，这些策略足以完成大部分推理过程。它们也可用于解决各类逻辑谜题。</p>


<p>下方细长的大方括号[ ]用于包裹可选语法。</p>

<div class="math">$$
\text { intro }\left[\text { name }_{1} \ldots \text { name }_{n}\right]
$$</div>

<h4>介绍</h4>
<p>intro策略将目标中前置的<span class="math">\(\forall\)</span>量词变量或前置假设<span class="math">\(\mathrm{a} \rightarrow\)</span>移至局部上下文中。该策略接受一个可选参数，用于指定变量或假设在上下文中的名称，覆盖默认命名。若提供多个名称（即<span class="math">\(\mathrm{n}&gt;1\)</span>），则会移动多个变量或假设。</p>


<p>对于可证明的目标，intro策略总能生成一个可证明的新目标，因此被称为安全策略。</p>


<h4>应用</h4>
<p>应用 定理或假设</p>


<p>apply策略会将当前目标与指定定理或假设的结论进行匹配，并将该定理或假设的前提条件添加为新的子目标。此匹配过程会执行至计算完成。</p>


<p>使用apply策略时必须谨慎，因为它可能将可证目标转化为不可证的子目标。例如，若当前目标是<span class="math">\(\vdash\)</span> True而我们应用定理False <span class="math">\(\rightarrow\)</span> True，结论True会与目标中的True匹配，最终得到不可证的子目标<span class="math">\(\vdash\)</span> False。因此我们说apply策略是不安全的。</p>


<h4>exact</h4>
<p>exact 定理或假设</p>

<p>exact策略会将目标命题与指定的定理或假设进行精确匹配，从而完成证明。虽然在此类情况下我们通常可以使用apply策略，但exact能更清晰地传达我们的意图。</p>

<h4>assumption</h4>
<p>assumption策略会从局部上下文中寻找与目标匹配的假设，并通过应用该假设来证明目标。</p>

<div class="math">$$
\begin{array}{ll}
\alpha \text {-conversion } &amp; (\text { fun } x \mapsto f x)=(\text { fun } y \mapsto f y) \\
\beta \text {-conversion } &amp; (\text { fun } x \mapsto f x) a=f a \\
\delta \text {-conversion } &amp; \text { double } 5=5+5 \\
\zeta \text {-conversion } &amp; (\text { let } n: \mathbb{N}:=2 ; n+n)=4 \\
\eta \text {-conversion } &amp; (\text { fun } x \mapsto f x)=f \\
\iota \text {-conversion } &amp; \text { Prod.fst }(a, b)=a
\end{array}
$$</div>

<h4>rfl策略</h4>
<p>rfl策略用于证明形如<span class="math">\(\vdash 1=r\)</span>的目标，其中等式两边<span class="math">\(l\)</span>和<span class="math">\(r\)</span>在计算后语法上完全相等。此处的计算主要指定义的展开，同时也包括匿名函数应用到参数时的规约等。这些转换规则有传统命名。主要转换规则及示例如下（假设全局上下文中包含定义def double <span class="math">\((n: \mathbb{N}): \mathbb{N}:=n+n\)</span>）：</p>

<p>将转换规则从左到右重复应用为重写规则的过程称为归约；而反向应用一次转换规则则称为展开。</p>

<p>简而言之，要证明<span class="math">\(\vdash 1=r\)</span>，rfl策略会展开<span class="math">\(l\)</span>和<span class="math">\(r\)</span>中的定义，并执行<span class="math">\(\beta\)</span>-规约及其他规约。若在此规约过程中<span class="math">\(l\)</span>和<span class="math">\(r\)</span>在语法上变为完全一致，该策略即成功。通常，当数学家会说"根据定义"时，rfl策略就能成功。</p>


<h4>ac_rfl</h4>
<p>ac_rfl 与 rfl 类似，但可用于处理结合律（例如<span class="math">\((a+b)+c=a+(b+c))\)</span>）和交换律（例如<span class="math">\(a+b=b+a)\)</span>）的推理。这适用于已注册为结合且可交换的二元运算，如算术类型中的<span class="math">\(*\)</span>和*运算，以及集合中的<span class="math">\(\cup\)</span>和<span class="math">\(\cap\)</span>运算。我们将在第3.6节看到一个示例。</p>


<h4>sorry指令</h4>
<p>我们在第2章遇到的sorry证明命令，可作为策略用于战术证明的任何阶段。它会"证明"当前目标而无需实际验证，使用时需谨慎。</p>

<pre><code>theorem And_swap (a b : Prop) :
    <span class="math">\(a \wedge b \rightarrow b \wedge a:=\)</span>
    by
        intro hab
        apply And.intro
        apply And.right
        exact hab
        apply And.left
        exact hab
</code></pre>
<h3>3.3 逻辑连接词与量词的推理</h3>
<p>在学习如何对自然数、列表或其他数据类型进行推理之前，我们必须先掌握Lean逻辑连接词与量词的推理方法。让我们从一个简单例子开始：合取交换律<span class="math">\((\wedge)\)</span>。</p>

<p>在此，我们建议您将光标悬停在Visual Studio Code中的示例上，以查看证明状态的序列。通过将光标置于每条命令上或紧随其后，您可以看到该行命令产生的效果。对于最后一行，Lean仅会显示“无目标”。</p>

<pre><code>And.intro <span class="math">\(: ? a \rightarrow ? b \rightarrow ? a \wedge ? b\)</span>
    And.left : ?a <span class="math">\(\wedge\)</span> ?b <span class="math">\(\rightarrow\)</span> ?a
And.right : ?a <span class="math">\(\wedge\)</span> ?b <span class="math">\(\rightarrow\)</span> b
</code></pre>
<p>该证明采用了典型的引入-应用-精确化混合策略。它运用了以下定理：</p>

<p>其中问号(?)表示可被实例化的变量——例如通过将目标结论与定理结论进行匹配。这些变量被称为元变量。</p>

<p>上述三条定理分别是合取连接的引入规则与两条消解规则。逻辑符号（如<span class="math">\(\wedge\)</span>）的引入规则是指结论部分以该符号为最外层运算符的定理；相应地，消解规则则要求该符号出现在假设中。对于每个逻辑符号，引入规则告诉我们如何证明以该符号为最外层运算符的命题，而消解规则则揭示了这类命题必须如何被证明。</p>

<p>在上述证明中，我们运用<span class="math">\(\wedge\)</span>的引入规则来证明目标<span class="math">\(\vdash b\)</span> <span class="math">\(\wedge a\)</span>，并运用两条消去规则从假设<span class="math">\(a \wedge b\)</span>中提取出<span class="math">\(b\)</span>和a。通过所谓的引入规则在<span class="math">\(\vdash b \wedge a\)</span>中"消去"<span class="math">\(\wedge\)</span>可能听起来有些奇怪。这种术语的逆向性是因为我们的证明过程本身就是逆向进行的。</p>

<div class="math">$$
\text { a b : Prop, hab : } a \wedge b \vdash ? \text { left. } a \wedge b
$$</div>

<p>问号也可能出现在目标中，它们表示可被任意实例化的变量。在上述证明过程中，紧接在应用策略 apply And.right 之后，我们得到的目标</p>


<p>其中?left.a是一个元变量。策略exact hab将?left.a（目标中）与a（hab中）进行匹配。这种通过实例化变量使两个项在语法上相等的程序称为合一（unification）。匹配是合一的特例，即其中一个项不含变量，如此处所示。</p>


<p>顺便提一下，当目标中出现元变量时，还会产生额外的子目标——每个元变量的类型都会作为一个子目标出现（例如<span class="math">\(\vdash\)</span> Prop）。这些令人困惑的子目标只是提醒我们需要用正确类型的项来实例化元变量。通常我们可以忽略这些子目标。一旦元变量被实例化（通常在解决另一个子目标时），其关联的子目标也会随之消失。</p>


<p>在Lean中，统一性检查会考虑计算等价性。例如，项 (fun <span class="math">\(x \mapsto\)</span> ?m) a 和 b 可以通过设定 <span class="math">\(? \mathrm{~m}:=\mathrm{b}\)</span> 实现统一，因为 (fun <span class="math">\(\mathrm{x} \mapsto \mathrm{b}\)</span> ) a 和 <span class="math">\(b\)</span> 在<span class="math">\(\beta\)</span>-规约下是语法等价的。</p>

<pre><code>theorem And_swap_braces :
    Ya b : Prop, a <span class="math">\(\wedge b \rightarrow b \wedge a:=\)</span>
    by
    intro a b hab
    apply And.intro
    \{ exact And.right hab \}
</code></pre>

<p>以下是定理And_swap的另一种证明方式：</p>


<h4>{ 精确的 And.left hab }</h4>
<p>该定理的表述方式有所不同，其中<span class="math">\(a\)</span>和<span class="math">\(b\)</span>作为<span class="math">\(\forall\)</span>量化的变量而非定理的参数。从逻辑上讲这是等价的，但在证明过程中我们必须在hab之外额外引入<span class="math">\(a\)</span>和<span class="math">\(b\)</span>。</p>


<p>另一个区别是花括号<span class="math">\(\}\)</span>的使用。当需要证明两个或更多目标时，通常良好的风格是将每个证明放在由花括号包围的独立块中。<span class="math">\(\}\)</span>战术组合器会聚焦于第一个子目标；内部的战术必须完成其证明。在我们的示例中，应用And.intro战术会创建两个子目标：<span class="math">\(\vdash b\)</span>和<span class="math">\(\vdash a\)</span>。</p>


<p>第三个区别在于，我们现在通过并置方式直接将And.right和And.left应用于假设<span class="math">\(a \wedge b\)</span>，分别得到<span class="math">\(b\)</span>和<span class="math">\(a\)</span>，而非等待定理的假设作为新的子目标出现。这在原本的逆向证明中是一个小的正向步骤。相同的语法既用于消除（即证明）假设，也用于实例化<span class="math">\(\forall\)</span>量词。这种方法的一个好处是避免了可能令人困惑的?left.a元变量。</p>

<pre><code>theorem f5_if (h : \n : \%, f n = n) :
    f 5 = 5 :=
    by exact h 5
</code></pre>

<p>在下一个示例中，我们通过并置法实例化一个<span class="math">\(\forall\)</span>量词：</p>

<pre><code>Or.inl : \forallb : Prop, ?a -&gt; ?a \veeb
Or.inr : \forallb : Prop, ?a -&gt; b \vee?a
Or.elim : ?a \vee?b -&gt; (?a -&gt; ?c) -&gt; (?b -&gt; ?c) -&gt; ?c
</code></pre>

<p>若<span class="math">\(h\)</span>是定理<span class="math">\(\forall n, f n=n\)</span>，则<span class="math">\(h 5\)</span>即为定理<span class="math">\(f 5=5\)</span>。析取<span class="math">\((\vee)\)</span>的引入与消解规则如下：</p>


<p>在Or.inl（"左引入"）和Or.inr（"右引入"）中的<span class="math">\(\forall\)</span>量词可以通过将定理名称直接应用于我们想要实例化的值来直接实例化，只需简单并列。因此，Or.inl False对应定理<span class="math">\(? a \rightarrow\)</span> ?a <span class="math">\(\vee\)</span> False。这是正向风格。</p>


<p>或者，我们可以在形如<span class="math">\(\ldots \vdash c \vee d\)</span>的目标上调用apply Or.inl。这会将定理中的<span class="math">\(? a:=c\)</span>和<span class="math">\(? b:=d\)</span>实例化，新的子目标变为<span class="math">\(\ldots \vdash c\)</span>。这种方式称为逆向风格。</p>

<p>Or.inl和Or.inr都是不安全的：如果在证明过程中错误地应用了二者之一，或者过早地应用其中任何一个，最终可能会得到一个无法证明的子目标。这一点很容易理解，如果我们考虑可证目标<span class="math">\(\vdash\)</span> True <span class="math">\(\vee\)</span> False：应用Or.inr会产生不可证的子目标<span class="math">\(\vdash\)</span> False。</p>

<p>Or.elim规则乍看可能违反直觉。其核心要义是：若我们拥有<span class="math">\(a \vee b\)</span>，那么要证明任意命题<span class="math">\(c\)</span>，只需分别在<span class="math">\(a\)</span>成立和<span class="math">\(b\)</span>成立时证明<span class="math">\(c\)</span>。您可以将<span class="math">\((? a \rightarrow ? c) \rightarrow(? b \rightarrow ? c) \rightarrow ? c\)</span>视为一种巧妙的技巧——它仅用蕴含关系就表达了析取的含义。</p>

<div class="math">$$
\begin{aligned}
&amp; \text { Iff.intro: }(? a \rightarrow ? b) \rightarrow(? b \rightarrow ? a) \rightarrow(? a \leftrightarrow ? b) \\
&amp; \text { Iff.mp : }(? a \leftrightarrow ? b) \rightarrow ? a \rightarrow ? b \\
&amp; \text { Iff.mpr: }(? a \leftrightarrow ? b) \rightarrow ? b \rightarrow ? a
\end{aligned}
$$</div>

<p>等价关系<span class="math">\((\leftrightarrow)\)</span>的引入与消解规则如下：</p>

<pre><code>Exists.intro: <span class="math">\(\forall w,(? P w \rightarrow(\exists x, ? P x))\)</span>
Exists.elm: <span class="math">\((\exists x, ? P x) \rightarrow(\forall a, ? P a \rightarrow ? c) \rightarrow ? c\)</span>
</code></pre>

<p>存在量词（<span class="math">\(\exists\)</span>）的引入与消解规则如下：</p>

<pre><code>theorem Exists_double_iden :
    <span class="math">\(\exists n: N\)</span>, double <span class="math">\(n=n:=\)</span>
    by
    apply Exists.intro \o
    rfl
</code></pre>

<p><span class="math">\(\exists\)</span>的引入规则可用于通过一个见证值实例化存在量词——即该量词主体为真时的某个取值。例如：</p>


<p>同样地，我们以正向方式实例化一个<span class="math">\(\vee\)</span>量词：Exists.intro o 是定理 ?P <span class="math">\(\circ \rightarrow(\exists x, ? P x)\)</span>。该规则是不安全的：若为<span class="math">\(x\)</span>选择错误的见证值，将导致目标不可证。例如，若目标是<span class="math">\(\vdash \exists n, n&gt;5\)</span>而我们选择3作为见证值，最终会得到不可证的子目标<span class="math">\(\vdash 3&gt;5\)</span>。</p>


<p>对于<span class="math">\(\exists\)</span>的消解规则，其思路与<span class="math">\(\vee\)</span>相似。实际上，可以将存在量词<span class="math">\(\exists n\)</span>, ?P <span class="math">\(n\)</span>视为一种可能无限的析取<span class="math">\(? P \circ\)</span> <span class="math">\(\vee ? P 1 \vee \cdots\)</span>。类似地，全称量词<span class="math">\(\forall n\)</span>, ?P <span class="math">\(n\)</span>可理解为<span class="math">\(? P \circ \wedge ? P 1 \wedge \cdots\)</span>。</p>

<p>对于真值（True），仅存在引入规则：</p>

<h4>True.intro : True</h4>
<p>真值不包含任何信息。若其作为假设出现，则完全无用，且不存在任何能从中提取信息的消解规则。下文第3.8节描述的clear策略可用于移除此类无用假设。</p>

<div class="math">$$
\text { False.elim : False } \rightarrow \text { ?a }
$$</div>
<p>相应地，对于假命题（False），仅存在一条消解规则：</p>

<p>我们无法证明伪命题（False），但如果从某处（例如假设中）获得了它，就可以推导出?任意命题。</p>


<p>实际上，否定（非）是通过蕴含和假来定义的：<span class="math">\(\neg\)</span> a 是 a <span class="math">\(\rightarrow\)</span> False 的缩写。直观上，这两者含义相同。我们可以将“非 a”理解为“a 会蕴含某种荒谬（因此非 a）”。</p>

<div class="math">$$
\begin{aligned}
&amp; \text { Classical.em : } \forall \mathrm{a}: \text { Prop, a } \vee \neg \mathrm{a} \\
&amp; \text { Classical.byContradiction }:(\neg ? \mathrm{a} \rightarrow \text { False }) \rightarrow ? \mathrm{a}
\end{aligned}
$$</div>

<p>Lean的逻辑体系是经典逻辑，支持排中律和反证法：</p>

<p>蕴涵<span class="math">\((\rightarrow)\)</span>与全称量词<span class="math">\((\vee)\)</span>如同典故中未吠的狗——它们没有引入或消解规则。取而代之的是，对两者而言，intro策略即引入原理，而应用（如<span class="math">\(\lambda\)</span>-演算中所示）即消解原理。例如给定定理hab<span class="math">\(: a \rightarrow b\)</span>和ha<span class="math">\(: a\)</span>，应用hab ha即得到陈述<span class="math">\(b\)</span>的定理。</p>

<p>在证明涉及逻辑连接词和量词的逻辑谜题时，我们提倡采用一种"无脑"、"电子游戏"式的推理风格，主要依赖intro和apply等基础策略。以下是一些常用技巧：</p>
<ul>
<li>若目标结论是蕴含式<span class="math">\(P \rightarrow Q\)</span>，使用intro <span class="math">\(h P\)</span>将<span class="math">\(P\)</span>移入假设集：<span class="math">\(\ldots, \mathrm{hP}: \mathrm{P} \vdash \mathrm{Q}\)</span>。</li>
<li>若目标结论是全称量词<span class="math">\(\forall x: \sigma, Q\)</span>，使用intro <span class="math">\(x\)</span>将<span class="math">\(x\)</span>移入局部上下文：<span class="math">\(\ldots, x: \sigma \vdash Q\)</span>。</li>
<li>寻找结论形态与目标匹配的定理或假设（可能包含可匹配变量）并应用。例如若目标是<span class="math">\(Q\)</span>且存在hPQ: <span class="math">\(P \rightarrow Q\)</span>，尝试apply hPQ。</li>
<li>否定目标<span class="math">\(\vdash \neg P\)</span>在计算意义上等同于<span class="math">\(\vdash P \rightarrow\)</span> False，可使用intro hP生成子目标hP : P <span class="math">\(\vdash\)</span> False。通过rw [Not]展开否定定义（见3.5节）通常是有效策略。</li>
<li>有时可通过apply False.elim将目标替换为False。后续通常应用形如<span class="math">\(P \rightarrow\)</span> False或<span class="math">\(\neg P\)</span>的定理/假设。</li>
<li>面临多项选择时（如Or.inl与Or.inr），记录已尝试路径，在遇到死胡同或进展停滞时回溯。</li>
<li>若怀疑陷入死胡同，需验证当前目标在给定假设下是否可证。即使初始定理陈述可证，错误应用不安全规则可能导致当前目标不可证。</li>
</ul>

<div class="math">$$
\begin{aligned}
&amp; \text { Eq.ref1: } \forall \mathrm{a}, \mathrm{a}=\mathrm{a} \\
&amp; \text { Eq.symm : } ? \mathrm{a}=? \mathrm{~b} \rightarrow ? \mathrm{~b}=? \mathrm{a} \\
&amp; \text { Eq.trans : } ? \mathrm{a}=? \mathrm{~b} \rightarrow ? \mathrm{~b}=? \mathrm{c} \rightarrow ? \mathrm{a}=? \mathrm{c} \\
&amp; \text { Eq.subst : } ? \mathrm{a}=? \mathrm{~b} \rightarrow ? \mathrm{P} ? \mathrm{a} \rightarrow ? \mathrm{P} ? \mathrm{~b}
\end{aligned}
$$</div>

<h3>3.4 关于等式的推理</h3>
<p>等号（=）同样是一个基本逻辑常量，其特征由以下引入规则和消解规则定义：</p>


<p>前三个定理是指明等号=作为等价关系的引入规则。第四个定理是消解规则，允许我们在由元变量?P表示的任意上下文中进行等量替换。</p>

<pre><code>theorem Eq_trans_symm <span class="math">\(\{\alpha\)</span> : Type\} (a b c : <span class="math">\(\alpha\)</span> )
    (hab : a = b) (hcb : c = b) :
    <span class="math">\(a=c:=\)</span>
    by
    apply Eq.trans
    <span class="math">\(\{\)</span> exact hab \}
    <span class="math">\(\{\)</span> apply Eq.symm
        exact hcb \}
</code></pre>
<p>以下示例将展示部分规则的实际应用。我们通过应用Eq.trans和Eq.symm规则，利用等式<span class="math">\(a=b\)</span>和<span class="math">\(c=b\)</span>来证明<span class="math">\(a=c\)</span>：</p>
<pre><code>theorem Eq_trans_symm_rw {a : Type} (a b c : a)
    (hab : a = b) (hcb : c = b) :
    a = c :=
    by
    rw [hab]
    rw [hcb]
</code></pre>

<p>由于这种重写操作十分常见，Lean提供了rw策略来实现相同效果。该策略在适用时还会自动应用rfl：</p>


<p>关于解析的说明：等号的绑定优先级高于逻辑连接符。因此，<span class="math">\(a=b \wedge c=d\)</span> 应理解为 <span class="math">\((a=b) \wedge(c=d)\)</span>。</p>


<h3>3.5 重写策略</h3>
<p>重写策略rw及其相关方法simp会执行等量替换操作。它们将等式作为从左到右的重写规则使用，用右侧表达式替换左侧表达式的所有出现实例。</p>

<div class="math">$$
\begin{array}{ll}
\text { at } h_{1} \ldots h_{n} &amp; \text { rewrites the specified hypotheses } \\
\text { at } * &amp; \text { rewrites all hypotheses and the target }
\end{array}
$$</div>

<p>默认情况下，它们作用于目标（goal）的靶标（target），但也可通过at关键字指定重写假设（hypotheses）：</p>

<div class="math">$$
r w\left[\text { theorem-or-constant }_{1}, \ldots, \text { theorem-or-constant }_{n}\right][\text { at position }]
$$</div>

<h4>重写策略</h4>
<p>rw策略使用一个或多个等式作为从左到右的重写规则来改写目标。它会搜索第一个匹配等式左侧的子项；一旦找到，该子项的所有出现都会被替换为右侧表达式。若等式包含变量，这些变量会根据需要进行实例化。要将定理反向用作从右到左的重写规则，可在定理名称前添加短左箭头<span class="math">\((\leftarrow)\)</span>。若指定多个等式，它们将依次被应用。</p>


<p>因此，给定定理 hg : <span class="math">\(\forall x, g x=f x\)</span> 和目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{f} a)(g b)(g c)\)</span>，策略 rw [hg] 会生成子目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{f} a)(\mathrm{f} b)(g c)\)</span>，而 rw [ <span class="math">\(\leftarrow \mathrm{hg}\)</span> ] 则会生成子目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{g} a)(\mathrm{g} b)(\mathrm{g} c)\)</span>。</p>


<p>除了定理之外，我们也可以指定常量的名称。这将尝试使用该常量的某个定义方程作为重写规则。</p>


<h4>simp 策略</h4>
<p>simp [at position]
simp 策略会使用一组称为 simp 集的标准化重写规则对目标进行穷尽式重写。simp 集中的每个等式都被用作从左到右的重写规则。该集合包含关于预定义符号（如算术和列表运算符）的各种规则，并可通过在适当定理上添加 @[simp] 属性进行扩展。
simp [theorem-or-constant <span class="math">\(\left.{ }_{1}, \ldots\right, \text { theorem-or-constant }_{n}\)</span> ] [at position]在此变体中，指定的定理会被临时添加到 simp 集。在定理列表中，星号(<em>)可表示所有假设，减号(-)前缀表示临时移除该定理。一个强大的指令是 simp [</em>] at *，它能同时简化假设并利用结果来简化目标的主体部分。</p>

<p>给定定理hg : <span class="math">\(\forall x, g x=f x\)</span> 和目标 <span class="math">\(\vdash h(f a)(g b)(g c)\)</span>，使用策略simp [hg]会生成子目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{f} \mathrm{a})(\mathrm{f} b)(\mathrm{f} \mathrm{c})\)</span>，其中g b和g c均被重写。除了定理外，我们也可以指定常量名称，这会临时将该常量的定义方程加入simp集合。</p>

<p>此时你可能会疑惑："simp究竟做了什么？"当然，你可以研究源代码或查阅科学文献。但这可能不是最有效利用时间的方式。事实上，即使是证明助手的专家用户，也未必完全理解他们日常使用的策略行为。最成功的用户会采取一种轻松灵活的态度，依次尝试不同策略，并观察产生的子目标（如果有的话），以此判断是否走在正确的路径上。</p>


<p>随着你持续使用simp和其他策略，你会逐渐培养出对它们擅长处理哪些类型目标的直觉。这正是交互式定理证明必须通过实践才能掌握的众多原因之一。很多时候，你并不会完全理解Lean的行为——为何某个策略成功或失败。定理证明有时会令人非常沮丧。《银河系漫游指南》封面上用大而友善的字母印着的建议在此同样适用：不要惊慌。</p>

<h3>3.6 数学归纳法证明</h3>
<p>induction策略对归纳类型的值执行结构归纳法。结构归纳意味着归纳过程遵循归纳类型的结构。对于由Nat.zero和Nat.succ构造的自然数，结构归纳对应于标准数学归纳法：要证明p n，只需证明<span class="math">\(p \ominus\)</span>和<span class="math">\(\forall k, p k \rightarrow p(k * 1)\)</span>。借助归纳法，我们可以对第2.2节中通过递归定义的加法和乘法运算进行推理。</p>
<pre><code>theorem add_zero ( <span class="math">\(n: \mathbb{N}\)</span> ) :
    add <span class="math">\(\odot n=n:=\)</span>
    by
        induction n with
        | zero <span class="math">\(\quad=&gt;r f l\)</span>
        | succ <span class="math">\(n^{\prime}\)</span> ih =&gt; simp [add, ih]
</code></pre>

<p>加法是通过对其第二个参数进行递归定义的。我们将证明两个定理：add_zero和add_succ，它们提供了基于第一个参数递归的替代等式。我们从add_zero开始：</p>


<p>归纳策略后跟随两个对应于构造函数的子证明。此外，子证明特有的任何变量或假设都可以在构造函数名称后显式命名。</p>

<div class="math">$$
n^{\prime}: \mathbb{N}, \text { ih }: \text { add } \odot n^{\prime}=n^{\prime} \vdash \text { add } \odot\left(\text { Nat. succ } n^{\prime}\right)=\text { Nat. succ } n^{\prime}
$$</div>

<p>第一个标记为zero的案例对应基本情况<span class="math">\(\vdash\)</span> add <span class="math">\(\odot \odot=\odot\)</span>。第二个标记为succ的案例对应归纳步骤</p>

<p>在succ后指定的名称<span class="math">\(n^{\prime}\)</span>和ih分别表示我们赋予Nat.succ参数和归纳假设的名称。虽然可以使用其他名称，但按照惯例通常将归纳假设称为ih。</p>
<pre><code>theorem add_succ (m n : N) :
    add (Nat.succ m) n = Nat.succ (add m n) :=
    by
        induction n with
        | zero =&gt; rfl
        | succ n' ih =&gt; simp [add, ih]
theorem add_comm (m n : N) :
    add m n = add n m :=
    by
        induction n with
        | zero =&gt; simp [add, add_zero]
        | succ n' ih =&gt; simp [add, add_succ, ih]
theorem add_assoc (l m n : N) :
    add (add l m) n = add l (add m n) :=
    by
        induction n with
        | zero =&gt; rfl
        | succ n' ih =&gt; simp [add, ih]
</code></pre>

<p>我们可以继续通过结构归纳法证明定理：</p>

<pre><code>instance Associative_add : Std.Associative add :=
    { assoc := add_assoc }
instance Commutative_add : Std.Commutative add :=
    { comm := add_comm }
</code></pre>
<p>当我们证明了一个二元运算符满足交换律和结合律后，最好让Lean的自动化机制（特别是ac_rfl）知晓这一点。以下命令为加法运算实现了这一目的：</p>
<pre><code>theorem mul_add (l m n : N) :
    mul l (add m n) = add (mul l m) (mul l n) :=
    by
    induction n with
    | zero =&gt; rfl
    | succ n' ih =&gt;
        simp [add, mul, ih]
        ac_rfl
</code></pre>
<p>（实例机制将在第5章详细解释。）以下示例使用ac_rfl策略，基于加法运算的结合律和交换律进行推理：</p>
<p>以下是进行归纳证明的几点建议：</p>
<ul>
<li>
<p>通常最好根据目标中出现的某个函数的定义结构进行归纳。特别是，如果一个函数是通过对其第<span class="math">\(n\)</span>个参数进行递归定义的，那么对该参数进行归纳可能是有意义的。</p>
</li>
<li>
<p>如果归纳的基础情况难以证明，这通常表明选择了错误的变量或应该先证明某些定理。</p>
</li>
</ul>

<pre><code>induction term [with
| constructor, names, =&gt; tactics
    \vdots
| constructor, names, =&gt; tactics
</code></pre>

<h3>3.7 归纳策略</h3>
<h4>induction</h4>
<p>induction策略对指定项执行结构归纳。这会生成与该项类型定义中构造函数数量相同的子目标。在递归构造函数（如Nat.succ或List.cons）对应的子目标中，归纳假设将作为假设条件可用。可选参数names, ..., names用于命名新生成的变量或假设。</p>

<h3>3.8 清理策略</h3>
<p>以下策略可协助我们清理目标状态。虽然目前尚未需要使用它们，但在探索证明过程中可能有所帮助。</p>

<h4>clear</h4>
<p>clear 变量或假设, ... 变量或假设,
clear策略会移除指定的变量和假设，只要它们没有在目标的其他地方被使用。</p>


<h4>重命名</h4>
<p>rename 变量类型或假设命题类型 =&gt; 新名称</p>

<p>rename策略用于更改变量或假设的名称。</p>

<h3>3.9 新引入的Lean结构摘要</h3>
<p>属性
@[simp] 将定理添加到simp集合中</p>

<table>
<thead>
<tr>
  <th style="text-align:left">ac_rfl</th>
  <th style="text-align:left">proves <span class="math">\(1=\mathrm{r}\)</span> up to associativity and commutativity</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">apply</td>
  <td style="text-align:left">matches the goal's target against the theorem's conclusion</td>
</tr>
<tr>
  <td style="text-align:left">assumption</td>
  <td style="text-align:left">proves the goal using a hypothesis</td>
</tr>
<tr>
  <td style="text-align:left">clear</td>
  <td style="text-align:left">removes a variable or hypothesis from the goal</td>
</tr>
<tr>
  <td style="text-align:left">exact</td>
  <td style="text-align:left">proves the goal using the specified theorem</td>
</tr>
<tr>
  <td style="text-align:left">induction</td>
  <td style="text-align:left">performs structural induction on a variable of an inductive type</td>
</tr>
<tr>
  <td style="text-align:left">intro</td>
  <td style="text-align:left">moves <span class="math">\(\forall\)</span>-quantified variables into the goal's hypotheses</td>
</tr>
<tr>
  <td style="text-align:left">rename</td>
  <td style="text-align:left">renames a variable or hypothesis</td>
</tr>
<tr>
  <td style="text-align:left">rfl</td>
  <td style="text-align:left">proves <span class="math">\(1=\mathrm{r}\)</span> up to computation</td>
</tr>
<tr>
  <td style="text-align:left">rw</td>
  <td style="text-align:left">rewrites once using the given theorem as a rewrite rule</td>
</tr>
<tr>
  <td style="text-align:left">simp</td>
  <td style="text-align:left">rewrites using a set of preregistered rewrite rules exhaustively</td>
</tr>
<tr>
  <td style="text-align:left">sorry</td>
  <td style="text-align:left">stands for a missing proof</td>
</tr>
</tbody>
</table>

<h4>证明命令</h4>
<h4>策略</h4>
<h4>策略组合器</h4>
<p><span class="math">\(\{\ldots\}\)</span>聚焦于第一个子目标；需要证明该子目标</p>


<h2>第四章：正向证明</h2>
<p>策略式证明采用逆向工作方式，从目标出发逐步将其简化为已知定理和假设。但有时正向推理更为合理：从既有定理和假设出发，逐步推进直至达成目标。结构化证明正是支持这种推理风格的体系。策略式证明虽易于编写却难以阅读，因此多数用户会混合使用两种风格，根据情境选择最合适的方式。结构化证明的高可读性使其深受部分用户青睐。</p>


<p>结构化证明是洒在Lean证明项之上的语法糖衣。它们通过使用诸如assume、have、let和show等模仿纸笔证明的关键字构建。所有Lean证明，无论是策略式还是结构化的，最终都会被内部转换为证明项。我们已在第3章见过一些示例：给定假设ha : a和hab : a <span class="math">\(\rightarrow\)</span> b时，项hab ha就是命题<span class="math">\(b\)</span>的证明项，我们写作hab ha : b。定理和假设的名称（如ha和hab）同样属于证明项。进一步延伸这个概念，给定hbc : b <span class="math">\(\rightarrow c\)</span>时，我们可以构建命题c的证明项hbc (hab ha)。可以将hab视为将a的证明转换为<span class="math">\(b\)</span>证明的函数，hbc同理。</p>

<p>结构化证明是Lean中的默认形式，可在策略模式外使用。要进入策略模式，必须使用by命令。</p>
<p>这里涉及的概念在《Lean 4中的定理证明》第2至4章中有更详细的阐述。Nederpelt与Geuvers的教科书也是另一本实用的参考书籍。</p>
<pre><code>theorem fst_of_two_props :
    Ya b : Prop, a -&gt; b -&gt; a :=
fix a b : Prop
assume ha : a
assume hb : b
show a from
    ha
</code></pre>

<h3>4.1 结构化证明</h3>
<p>作为第一个示例，考虑以下结构化证明：</p>

<p>在结构化证明中，由<span class="math">\(\forall\)</span>量词约束的每个变量以及每个蕴含假设都通过fix和assume命令显式引入。多个变量可同时引入。我们通常会省略变量类型（尤其当类型可通过变量名推测时），但始终会逐行明示命题以增强可读性——这毕竟是结构化风格的主要潜在优势之一。末尾的show...from命令会为提升可读性而重复待证命题，并在from关键词后给出证明。此时的目标是a b : Prop, ha : a, hb : b <span class="math">\(\vdash\)</span> a。</p>
<p>非正式地，我们可以将证明过程表述如下：
设定若干命题a和<span class="math">\(b\)</span>。
假设(ha) a与(<span class="math">\(h b\)</span>) b为真。
需证a。这显然可由ha直接得出。
部分作者会在"命题"前加入"任意但固定"等限定词，或表述为"设a和b为某些命题"。这些变体表述均等价。此外，可用"QED"替代<span class="math">\(\square\)</span>来结束证明。</p>
<pre><code>theorem prop_comp (a b c : Prop) (hab : a <span class="math">\(\rightarrow\)</span> b) (hbc : b <span class="math">\(\rightarrow\)</span> c) :
        <span class="math">\(a \rightarrow c:=\)</span>
    assume ha : a
    have hb : b :=
        hab ha
    have hc : c :=
        hbc hb
    show c from
        hc
</code></pre>

<p>上述Lean证明的非典型之处在于目标结论直接出现在假设中。通常我们需要进行若干中间推理步骤，本质上遵循"从某某前提，我们得出某某结论"的形式。在Lean中，每个中间步骤都以have命令的形式呈现，如下例所示：</p>


<p>非正式表述：
假设（ha）a为真。
由ha和hab可得（<span class="math">\(h b\)</span>）b。
由hb和hbc可得（hc）c。
需证明c。这显然由hc直接得出。
注意这是前向证明：它从假设a逐步推进到目标定理c，每次处理一个定理。假言推理（"由a和<span class="math">\(\mathrm{a} \rightarrow \mathrm{b}\)</span>推出b"）通过简单并列表达（例如hab ha）。</p>


<p>一般而言，fix-assume-show框架会重复定理的陈述。我们通常将固定的变量命名为目标中的绑定变量，正如我们在此处所做的，但这并非强制要求。此外，避免遮蔽已有变量是良好的实践。在最后一个fix或assume与show之间，我们可以根据需要添加任意数量的have命令，这取决于我们希望论证的详细程度。细节可以增强可读性，但提供过多细节可能会让读者不堪重负。</p>

<pre><code>theorem prop_comp_inline (a b c : Prop) (hab : a -&gt; b)
    (hbc : b -&gt; c) :
    a }-&gt;\mathrm{ c :=
    assume ha : a
    show c from
        hbc (hab ha)
</code></pre>

<p>have命令的语法与theorem类似，但出现在结构化证明内部。我们也可以将have视为一种定义。在have hb : b := hab ha中，右侧的hab ha是<span class="math">\(b\)</span>的证明项，而左侧的<span class="math">\(h b\)</span>被定义为该证明项的同义词。此后，hb和hab ha可以互换使用。由于<span class="math">\(h b\)</span>和<span class="math">\(h c\)</span>仅使用一次且其证明非常简短，专家通常会选择内联它们，将hc替换为hbc hb，再将hb替换为hab ha，最终得到</p>

<pre><code>theorem hr :
    \forall}\mp@subsup{c}{1}{}\mathrm{ c}_{1}:\sigma_{1}\mathrm{ ) ... ( }c_{1}:\sigma_{1}\mathrm{ ), P}_{1}-&gt;\cdots-&gt;P_{m}-&gt;R:=
    fix (c}\mp@subsup{c}{1}{}\mathrm{ c}_{1}:\sigma_{1}\mathrm{ ) ... (c}\mp@subsup{c}{1}{}\mathrm{ c}_{1}:\sigma_{1}\mathrm{ )
    assume h}\mp@subsup{h}{1}{}\mathrm{ : P
        \vdots
    assume h m : P m
    have k
    have k
show R from ...
</code></pre>

<p>典型的结构化证明遵循以下fix-assume-have-show格式：</p>


<h3>4.2 结构化构造</h3>
<p>前一节介绍了编写结构化证明的主要命令：fix、assume、have和show。现在我们将更系统地回顾结构化证明的各个组成部分。</p>

<pre><code>theorem two_add_two_Eq_four :
    <span class="math">\(2+2=4:=\)</span>
    by ...
</code></pre>

<h4>定理或假设</h4>
<p>除了sorry之外，最简单的结构化证明就是定理或假设的名称。如果我们有</p>

<pre><code>theorem this_time_with_feeling :
    <span class="math">\(2+2=4:=\)</span>
    two_add_two_Eq_four
</code></pre>

<p>那么定理名称two_add_two_Eq_four后续可作为<span class="math">\(2+2=4\)</span>的证明使用。例如：</p>

<pre><code>theorem add_comm_zero_left (n : N) :
    add ○ n = add n ○ :=
    add_comm ○ n
</code></pre>
<p>我们可以向定理传递参数来实例化<span class="math">\(\forall\)</span>量词并消解假设。假设定理add_comm（<span class="math">\(\mathrm{m} \mathrm{n}: \mathbb{N}\)</span>）：add <span class="math">\(\mathrm{m} \mathrm{n}=\)</span> add n m 可用，且我们需要证明其特例 add <span class="math">\(\circ \mathrm{n}=\)</span> add <span class="math">\(\mathrm{n} \circ\)</span>。这可以通过简洁地使用定理名称和两个参数来实现：</p>

<p>这等价于使用战术证明 exact add_comm <span class="math">\(\circ \mathrm{n}\)</span> 但更为简洁。exact 策略可视为 by 的逆操作——何必进入策略模式又立即退出？</p>


<p>与exact和apply类似，定理或假设的陈述会通过计算与当前目标进行匹配。这提供了一定的灵活性。</p>


<h4>fix</h4>
<p>fix 名称 : 类型
fix命令将目标结论中的<span class="math">\(\forall\)</span>量词变量移至局部上下文中。这是intro策略的结构化版本。</p>

<p>需要注意的是，Lean标准库中用于固定变量的策略是fun。我们更倾向于使用LoVelib提供的fix作为更具可读性的替代方案，而保留fun用于指定匿名函数。</p>

<h4>assume</h4>
<p>assume 名称 : 命题
assume命令将目标命题中的前件假设移至局部上下文中。可将其视为intro策略的结构化版本。</p>

<p>请注意，Lean标准库中声明假设的常规策略是fun。我们更倾向于使用LoVelib提供的assume作为更具可读性的替代方案，而保留fun用于指定匿名函数。</p>
<pre><code>have name : proposition :=
    proof
</code></pre>

<h4>have命令</h4>
<p>have命令允许我们陈述并证明一个中间定理，该定理可以引用先前通过fixes、assumes和haves引入的名称。其证明可采用策略式或结构化形式。通常我们会用结构化证明勾勒主要论证框架，而对子目标或无趣的中间步骤采用策略式证明。另一种混合情形出现在向定理名称传递参数时。例如给定hab : <span class="math">\(a \rightarrow b\)</span>和ha : a，策略exact hab ha将能证明目标<span class="math">\(\vdash b\)</span>。此处hab ha是嵌套在策略中的证明项。</p>


<h4>let</h4>
<p>let 名称 [: 类型] := 项
let命令用于引入新的局部定义。该命令可为后续证明中多次出现的复杂对象命名，其功能类似于have，但专为可计算数据（而非证明）设计。展开或引入let操作对应<span class="math">\(\mathcal{L}\)</span>-转换（第3.2节）。</p>

<p>构造 let name [: type] := term 后必须跟随换行或分号(;)。</p>
<pre><code>show proposition from
    proof
</code></pre>

<h4>显示</h4>
<p>show命令允许我们重复显示待证明目标，这可以作为有效的文档记录手段。该命令还支持通过计算等价的方式对目标进行语法重构。若无需重复目标或进行语法重构，可直接使用proof替代show proposition from proof的语法结构。此类证明既可采用策略式也可采用结构化形式。</p>

<pre><code>theorem And_swap (a b : Prop) :
    a <span class="math">\(\wedge b \rightarrow b \wedge a:=\)</span>
assume hab : a <span class="math">\(\wedge b\)</span>
have ha : a :=
    And.left hab
have hb : b :=
    And.right hab
show b <span class="math">\(\wedge\)</span> a from
    And.intro hb ha
</code></pre>

<h3>4.3 关于逻辑连接词与量词的前向推理</h3>
<p>以正向方式对逻辑连接词和量词进行推理时，使用的引入与消解规则与策略模式相同（第3.3节）。以下示例将展示其基本思路。让我们从合取开始：</p>

<pre><code>theorem And_swap_tactical (a b : Prop) :
    a <span class="math">\(\wedge b \rightarrow b \wedge a:=\)</span>
    by
        intro hab
        apply And.intro
        apply And.right
        exact hab
        apply And.left
        exact hab
</code></pre>

<p>即使不了解"And.left"等术语含义的读者也能理解：我们从<span class="math">\(a \wedge b\)</span>中提取出<span class="math">\(a\)</span>和<span class="math">\(b\)</span>，再将它们重组为<span class="math">\(b \wedge a\)</span>。数学家理解这种证明方式可能比理解其战术式证明版本更为轻松：</p>


<p>一般而言，逆向证明更容易"无脑"推导，且证明辅助工具提供的大多数自动化操作都是逆向进行的。这很合理：假设你是马普尔小姐或赫尔克里·波洛正在调查谋杀案。逆向调查会从犯罪现场出发，试图提取能将少数嫌疑人与罪行联系起来的线索。相比之下，正向调查可能要从多达80亿人中逐一询问不在场证明。哪种方法更可能成功？</p>

<pre><code>theorem Forall.one_point <span class="math">\(\{\alpha\)</span> : Type\} (t : <span class="math">\(\alpha\)</span> ) (P : <span class="math">\(\alpha \rightarrow\)</span> Prop) :
    <span class="math">\((\forall x, x=t \rightarrow P x) \leftrightarrow P t:=\)</span>
    Iff.intro
    (assume hall : <span class="math">\(\forall x, x=t \rightarrow P x\)</span>
        show <span class="math">\(P\)</span> t from
            by
                apply hall <span class="math">\(t\)</span>
                rfl)
    (assume hp : P t
    fix <span class="math">\(x: \alpha\)</span>
    assume heq : <span class="math">\(x=t\)</span>
    show <span class="math">\(P\)</span> x from
        by
            rw [heq]
            exact hp )
</code></pre>

<p>接下来的例子涉及单点规则。这些定理可用于消除量词，当约束变量实际上只能取一个值时。例如，命题<span class="math">\(\forall n, n=666 \rightarrow\)</span> beast <span class="math">\(\geq n\)</span> 可简化为beast <span class="math">\(\geq 666\)</span>。以下定理证明了这种简化的合理性：</p>


<p>这个证明看似令人生畏，但实际构建过程并不困难。关键在于循序渐进：我们首先注意到目标是一个等价关系，因此写下</p>


<p>当且仅当引入规则（<em>）（</em>），其中Iff.intro是<span class="math">\(\leftrightarrow\)</span>的引入规则（第3.3节）。这两个占位符对于保证证明结构的完整性至关重要。我们使用括号是因为我们强烈怀疑子证明将是非平凡的。由于证明本质上是项，而项本质上是程序，我们在第1.4节给出的建议在此同样适用，只需稍作调整：</p>

<p>核心思想在于证明应始终保持语法正确性。在Visual Studio Code中，我们唯一应看到的红色下划线应仅出现在占位符下方。一般而言，证明开发的一个良好原则是：从一个可编译的证明开始，进行最小可能的修改以获得新的可编译证明，如此重复直至证明完成。</p>
<pre><code>Iff.intro
    (assume hall : <span class="math">\(\forall x, x=t \rightarrow P x\)</span>
        show <span class="math">\(P\)</span> t from
            _ )
    (_)
</code></pre>

<p>将鼠标悬停在第一个占位符上会显示对应的子目标。我们可以看到Lean期望得到一个<span class="math">\(\vdash(\forall x, x=t \rightarrow P x) \rightarrow P t\)</span>的证明，因此我们提供了一个合适的框架。结构化证明一个蕴含式通常由assume后接show组成：</p>

<pre><code>Iff.intro
    (assume hall : <span class="math">\(\forall x, x=t \rightarrow P x\)</span>
        show <span class="math">\(P t\)</span> from
            by
                apply hall <span class="math">\(t\)</span>
                rfl))
    (_)
</code></pre>

<p>剩余的每个占位符都可以用结构化证明或策略证明来替换。要消除第一个占位符，我们进入策略模式并应用假设<span class="math">\(\forall x, x=t \rightarrow P x\)</span>的实例<span class="math">\(t=t \rightarrow P t\)</span>到目标<span class="math">\(\vdash P t\)</span>上。这会留下证明义务<span class="math">\(t=t\)</span>，我们使用rfl策略来完成该证明：</p>

<pre><code>(assume hp : P t
fix x : <span class="math">\(\alpha\)</span>
assume heq : <span class="math">\(x=t\)</span>
show <span class="math">\(P x\)</span> from
    _ )
</code></pre>

<p>第二个占位符表示<span class="math">\(\vdash P t \rightarrow \forall x, x=t \rightarrow P x\)</span>。要消除它，我们针对第一个蕴含的假设使用assume指令，对<span class="math">\(\forall\)</span>使用fix指令，对第二个蕴含的假设使用assume指令，并为结论部分使用show指令：</p>

<pre><code>(assume hp : P t
fix <span class="math">\(x: \alpha\)</span>
assume heq : <span class="math">\(x=t\)</span>
show <span class="math">\(P x\)</span> from
    by
        rw [heq]
        exact hp )
</code></pre>

<p>该证明过程采用策略性操作：我们将<span class="math">\(\vdash P x\)</span>中的<span class="math">\(x\)</span>重写为<span class="math">\(t\)</span>，得到<span class="math">\(\vdash P t\)</span>，这与假设hp相匹配：</p>

<pre><code>theorem beast_666 (beast : N) :
    <span class="math">\((\forall n, n=666 \rightarrow\)</span> beast <span class="math">\(\geq n) \leftrightarrow\)</span> beast <span class="math">\(\geq 666:=\)</span>
Forall.one_point _ _
</code></pre>

<p>让我们验证单点规则在我们这个激励性示例中确实有效：</p>


<p>确实有效。除了使用 Forall. one_point __，我们也可以写成 Forall. one_point 666 (fun <span class="math">\(m \mapsto\)</span> beast <span class="math">\(\geq m\)</span> )。</p>

<pre><code>theorem Exists.one_point <span class="math">\(\{\alpha\)</span> : Type\}(t : <span class="math">\(\alpha\)</span> ) (P : <span class="math">\(\alpha \rightarrow\)</span> Prop) :
    <span class="math">\((\exists x: \alpha, x=t \wedge P x) \leftrightarrow P t:=\)</span>
    Iff.intro
    (assume hex : <span class="math">\(\exists x, x=t \wedge P x\)</span>
        show <span class="math">\(P t\)</span> from
            Exists.elim hex
            (fix <span class="math">\(x: \alpha\)</span>
                assume hand : <span class="math">\(x=t \wedge P x\)</span>
                have hxt : <span class="math">\(x=t:=\)</span>

        And.left hand
        have hpx : P x :=
            And.right hand
        show P t from
            by
                rw [ \leftarrowhxt]
                exact hpx))
(assume hp : P t
    show <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span> from
        Exists.intro <span class="math">\(t\)</span>
            (have tt : <span class="math">\(t=t:=\)</span>
                by rfl
            show <span class="math">\(t=t \wedge P t\)</span> from
                And.intro tt hp))
</code></pre>

<p>最后，关于<span class="math">\(\exists\)</span>的单点规则展示了如何在结构化证明中使用<span class="math">\(\exists\)</span>的引入与消解规则：</p>


<p>尽管这个证明看起来可能令人望而生畏，但它主要是通过无意识地运用与<span class="math">\(\forall\)</span>单点规则证明相同的流程构建出来的。</p>

<pre><code>Iff.intro (_) (_)
</code></pre>
<p>首先，我们使用<span class="math">\(\leftrightarrow\)</span>的引入规则：</p>
<pre><code>Iff.intro
    (assume hex : <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>
        show <span class="math">\(P t\)</span> from
            _ )
    (_)
</code></pre>

<p>对于第一个占位符，我们需要在假设<span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>下提供<span class="math">\(P t\)</span>的证明。因此，我们将证明框架扩展为</p>

<pre><code>Iff.intro
    (assume hex : <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>
        show <span class="math">\(P t\)</span> from
            Exists.elim hex (_))
    (_)
</code></pre>

<p>此时，我们需要从假设hex中提取关于<span class="math">\(x\)</span>的见证。为此，我们使用<span class="math">\(\exists\)</span>的消解规则：</p>

<pre><code>Iff.intro
    (assume hex : <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>
        show <span class="math">\(P t\)</span> from
            Exists.elim hex
            (fix <span class="math">\(x: \alpha\)</span>
            assume hand : <span class="math">\(x=t \wedge P x\)</span>
            show <span class="math">\(P t\)</span> from
                _))
(_)
</code></pre>

<p>第一个占位符要求提供子目标<span class="math">\(\vdash \forall x, x=t \wedge P x \rightarrow P t\)</span>的证明。我们简要描述如下：</p>

<pre><code>Iff.intro
    (assume hex : <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>
        show <span class="math">\(P\)</span> t from
            Exists.elim hex
            (fix <span class="math">\(x: \alpha\)</span>
                assume hand : <span class="math">\(x=t \wedge P x\)</span>
                have hxt : <span class="math">\(x=t\)</span> :=
                    And.left hand
                have hpx : P x :=
                    And.right hand
                show <span class="math">\(P\)</span> t from
                    _))
    (_)
</code></pre>

<p>注意子证明如何镜像地对应子目标：fix对应<span class="math">\(\forall\)</span>，assume对应<span class="math">\(\rightarrow\)</span>的假设部分，show对应<span class="math">\(\rightarrow\)</span>的结论部分。此时我们可以访问见证者<span class="math">\(x\)</span>及其特征性质<span class="math">\(x=t \wedge P x\)</span>。接着通过have命令和<span class="math">\(\wedge\)</span>的消解规则（And.left与And.right）提取<span class="math">\(x=t \wedge P x\)</span>的两个合取项：</p>

<pre><code>Iff.intro
    (assume hex : <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>
        show <span class="math">\(P\)</span> t from
            Exists.elim hex
            (fix <span class="math">\(x: \alpha\)</span>
                assume hand : <span class="math">\(x=t \wedge P x\)</span>
                have hxt : <span class="math">\(x=t\)</span> :=
                    And.left hand
                have hpx : P x :=
                    And.right hand
                show <span class="math">\(P\)</span> t from
                    by
                        rw [t-hxt]
                        exact hpx))
    (_)
</code></pre>

<p>现在我们可以尝试证明<span class="math">\(P t\)</span>。我们将<span class="math">\(t\)</span>重写为<span class="math">\(x\)</span>并应用假设P x：</p>

<pre><code>(assume hp : P t
    show <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span> from
    _ )
</code></pre>

<p>对于剩余的占位符，我们首先基于子目标<span class="math">\(\vdash \mathrm{Pt} \rightarrow \exists \mathrm{x}: \alpha, \mathrm{x}=\mathrm{t} \wedge \mathrm{Px}\)</span>提供一个证明框架：</p>

<pre><code>(assume hp : P t
    show <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span> from
        Exists.intro t (_))
</code></pre>
<p>随后我们运用<span class="math">\(\exists\)</span>的引入规则来提供见证项<span class="math">\(t\)</span>：</p>
<pre><code>(assume hp : P t
    show <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span> from
        Exists.intro t
</code></pre>
<div class="math">$$
\begin{aligned}
(\text { show } t &amp; =t \wedge P t \text { from } \\
\ldots &amp; \text { ) }
\end{aligned}
$$</div>

<p>接下来是更多的模板化步骤：</p>

<pre><code>(assume hp : P t
    show <span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span> from
        Exists.intro <span class="math">\(t\)</span>
            (have tt : <span class="math">\(t=t:=\)</span>
                by rfl
            show <span class="math">\(t=t \wedge P t\)</span> from
                And.intro tt hp))
</code></pre>

<p>最后一个合取式<span class="math">\(t=t \wedge P t\)</span>的证明很简单：其左侧可由自反性直接得出，右侧则正是假设hp。最终我们得到</p>

<p>在构建上述结构化证明时，我们采用了与展示类型居留元（第1.4节）基本相同的流程，将函数箭头理解为逻辑蕴涵。这两种流程的相似性并非偶然，我们将在第4.7节详细阐述。</p>

<h3>4.4 演算式证明</h3>
<p>在非形式化数学中，我们常将证明表示为等式、不等式或等价关系的传递链（例如<span class="math">\(a=b=c, a \geq b \geq c\)</span>，或<span class="math">\(a \leftrightarrow b \leftrightarrow c\)</span>）。在Lean中，这类演算式证明通过calc命令实现，该命令提供轻量级语法，并自动为预注册关系（如等式和算术比较运算符）应用传递性定理。</p>

<pre><code>calc
    term
        <span class="math">\(o p_{1}\)</span> term <span class="math">\(_{1}:=\)</span>
        proo <span class="math">\(f_{1}\)</span>
    _ <span class="math">\(o p_{2}\)</span> term <span class="math">\(_{2}:=\)</span>
        proo <span class="math">\(f_{2}\)</span>
        <span class="math">\(\vdots\)</span>
    _op <span class="math">\(_{n}\)</span> term <span class="math">\(_{n}:=\)</span>
        proo <span class="math">\(f_{n}\)</span>
</code></pre>

<p>通用语法格式如下：</p>


<p>下划线（<em>）是语法的一部分。每个证明${ }</em>{i}$用于验证语句项<span class="math">\(_{1-t} o p_{i}\)</span>与项<span class="math">\(_{i}\)</span>的关系。运算符<span class="math">\(o p_{i}\)</span>不必相同，但必须彼此兼容。例如，<span class="math">\(=,&lt;\)</span>和<span class="math">\(\leq\)</span>是兼容的，而<span class="math">\(&gt;\)</span>与<span class="math">\(&lt;\)</span>则不兼容。</p>

<pre><code>theorem two_mul_example (m n : N) :
    2 * m + n = m + n + m :=
    calc
    2 * m + n = m + m + n :=
        by rw [Nat.two_mul]
    _ = m + n + m :=
        by ac_rfl
</code></pre>

<p>以下是一个简单示例：</p>

<div class="math">$$
\begin{aligned}
2 * m+n &amp; =(m+m)+n \\
&amp; =m+n+m
\end{aligned}
$$</div>
<div class="math">$$
\begin{aligned}
&amp; \text { (since } 2 * m=m+n) \\
&amp; \text { (by associativity and commutativity of }+)
\end{aligned}
$$</div>

<p>数学家们（假设他们愿意为如此简单的结果提供证明）可能会将上述证明大致写成如下形式：</p>

<pre><code>theorem two_mul_example_have (m n : N) :
    <span class="math">\(2 * m+n=m+n+m:=\)</span>
    have hmul : <span class="math">\(2 * m+n=m+m+n:=\)</span>
        by rw [Nat.two_mul]
    have hcomm : <span class="math">\(m+m+n=m+n+m:=\)</span>
        by ac_rfl
    show _ from
        Eq.trans hmul hcomm
</code></pre>

<p>在Lean证明中，下划线代表项<span class="math">\((m+m)+n\)</span>，若我们不使用calc结构编写证明，就必须重复书写该表达式。</p>

<p>需要注意的是，在使用have语句时，我们还需显式调用Eq.trans并为两个中间步骤命名。</p>

<h3>4.5 使用策略进行前向推理</h3>
<p>许多用户更倾向于使用策略模式而非结构化证明。但即使在策略模式下，混合前向与后向推理步骤的前向推理方式仍颇具价值。结构化证明命令have、let和calc同样可作为策略使用，这使得此类推理成为可能。</p>

<pre><code>theorem prop_comp_tactical (a b c : Prop) (hab : a <span class="math">\(\rightarrow\)</span> b)
    (hbc : b <span class="math">\(\rightarrow\)</span> c) :
    a <span class="math">\(\rightarrow\)</span> c :=
    by
        intro ha
        have hb : b :=
            hab ha
        let <span class="math">\(c^{\prime}:=c\)</span>
        have hc : c' :=
            hbc hb
        exact hc
</code></pre>

<p>以下示例展示了在我们已多次见过的定理上使用have和let策略：</p>


<p>have
have 名称 : 命题 :=
证明
have策略允许我们在策略模式中陈述并证明一个中间定理。随后，该定理将作为假设出现在目标状态中。</p>


<h4>let</h4>
<p>let 名称 <span class="math">\([\)</span> : 类型 <span class="math">\(]:=\)</span> 项
let 策略允许我们在策略模式中引入局部定义。随后，该定义符号及其定义将在目标状态中可用。</p>

<pre><code>calc
    term <span class="math">\(_{0}\)</span> op <span class="math">\(_{1}\)</span> term <span class="math">\(_{1}:=\)</span>
        proof <span class="math">\(_{1}\)</span>
    _ op <span class="math">\(_{2}\)</span> term <span class="math">\(_{2}:=\)</span>
        proof <span class="math">\(_{2}\)</span>
            \vdots
    _ op <span class="math">\(_{n}\)</span> term <span class="math">\(_{n}:=\)</span>
        proof <span class="math">\(_{n}\)</span>
</code></pre>

<h4>calc</h4>
<p>calc策略允许我们在策略模式中输入计算式证明（第4.4节）。该策略与同名结构化证明命令具有相同语法。我们可以将calc...（此处calc作为策略）视为apply (exact calc...)的别名，其中calc是前文所述的结构化证明命令。</p>


<h3>4.6 依赖类型</h3>
<p>依赖类型是依赖类型理论这一逻辑家族的定义性特征。尽管您可能不熟悉这个术语，但很可能以某种形式接触过这一概念。</p>

<div class="math">$$
(\text { pick } n:\{i: \mathbb{N} / / i \leq n\})_{n: \mathbb{N}}
$$</div>
<p>考虑一个函数pick，它接受一个自然数<span class="math">\(n\)</span>（即来自<span class="math">\(\mathbb{N}\)</span><span class="math">\(=\{0,1,2, \ldots\}\)</span>的值），并返回一个介于0到<span class="math">\(n\)</span>之间的自然数。直观上，pick <span class="math">\(n\)</span>的类型应为<span class="math">\(\{0,1, \ldots, n\}\)</span>（即由所有满足<span class="math">\(i \leq n\)</span>的自然数构成的类型）。在Lean中，该类型写作<span class="math">\(\{i: \mathbb{N} / / i \leq n\}\)</span>，这就是pick <span class="math">\(n\)</span>的类型。具有数学背景的读者可能会将pick视为一个<span class="math">\(\mathbb{N}\)</span>索引的项族</p>
<div class="math">$$
\text { pick }:(n: \mathbb{N}) \rightarrow\{i: \mathbb{N} / / i \leq n\}
$$</div>

<p>其中每个项的类型取决于索引——例如，pick <span class="math">\(5:\{i: \mathbb{N} / /\)</span> <span class="math">\(i \leq 5\)</span> }。但pick本身的类型应该是什么？我们希望表达pick是一个接收参数<span class="math">\(n: \mathbb{N}\)</span>并返回类型为<span class="math">\(\{i: \mathbb{N} / / i \leq n\}\)</span>的值的函数。为了捕捉这一点，我们将写作</p>


<p>这是一个依赖类型：结果的类型取决于参数<span class="math">\(n\)</span>的值。（变量名<span class="math">\(n\)</span>本身并不重要；我们也可以用<span class="math">\(m\)</span>或<span class="math">\(x\)</span>表示。）</p>


<p>除非另有说明，依赖类型通常指依赖于（非类型）项的类型，如上文所述，其中<span class="math">\(n: \mathbb{N}\)</span>作为项，<span class="math">\(\{i: \mathbb{N} / / i \leq n\}\)</span>作为依赖于它的类型。但需注意：类型也可能依赖于另一个类型——例如类型构造器List，其<span class="math">\(\eta\)</span>展开变体fun <span class="math">\(\alpha\)</span> : Type <span class="math">\(\mapsto\)</span> List <span class="math">\(\alpha\)</span>，或具有相同定义域和陪域的函数的多态类型fun <span class="math">\(\alpha\)</span> : Type <span class="math">\(\mapsto \alpha \rightarrow \alpha\)</span>。</p>
<ul>
<li>项可能依赖于类型——例如多态恒等函数fun <span class="math">\(\alpha\)</span> : Type <span class="math">\(\mapsto\)</span> fun <span class="math">\(x: \alpha \mapsto x\)</span>。</li>
<li>当然，项也可能依赖于项——例如fun <span class="math">\(n\)</span> : <span class="math">\(\mathbb{N}\)</span> <span class="math">\(\mapsto n+2\)</span>。
综上，fun <span class="math">\(x \mapsto t\)</span>存在四种情况：</li>
</ul>

<table>
<thead>
<tr>
  <th style="text-align:left">Body (t)</th>
  <th style="text-align:left">Argument (x)</th>
  <th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">A term depending on</td>
  <td style="text-align:left">a term</td>
  <td style="text-align:left">Simply typed <span class="math">\(\lambda\)</span>-expression</td>
</tr>
<tr>
  <td style="text-align:left">A type depending on</td>
  <td style="text-align:left">a term</td>
  <td style="text-align:left">Dependent type (in the narrow sense)</td>
</tr>
<tr>
  <td style="text-align:left">A term depending on</td>
  <td style="text-align:left">a type</td>
  <td style="text-align:left">Polymorphic term</td>
</tr>
<tr>
  <td style="text-align:left">A type depending on</td>
  <td style="text-align:left">a type</td>
  <td style="text-align:left">Polymorphic type constructor</td>
</tr>
</tbody>
</table>
<div class="math">$$
\begin{aligned}
&amp; \frac{C \vdash t:(x: \sigma) \rightarrow \tau[x] \quad C \vdash u: \sigma}{C \vdash t u: \tau[u]} \text { APP }^{\prime} \\
&amp; \frac{C, x: \sigma \vdash t: \tau[x]}{C \vdash(\text { fun } x: \sigma \mapsto t):(x: \sigma) \rightarrow \tau[x]} \text { FUN }^{\prime}
\end{aligned}
$$</div>
<p>最后三行对应Henk Barendregt的<span class="math">\(\lambda\)</span>-立方体的三个轴向。<span class="math">\({ }^{1}\)</span>第1.3节中提出的APP和FUN规则必须进行泛化以处理依赖类型：</p>

<p>记号<span class="math">\(\tau[x]\)</span>表示可能包含<span class="math">\(x\)</span>的类型，而<span class="math">\(\tau[u]\)</span>表示将<span class="math">\(x\)</span>的所有出现替换为<span class="math">\(u\)</span>后的相同类型。</p>


<p>当<span class="math">\(x\)</span>不出现于<span class="math">\(\tau[x]\)</span>时，即为简单类型情形。此时可直接用<span class="math">\(\sigma \rightarrow\)</span>替代<span class="math">\((x: \sigma) \rightarrow\)</span>。常见的<span class="math">\(\sigma \rightarrow \tau\)</span>记法等价于<span class="math">\(\_: \sigma) \rightarrow \tau\)</span>。容易验证当<span class="math">\(x\)</span>不在<span class="math">\(\tau[x]\)</span>中出现时，APP'与FUN'规则会退化为APP和FUN规则。</p>

<div class="math">$$
\frac{\vdash \text { pick }:(n: \mathbb{N}) \rightarrow i: \mathbb{N} / / i \leq n \quad \vdash 5: \mathbb{N}}{\vdash \text { pick } 5: i: \mathbb{N} / / i \leq 5} \text { APP }^{\prime}
$$</div>
<p>以下示例展示了APP'规则：</p>
<div class="math">$$
\frac{\alpha: \text { Type, } x: \alpha \vdash x: \alpha}{\alpha: \text { Type } \vdash(\text { fun } x: \alpha \mapsto x): \alpha \rightarrow \alpha} \text { FUN or FUN' }
$$</div>

<p>下一个示例展示FUN'：</p>


<p><span class="math">\(\vdash(\)</span> 函数 <span class="math">\(\alpha\)</span> : 类型 <span class="math">\(\mapsto\)</span> 函数 <span class="math">\(x: \alpha \mapsto x):(\alpha:\)</span> 类型 <span class="math">\() \rightarrow \alpha \rightarrow \alpha\)</span> FUN'</p>


<p>当前描述并不完整，因为我们仅验证了冒号(:)左侧的项（即实体）是良类型的。冒号右侧的类型（即实体）同样需要使用相同的类型系统进行验证。</p>


<p>例如，Nat.succ 的类型是<span class="math">\(\mathbb{N} \rightarrow \mathbb{N}\)</span>，而该类型本身的类型是Type。像Type和Prop这样的类型之类型被称为"宇宙"，我们将在第12章对其进行更深入的研究。</p>


<p>值得注意的是，全称量化实际上只是依赖类型的一个别名：<span class="math">\(\forall x: \sigma, \tau\)</span> 是 <span class="math">\((x: \sigma) \rightarrow \tau\)</span> 的简写形式。这一点将在下文中变得更加清晰。</p>


<h3>4.7 PAT原则</h3>
<p>你可能已经注意到，相同的符号<span class="math">\(\rightarrow\)</span>既用于表示蕴含关系（例如False <span class="math">\(\rightarrow\)</span> True），也用作函数的类型构造器（例如<span class="math">\(\mathbb{Z} \rightarrow \mathbb{N}\)</span>）。脱离上下文时，我们无法判断<span class="math">\(a \rightarrow b\)</span>究竟是指定义域为<span class="math">\(a\)</span>、陪域为<span class="math">\(b\)</span>的函数类型，还是指命题"a蕴含<span class="math">\(b\)</span>"。</p>

<div class="math">$$
\text { PAT }=\text { propositions as types } \quad \text { PAT }=\text { proofs as terms }
$$</div>

<p>事实证明，这两个概念不仅看起来相同，它们本质上是相同的。这被称为PAT原则，其中PAT是一个双重助记符：</p>


<p>此外，由于类型本身也是项，这也意味着命题同样是项。然而PAT并非四重助记符（-PAT——将证明视为类型）。还需注意并非所有类型都是命题，也并非所有项都是证明。</p>

<p>通过使用项和类型来表示证明和命题，依值类型理论实现了概念的精简整合。"H是否是P的证明？"这一问题等价于"项H是否具有类型P？"。因此，在Lean系统内部不存在独立的证明检查器，仅有类型检查器。所有证明均由类型检查器进行验证。</p>
<p>让我们逐一回顾这些基本要素。我们用数学变量<span class="math">\(\sigma, \tau\)</span>表示类型；<span class="math">\(P, Q\)</span>表示命题；<span class="math">\(t, u, x\)</span>表示项；<span class="math">\(h, G, H\)</span>表示证明。</p>
<p>从“命题即类型”出发，对于类型，我们有以下内容：</p>
<ul>
<li>
<span class="math">\(\sigma \rightarrow \tau\)</span> 是从 <span class="math">\(\sigma\)</span> 到 <span class="math">\(\tau\)</span> 的函数类型。</li>
<li>
<span class="math">\((x: \sigma) \rightarrow \tau[x]\)</span> 是从 <span class="math">\(x: \sigma\)</span> 到 <span class="math">\(\tau[x]\)</span> 的依赖类型函数。</li>
</ul>

<p>相比之下，对于命题，我们有以下对应关系：</p>
<ul>
<li>
<span class="math">\(P \rightarrow Q\)</span>可解读为"P蕴含<span class="math">\(Q\)</span>"，或是将<span class="math">\(P\)</span>的证明映射到<span class="math">\(Q\)</span>证明的函数类型。</li>
<li>
<span class="math">\(\forall x: \sigma, Q[x]\)</span>可解读为"对于所有<span class="math">\(x, Q[x]\)</span>"，或是类型为<span class="math">\((x: \sigma) \rightarrow Q[x]\)</span>的函数类型，将类型为<span class="math">\(\sigma\)</span>的值<span class="math">\(x\)</span>映射到<span class="math">\(Q[x]\)</span>的证明。
延续"证明即项"的对应关系，对于项我们有以下定义：</li>
<li>常量是项</li>
<li>变量是项</li>
<li>
<span class="math">\(t u\)</span>表示函数<span class="math">\(t\)</span>对参数<span class="math">\(u\)</span>的应用</li>
<li>fun <span class="math">\(x \mapsto t[x]\)</span>是将<span class="math">\(x\)</span>映射到<span class="math">\(t[x]\)</span>的函数</li>
</ul>


<p>相比之下，对于证明（即证明项），我们有以下规则：</p>
<ul>
<li>定理或假设的名称即构成证明。</li>
<li>H t 是通过将证明H的陈述中的前导<span class="math">\(\forall\)</span>量词用项<span class="math">\(t\)</span>实例化后得到的证明。</li>
<li>H G 是通过用证明G解除H的陈述中的前导假设后得到的证明。此操作称为假言推理。</li>
<li>fun <span class="math">\(h: P \mapsto H[h]\)</span> 是<span class="math">\(P \rightarrow Q\)</span>的证明，前提是对于所有<span class="math">\(h: P\)</span>，<span class="math">\(H[h]\)</span>都是<span class="math">\(Q\)</span>的证明。</li>
<li>fun <span class="math">\(x: \sigma \mapsto H[x]\)</span> 是<span class="math">\(\forall x: \sigma, Q[x]\)</span>的证明，前提是对于所有<span class="math">\(x: \sigma\)</span>，<span class="math">\(H[x]\)</span>都是<span class="math">\(Q[x]\)</span>的证明。
最后两种情况由Fun'规则证明有效。在结构化证明中（相对于原始证明项），我们会使用assume或fix替代fun，并且为了可读性可能会用show重复结论，如下所示：</li>
</ul>

<pre><code>theorem case_4 :
    <span class="math">\(P \rightarrow Q:=\)</span>
    assume <span class="math">\(h: P\)</span>
    show <span class="math">\(Q\)</span> from
        <span class="math">\(H[h]\)</span>
</code></pre>

<p>定理 case_5：
<span class="math">\(\forall x: \sigma, Q[x]:=\)</span>
固定 <span class="math">\(x: \tau\)</span>
由 <span class="math">\(H[x]\)</span> 证明 <span class="math">\(Q[x]\)</span></p>


<p>依赖类型理论的术语可能相当令人困惑，因为某些词汇具有狭义和广义的双重含义。下图展示了重要术语的各种含义：</p>


<p><img src="img-4.jpeg" alt="img-4.jpeg"></p>

<p>广义而言，任何表达式都是项，任何可能出现在类型判断右侧的表达式都是类型，而任何可能出现在左侧带有类型的类型判断右侧的表达式则是宇宙。这与将<span class="math">\(t: u\)</span>解读为"<span class="math">\(t\)</span>具有类型<span class="math">\(u\)</span>"以及宇宙是类型的类型这一概念相一致。</p>

<p>根据PAT原则，部分Lean命令虽有两个名称但本质相同。例如fix与assume实际上都是fun在LoVelib中的别名。此外也存在行为略有差异的配对命令，如def/theorem和let/have。根本区别在于：当我们定义函数或数据时，不仅关注类型还关注函数体——即具体行为；而定理一旦得证，其证明过程便不再重要，关键在于证明存在性。我们将在第12章重新讨论证明无关性这个话题。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">Tactical proof</th>
  <th style="text-align:left">Structured proof</th>
  <th style="text-align:left">Raw proof term</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">intro <span class="math">\(x\)</span>
</td>
  <td style="text-align:left">fix <span class="math">\(x: \tau\)</span>
</td>
  <td style="text-align:left">fun <span class="math">\(x \mapsto\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">intro <span class="math">\(h\)</span>
</td>
  <td style="text-align:left">assume <span class="math">\(h: P\)</span>
</td>
  <td style="text-align:left">fun <span class="math">\(h \mapsto\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">have <span class="math">\(k:=H\)</span>
</td>
  <td style="text-align:left">have <span class="math">\(k:=H\)</span>
</td>
  <td style="text-align:left">(fun <span class="math">\(k \mapsto \ldots) H\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">let <span class="math">\(x:=t\)</span>
</td>
  <td style="text-align:left">let <span class="math">\(x:=t\)</span>
</td>
  <td style="text-align:left">(fun <span class="math">\(x \mapsto \ldots) t\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">exact <span class="math">\((H: P)\)</span>
</td>
  <td style="text-align:left">show <span class="math">\(P\)</span> from <span class="math">\(H\)</span>
</td>
  <td style="text-align:left"><span class="math">\(H: P\)</span></td>
</tr>
<tr>
  <td style="text-align:left">calc</td>
  <td style="text-align:left">calc</td>
  <td style="text-align:left">calc</td>
</tr>
</tbody>
</table>

<p>下表总结了策略证明、结构化证明和原始证明项之间的区别：</p>


<p>请注意，<span class="math">\(x:=t\)</span>后接<span class="math">\(u\)</span>本质上是一种书写（fun <span class="math">\(x \mapsto u\)</span>）<span class="math">\(t\)</span>的方式，只是禁用了<span class="math">\(\beta\)</span>-规约。</p>


<h3>4.8 基于模式匹配与递归的归纳法</h3>
<p>在3.6节中，我们回顾了使用归纳策略进行归纳证明的方法。另一种更灵活的方式则依赖于模式匹配和PAT原理。</p>

<pre><code>def reverse <span class="math">\(\{\alpha\)</span> : Type \} : List <span class="math">\(\alpha \rightarrow\)</span> List <span class="math">\(\alpha\)</span>
    | [] <span class="math">\(\Rightarrow\)</span> []<span class="math">\(x:: x s=&gt;\)</span> reverse <span class="math">\(x s++[x]\)</span>
</code></pre>

<p>回顾2.2.3节末尾对列表反转的定义：</p>

<pre><code>theorem reverse_append <span class="math">\(\{\alpha\)</span> : Type \} :
    <span class="math">\(\forall x s\)</span> ys : List <span class="math">\(\alpha\)</span>,
        reverse <span class="math">\((x s++y s)=\)</span> reverse ys ++ reverse xs
    | [], ys =&gt; by simp [reverse]
    | x :: xs, ys =&gt; by simp [reverse, reverse_append xs]
</code></pre>

<p>事实上，reverse（反转）函数在Lean标准库中以List.reverse形式存在，其定义虽更高效但不利于推理。一个需要证明的有用性质是：reverse是其自身的逆运算，即对于所有列表xs，reverse (reverse <span class="math">\(x s\)</span> ) = xs。然而当我们尝试用归纳法证明时，很快会遇到障碍。归纳步骤为：
ih : <span class="math">\(\forall x s\)</span>, reverse (reverse <span class="math">\(x s\)</span> ) = xs <span class="math">\(\vdash\)</span> reverse (reverse <span class="math">\(x s++[x]\)</span> ) = x : : xs
注意到<span class="math">\(++[x]\)</span>在双重reverse嵌套中的存在令人不适。我们需要一种方法将外层的reverse"分配"到++操作上，以获得与归纳假设左侧匹配的项。技巧在于证明并使用以下定理：</p>


<p>该定理的证明过程看起来更像递归函数定义而非证明。左侧的模式[]和<span class="math">\(x\)</span>::xs对应<span class="math">\(\forall\)</span>量词变量<span class="math">\(x\)</span>s的两个构造子。每个=&gt;符号右侧是对应情况的证明。可进行模式匹配的变量是<span class="math">\(\forall\)</span>量词中按出现顺序排列的变量（此处为<span class="math">\(x\)</span>s和<span class="math">\(y\)</span>s）。在归纳步骤的证明中，归纳假设以正在证明的定理名（reverse_append）存在。</p>


<p>我们显式地将<span class="math">\(x s\)</span>作为参数传递给归纳假设。这限制了该假设仅适用于<span class="math">\(x\)</span>s而不适用于其他列表。特别地，这确保了定理不会被应用于<span class="math">\(x\)</span>::<span class="math">\(x\)</span>s的情况，否则可能导致循环证明："要证明reverse_append(<span class="math">\(x\)</span>::xs)，需使用reverse_append(<span class="math">\(x\)</span>::xs)"。Lean的终止检查器会检测到这种非良基的证明并报错，但我们需要避免这种情况。此外，显式参数xs具有文档说明的作用，明确表示"我们需要的定理唯一递归实例就是针对xs的"。</p>

<pre><code>theorem reverse_append_tactical {x : Type} (xs ys : List }\alpha\mathrm{ ) :
    reverse (xs ++ ys) = reverse ys ++ reverse xs :=
    by
        induction xs with
        | nil =&gt; simp [reverse]
        | cons x xs' ih =&gt; simp [reverse, ih]
</code></pre>
<p>作为参考，策略式证明如下：</p>

<p>若将[y]替代ys，该定理同样可证且有用。但养成尽可能普遍地陈述定理的习惯是良好的，这能产生更具可复用性的代码库。此外，在归纳证明中，这通常是获得足够强归纳假设的必要条件。一般而言，寻找恰当的归纳方式和定理需要思考与创造性。</p>

<pre><code>theorem name (params <span class="math">\(\left.{ }_{1}: \operatorname{type}_{1}\right) \ldots\left(\right.\)</span> params <span class="math">\(_{n}:\)</span> type <span class="math">\(_{m}\)</span> ) :
    statement
    | patterns <span class="math">\(_{1}=&gt;\)</span> proof <span class="math">\(_{1}\)</span>
        \vdots
    | patterns <span class="math">\(_{n}=&gt;\)</span> proof <span class="math">\(_{n}\)</span>
</code></pre>

<p>支持对多个变量进行同步模式匹配（例如上文中的xs和ys）。各模式之间需用逗号分隔，其通用格式为</p>

<p>请注意其与def语法（第2.2节）的高度相似性。这两个命令实际上几乎相同，但theorem会将定义的项或证明视为不透明，而def则保持其透明性。由于定理一旦被证明后实际证明过程就无关紧要（第12节），后续无需再展开它们。类似的区别也存在于let和have之间。</p>

<p>根据PAT原理，通过模式匹配和递归进行的归纳证明与递归证明项是相同的。当我们调用归纳假设时，实际上就是在递归地调用一个递归函数。这解释了为什么归纳假设与我们证明的定理具有相同的名称。Lean的终止检查器用于确立归纳证明的良基性。</p>

<pre><code>theorem reverse_reverse <span class="math">\(\{\alpha\)</span> : Type \} :
    <span class="math">\(\forall x s\)</span> : List <span class="math">\(\alpha\)</span>, reverse (reverse <span class="math">\(x s)=x s\)</span>
    | [] <span class="math">\(\quad=&gt;\)</span> by rfl
    <span class="math">\(\mid x:: x s=&gt;\)</span>
    by simp [reverse, reverse_append, reverse_reverse xs]
</code></pre>

<p>在完成reverse_append定理的证明后，我们可以回到最初的目标：</p>


<p>模式匹配与递归归纳在Lean用户中颇受欢迎。其主要优势在于便捷的语法以及对良基归纳的支持——这种归纳方式比induction策略提供的结构归纳更强大（见第3.7节）。然而在本指南中，我们并不需要良基归纳的全部能力。此外，由于微妙的逻辑原因，模式匹配与递归归纳不适用于归纳谓词（这是第6章的主题）。基于这些原因，我们将更频繁地选用induction策略。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">assume</th>
  <th style="text-align:left">states assumptions</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">calc</td>
  <td style="text-align:left">combines proofs by transitivity</td>
</tr>
<tr>
  <td style="text-align:left">fix</td>
  <td style="text-align:left">fixes variables</td>
</tr>
<tr>
  <td style="text-align:left">have</td>
  <td style="text-align:left">states an intermediate theorem</td>
</tr>
<tr>
  <td style="text-align:left">let</td>
  <td style="text-align:left">introduces a local definition</td>
</tr>
<tr>
  <td style="text-align:left">show</td>
  <td style="text-align:left">states the target</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
  <th style="text-align:left">calc</th>
  <th style="text-align:left">combines proofs by transitivity</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">have</td>
  <td style="text-align:left">states an intermediate theorem</td>
</tr>
<tr>
  <td style="text-align:left">let</td>
  <td style="text-align:left">introduces a local definition</td>
</tr>
</tbody>
</table>

<h3>4.9 新引入的Lean结构摘要</h3>
<h4>证明命令</h4>
<h4>策略</h4>
<h1>第二部分：函数式逻辑编程</h1>
<h2>第五章：函数式编程</h2>
<p>我们将深入探讨类型化函数式编程的核心要素：归纳类型、归纳证明、递归函数、模式匹配、结构体（记录）和类型类。这里涉及的概念在《Lean 4定理证明》第7至10章中有更详细的阐述。</p>

<h3>5.1 归纳类型</h3>
<p>归纳类型的建模灵感来源于类型化函数式编程语言（如Haskell、ML、OCaml）的数据类型，同时也让人联想到Scala中的密封类。在第2章中，我们已经接触过一些基础的归纳类型：自然数、算术表达式类型以及有限列表。本章我们将重新审视列表结构，并研究二叉树。此外，我们还将简要探讨长度为<span class="math">\(n\)</span>的向量——一种依赖类型。</p>
<pre><code>inductive Nat : Type where
    | zero : Nat
    | succ : Nat <span class="math">\(\rightarrow\)</span> Nat
</code></pre>

<p>回顾将自然数定义为归纳类型的定义：</p>


<p>这定义了Nat类型及两个构造子Nat.zero和Nat.succ。该定义还断言了构造子的某些性质。此外，它还引入了更多内部使用的常量以支持归纳和递归。</p>


<p>如第2.1节所述，归纳类型是指其成员仅包含通过有限次应用其构造子所构建的值，且仅包含这些值。核心原则：</p>
<ul>
<li>无冗余：该类型不包含超出构造子可表达范围的值。</li>
<li>无歧义：通过不同构造子组合构建的值互不相同。</li>
</ul>


<p>对于自然数而言，"无冗余"意味着不存在无法通过有限次组合Nat.zero和Nat.succ表示的特殊值（如<span class="math">\(-1, c, \infty\)</span>或NAN），而"无歧义"则确保对于所有n都有Nat.zero <span class="math">\(\neq\)</span> Nat.succ n，且Nat.succ是单射的。此外，归纳类型的值总是有限的。无限项</p>


<p>Nat.succ (Nat.succ (Nat.succ (Nat.succ ...))) 并不是一个有效值。也不存在满足 Nat.succ <span class="math">\(n=n\)</span> 的值 <span class="math">\(n\)</span>，我们将在下文证明这一点。</p>


<p>归纳类型使用起来非常方便，因为它们支持归纳和递归且其构造子行为良好，但并非所有类型都能定义为归纳类型。特别是数学类型如<span class="math">\(\mathbb{Q}\)</span>（有理数）和<span class="math">\(\mathbb{R}\)</span>（实数）需要基于商类型和子类型的更复杂构造方法，这将在第12章和第14章进行说明。</p>

<div class="math">$$
\begin{gathered}
\vdash P[\varnothing] \\
k: \mathbb{N}, i h: P[k] \vdash P[k+1]
\end{gathered}
$$</div>

<h3>5.2 结构归纳法</h3>
<p>结构归纳法是数学归纳法在任意归纳类型上的推广。要通过结构归纳法证明目标<span class="math">\(n: \mathbb{N} \vdash P[n]\)</span>，只需证明两个子目标（传统上称为基例和归纳步骤）：</p>

<div class="math">$$
h Q: Q, n: \mathbb{N}, h R: R[n] \vdash S[n]
$$</div>

<p>当然，我们也可以用Nat.zero和Nat.succ k来代替<span class="math">\(\varnothing\)</span>和<span class="math">\(k+1\)</span>。但一般情况下，情况会更加复杂。目标可能包含一些不依赖于<span class="math">\(n\)</span>的额外假设（例如Q），以及其他依赖于<span class="math">\(n\)</span>的假设（例如<span class="math">\(R[n]\)</span>）。假设我们各有一个这样的假设，这就给出了初始目标</p>

<div class="math">$$
\begin{gathered}
h Q: Q, h R: R[\varnothing] \vdash S[\varnothing] \\
h Q: Q, k: \mathbb{N}, i h: R[k] \rightarrow S[k], h R: R[k+1] \vdash S[k+1]
\end{gathered}
$$</div>

<p>对<span class="math">\(n\)</span>进行结构归纳后会产生两个子目标</p>


<p>假设<span class="math">\(Q\)</span>直接从初始目标中原封不动地保留下来，而<span class="math">\(R[n] \vdash S[n]\)</span>的处理方式几乎与目标结论是<span class="math">\(R[n] \rightarrow\)</span> <span class="math">\(S[n]\)</span>时相同。通过在前文第一个示例中取<span class="math">\(P[n]:=R[n] \rightarrow S[n]\)</span>即可轻松验证这一点。由于这种通用格式非常冗长且信息量有限（鉴于我们已经理解其运作原理），从现在起我们将以最简单的形式呈现目标，不再包含额外假设。</p>

<div class="math">$$
\begin{gathered}
\vdash P[[]] \\
y: \alpha, y s: \text { list } \alpha, i h: P[y s] \vdash P[y:: y s]
\end{gathered}
$$</div>

<p>对于列表，给定目标<span class="math">\(x s\)</span> : list <span class="math">\(\alpha \vdash P[x s]\)</span>，对<span class="math">\(x s\)</span>进行结构归纳可得</p>


<p>当然我们也可以写作List.nil和List.cons y ys。由于<span class="math">\(y\)</span>不是列表类型，因此没有与之关联的归纳假设。</p>

<div class="math">$$
i: \mathbb{Z} \vdash P[A E x p . n u m ~ i] \quad x: \text { String } \vdash P[A E x p . v a r ~ x]
$$</div>

<p>对于算术表达式，基本情况是</p>

<pre><code><span class="math">\(\mathrm{e}_{1} \mathrm{e}_{2}:\)</span> AExp, ih <span class="math">\(_{1}: \mathrm{P}\left[\mathrm{e}_{1}\right]\)</span>, ih <span class="math">\(_{2}: \mathrm{P}\left[\mathrm{e}_{2}\right] \vdash \mathrm{P}\left[\mathrm{AExp} . \mathrm{add} \mathrm{e}_{1} \mathrm{e}_{2}\right]\)</span>
<span class="math">\(e_{1} e_{2}:\)</span> AExp, ih <span class="math">\(_{1}: \mathrm{P}\left[\mathrm{e}_{1}\right]\)</span>, ih <span class="math">\(_{2}: \mathrm{P}\left[\mathrm{e}_{2}\right] \vdash \mathrm{P}\left[\mathrm{AExp} . \operatorname{sub} \mathrm{e}_{1} \mathrm{e}_{2}\right]\)</span>
<span class="math">\(e_{1} e_{2}:\)</span> AExp, ih <span class="math">\(_{1}: \mathrm{P}\left[\mathrm{e}_{1}\right]\)</span>, ih <span class="math">\(_{2}: \mathrm{P}\left[\mathrm{e}_{2}\right] \vdash \mathrm{P}\left[\mathrm{AExp} . \mathrm{mul} \mathrm{e}_{1} \mathrm{e}_{2}\right]\)</span>
</code></pre>
<p>归纳步骤为</p>

<p>注意关于<span class="math">\(e_{1}\)</span>和<span class="math">\(e_{2}\)</span>的两个归纳假设。一般而言，结构归纳会为每个构造子生成一个子目标。在每个子目标中，对于正在进行归纳的类型，其所有构造子参数都可获得相应的归纳假设。</p>

<p>给定一个归纳类型<span class="math">\(\tau\)</span>，计算子目标的过程始终相同：</p>
<ol>
<li>将<span class="math">\(\mathrm{P}[\mathrm{]}\)</span>中的空缺替换为每个可能的构造子应用于新变量（例如<span class="math">\(y\)</span> :: ys），生成与构造子数量相同的子目标。</li>
<li>将这些新变量（例如<span class="math">\(y\)</span>、ys）添加到局部上下文中。</li>
<li>为所有类型为<span class="math">\(\tau\)</span>的新变量添加归纳假设。</li>
</ol>

<p>举例来说，我们将证明对于所有<span class="math">\(\mathrm{n}: \mathbb{N}\)</span>，Nat.succ <span class="math">\(\mathrm{n} \neq \mathrm{n}\)</span>成立。首先给出一个非形式化证明：</p>


<p>该证明采用对<span class="math">\(n\)</span>的结构归纳法。基本情况0：需证明Nat.succ <span class="math">\(\circ \neq \circ\)</span>，这由归纳类型构造子的"无混淆性"性质直接可得。归纳情况Nat.succ k：归纳假设为Nat.succ <span class="math">\(\mathrm{k} \neq \mathrm{k}\)</span>。需证明Nat.succ (Nat.succ k) <span class="math">\(\neq\)</span> Nat.succ k。根据Nat.succ的单射性，Nat.succ (Nat.succ k) = Nat.succ k等价于Nat.succ <span class="math">\(k=k\)</span>。因此只需证明Nat.succ <span class="math">\(k \neq k\)</span>，而这正好与归纳假设相符。</p>


<p>请注意这个非正式证明的主要特征，在你自己进行非正式论证时应尽量重现这些特点：</p>
<ul>
<li>证明开始时明确声明了所采用的证明类型（例如使用何种归纳法及作用于哪个变量）。</li>
<li>各案例被清晰标识，且每个案例中都明确陈述了证明目标和假设条件。</li>
<li>明确引用了证明所依赖的关键定理（例如Nat.succ的单射性）。现在让我们在Lean中完成这个证明：</li>
</ul>

<pre><code>theorem Nat.succ_neq_self ( <span class="math">\(\mathrm{n}: \mathbb{N}\)</span> ) :
    Nat.succ <span class="math">\(\mathrm{n} \neq \mathrm{n}:=\)</span>
    by
    induction n with
    | zero <span class="math">\(\quad=&gt;\)</span> simp
    | succ n' ih =&gt; simp [ih]
</code></pre>
<p>关于构造函数的常规推理都由simp自动完成。</p>
<pre><code>def fact : N -&gt; N
    | 0 =&gt; 0
    | n + 1 =&gt;(n + 1)* fact n
</code></pre>

<h3>5.3 结构递归</h3>
<p>结构递归是一种递归形式，允许我们从递归值上剥离一个构造子。以下阶乘函数即为结构递归：</p>


<p>这里我们剥离的构造子是Nat.succ（写作+1）。这类函数保证在递归停止前只会有限次调用自身；例如，fact 12345将会调用自身12345次。该函数被称为可终止的。这一性质有助于确保逻辑一致性。</p>

<pre><code>def factThreeCases : N -&gt; N
    | 0 =&gt; 0
    | 1 =&gt; 1
    | n + 1 =&gt;(n + 1)* factThreeCases n
</code></pre>

<p>在结构递归中，方程式的数量与构造器的数量相等。初学者常会倾向于添加多余的冗余分支，如下例所示：</p>


<p>抵制这种诱惑符合你自身的最大利益。定义中包含的案例越多，进行相关推理时所需的工作量就越大。请牢记这句格言：一个好的定义抵得上三个定理。</p>

<pre><code>-- fails
def illegal : N -&gt; N
    | n =&gt; illegal n + 1
</code></pre>

<p>对于结构递归函数，Lean能自动证明终止性。但对于更一般的递归模式，终止性检查可能会失败。有时这种失败是合理的，如下例所示：</p>


<p>如果Lean接受了这个定义，我们就能利用它来证明<span class="math">\(\circ=1\)</span>——只需在等式<span class="math">\(n=\)</span>非法<span class="math">\(n+1\)</span>两边同时减去非法的<span class="math">\(n\)</span>。从<span class="math">\(\circ=1\)</span>出发，我们可以推导出False（假命题），而基于False又能推导出任意命题。显然，我们绝不允许这种情况发生。</p>

<pre><code>opaque immoral : N -&gt; N
axiom immoral_eq (n : N) :
    immoral n = immoral n + 1
theorem proof_of_False :
    False :=
    have hi : immoral }\circ\mathrm{ = immoral }\circ+1\mathrm{ :=
    immoral_eq 0
    have him :
    immoral }\circ\mathrm{ - immoral }\circ\mathrm{ = immoral }\circ+1\mathrm{-immoral }\circ\mathrm{ :=
    by rw [+-hi]
    have h@eq1 : }\circ\mathrm{ = 1 :=

    by simp at him
show False from
    by simp at hoeq1
</code></pre>

<p>若我们使用了opaque和axiom，将无任何补救余地：</p>


<p>相较于opaque和axiom，更倾向于使用def的另一个原因是定义方程可用于计算。诸如rfl这类在计算层面实现统一的策略，每当我们引入一个定义时就会变得更强大，且诊断命令#eval和#reduce可应用于已定义的常量。</p>


<p>细心的读者可能已经注意到，上述阶乘定义在数学上是错误的：无论参数为何，fact和factThreeCases函数都惊人地返回0。我们简直是把阶乘(fact)搞砸了。这些令人尴尬的错误提醒我们要测试定义并证明其某些属性。虽然有缺陷的公理偶尔会出现，但更常见的是定义未能捕捉预期概念的情况。仅仅因为一个函数被命名为fact，并不意味着它真的能计算阶乘。</p>

<pre><code>match <span class="math">\(\operatorname{term}_{1}, \ldots, \operatorname{term}_{n}\)</span> with
    | pattern <span class="math">\(_{11}, \ldots\)</span>, pattern <span class="math">\(_{1 m} \Rightarrow\)</span> result <span class="math">\(_{1}\)</span>
        <span class="math">\(\vdots\)</span>
    | pattern <span class="math">\(_{n 1}, \ldots\)</span>, pattern <span class="math">\(_{n m} \Rightarrow\)</span> result <span class="math">\(_{n}\)</span>
</code></pre>

<h3>5.4 模式匹配表达式</h3>
<p>模式匹配不仅可以在def命令的顶层进行，还可以通过match表达式在项的深层结构中实现。该构造具有以下通用语法：</p>


<p>该构造让人联想到某些现代编程语言中的match语句。上述匹配表达式的英文翻译如下：</p>


<p>考虑项 term <span class="math">\(_{1}, \ldots\)</span>、term <span class="math">\(_{n}\)</span>。若它们分别匹配模式 pattern <span class="math">\(_{11}, \ldots\)</span>、pattern <span class="math">\(_{1 m}\)</span>，则生成结果 result <span class="math">\(_{1}\)</span>。</p>


<p>若它们分别为模式<span class="math">\(_{n 1}, \ldots\)</span>、模式<span class="math">\(_{n m}\)</span>的形式，则生成结果<span class="math">\(_{n}\)</span>。</p>


<p>模式中可包含变量、构造器及无名占位符(<em>)。结果${ }</em>{1}$表达式可引用对应模式中引入的变量。</p>

<pre><code>def bcount { }\alpha\mathrm{ : Type} (p : \alpha -&gt; Bool) : List \alpha -&gt; N
    | [] =&gt; 0
    | x :: xs =&gt;
        match p x with
        | true =&gt; bcount p xs + 1
        | false =&gt; bcount p xs
</code></pre>

<p>以下函数定义展示了表达式内模式匹配的语法：</p>

<p>bcount函数用于计算列表中满足给定谓词<span class="math">\(p\)</span>的元素数量。该谓词的陪域为Bool类型。根据通用规则，我们将在程序中使用布尔类型Bool，而在陈述程序属性时使用命题类型Prop。Bool类型的两个值称为false和true（小写形式）。<span class="math">\({ }^{1}\)</span> 逻辑连接词分别称为或（中缀：||）、与（中缀：88）和非（前缀：!）。</p>

<p>下图展示了Bool和Prop类型的解释：</p>


<p><img src="img-5.jpeg" alt="img-5.jpeg"></p>

<p>点表示元素，圆圈表示类型，矩形则表示类型的类型（即宇宙）。可以看到Bool被解释为包含两个值的集合，而Prop由无限多个命题（即类型）组成，每个命题又包含零个或多个证明（即元素）。我们将在第6章完善这一图示。</p>
<pre><code>def min (a b : N) : N :=
    if a \leq b then a else b
</code></pre>
<p>我们无法对命题（Prop类型）进行模式匹配，但可以使用if-then-else结构替代。例如，自然数的最小值运算符可定义如下：</p>

<p>这需要一个可判定的（即可执行的）命题。对于<span class="math">\(\leq\)</span>关系便是如此：给定具体参数（例如35和49），Lean能将<span class="math">\(35 \leq 49\)</span>规约为True。Lean通过类型类机制来跟踪可判定性，下文将对此进行解释。</p>


<h3>5.5 结构体</h3>
<p>Lean 提供了一种便捷的语法用于定义结构体（亦称记录）。这些本质上是通过语法糖封装的非递归单构造器归纳类型。</p>

<pre><code>structure RGB where
    red : N
    green : N
    blue : N
</code></pre>

<p>以下定义引入了一个名为RGB的结构体，该结构体包含三个类型为N的字段：red、green和blue：</p>

<pre><code>inductive RGB : Type where
    | mk : N -&gt; N -&gt; N -&gt; RGB

def RGB.red : RGB <span class="math">\(\rightarrow\)</span> N
    | RGB.mk r _ _ =&gt; r
def RGB.green : RGB <span class="math">\(\rightarrow\)</span> N
    | RGB.mk _ g _ =&gt; g
def RGB.blue : RGB <span class="math">\(\rightarrow\)</span> N
    | RGB.mk _ _ b =&gt; b
</code></pre>
<p>该定义的效果大致等同于以下命令：</p>
<pre><code>structure RGBA extends RGB where
    alpha : N
</code></pre>
<p>我们可以将新结构定义为现有结构的扩展。以下定义通过添加名为alpha的第四个字段来扩展RGB结构：</p>
<pre><code>structure structure-name (params 1 : type 1 ) ... (params 12 : type 1
    [extends structure <span class="math">\(_{1}, \ldots\)</span>, structure <span class="math">\(_{n}\)</span> ] where
    field-name <span class="math">\(_{1}\)</span> : field-type <span class="math">\(_{1}\)</span>
        \vdots
    field-name <span class="math">\(_{n}\)</span> : field-type <span class="math">\(_{n}\)</span>
</code></pre>
<p>定义结构体的通用语法为</p>

<p>参数params <span class="math">\(_{1}, \ldots\)</span>, params <span class="math">\(_{k}\)</span>实质上是额外的字段，但与字段名<span class="math">\(_{1}, \ldots\)</span>, 字段名<span class="math">\(_{n}\)</span>不同，它们作为类型构造器(结构名称)的参数存储在类型中。</p>

<pre><code>def pureRed : RGB :=
    RGB.mk oxff oxoo oxoo
def pureGreen : RGB :=
    { red := oxoo
        green := oxff
        blue := oxoo }
def semitransparentGreen : RGBA :=
    { pureGreen with
        alpha := ox7f }
</code></pre>

<p>数值可通过多种语法格式指定：</p>


<p>semitransparentGreen的定义复制了pureGreen的所有值，但显式设置了alpha字段。</p>

<pre><code>def shuffle (c : RGB) : RGB :=
    { red := RGB.green c
        green := RGB.blue c
        blue := RGB.red c }
</code></pre>
<p>接下来，我们定义一个名为shuffle的操作：</p>
<pre><code>theorem shuffle_shuffle_shuffle (c : RGB) :
    shuffle (shuffle (shuffle c)) = c :=
    by rfl
</code></pre>

<p>该定义依赖于生成的选取器RGB.red、RGB.green和RGB.blue。除了RGB.red c这种写法，我们也可以写成c.red，其他字段同理。有时我们会在Lean的输出中看到这种表示法，即便我们自己并不使用它。连续应用shuffle操作三次等同于完全不应用该操作：</p>


<h3>5.6 类型类</h3>
<p>类型类是一种由Haskell推广并被多个证明辅助工具采用的机制。在Lean中，类型类是一种结合了抽象常量及其属性的结构类型。<span class="math">\({ }^{2}\)</span> 通过为常量提供具体定义并证明属性成立，可以将某个类型声明为类型类的实例。Lean会根据类型检索相应的实例。</p>

<pre><code>class Inhabited ( }\alpha\mathrm{ : Type) : Type where
    default : }\alpha
</code></pre>

<p>一个简单的例子是类型类Inhabited，它仅需要一个常量Inhabited.default且不包含任何属性：</p>


<p>语法与结构体相同，只是用关键字class替代了structure。参数<span class="math">\(\alpha\)</span>表示可能属于该类的任意类型。这个特定类型类虽然只有一个参数和一个字段，但通常类型类可以包含多个参数和多个字段。</p>

<pre><code>instance Nat.Inhabited : Inhabited N :=
    { default := 0 }
</code></pre>

<p>任何至少包含一个元素的类型都可以注册为Inhabited类型类的实例。例如，我们可以通过选择一个任意数字作为默认值来注册<span class="math">\(\mathbb{N}\)</span>：</p>


<p>这定义了一个名为Nat.Inhabited的值，其类型为Inhabited <span class="math">\(\mathbb{N}\)</span>。由于我们使用instance关键字而非def，该结构值会被注册为规范实例，每当需要Inhabited <span class="math">\(\mathbb{N}\)</span>类型的结构时就会使用它。在存储类型类实例的全局表中，现在存在一条记录</p>

<pre><code>instance List.Inhabited { }\alpha\mathrm{ : Type} : Inhabited (List }\alpha\mathrm{ :=
    { default := [] }
</code></pre>

<p>对于自然数集合，存在一个名为Nat.Inhabited的类型类实例，其类型为Inhabited <span class="math">\(\mathbb{N} \mapsto\)</span>。对于列表而言，空列表是一个明显的默认值，即使类型<span class="math">\(\alpha\)</span>未被实例化时也可构造：</p>

<div class="math">$$
\text { Inhabited (List ? } \alpha \text { ) } \mapsto \text { List. Inhabited }
$$</div>

<p>这会将以下条目添加到全局表中：</p>


<p>举例而言，注意到类型为<span class="math">\(\alpha \rightarrow \beta\)</span>的有限函数可以通过其函数表表示，该表的类型为<span class="math">\(\beta \times \cdots \times \beta\)</span>（包含<span class="math">\(|\alpha|\)</span>个<span class="math">\(\beta\)</span>副本）。因此，<span class="math">\(|\alpha \rightarrow \beta|=|\beta|^{|\alpha|}\)</span>。要使之为<span class="math">\(\theta\)</span>，必须同时满足<span class="math">\(|\beta|=\theta\)</span>且<span class="math">\(|\alpha| \neq \theta\)</span>。换言之，当满足以下任一条件时，类型<span class="math">\(\alpha \rightarrow \beta\)</span>是可居留的：(1) <span class="math">\(\beta\)</span>可居留，或(2) <span class="math">\(\alpha\)</span>不可居留。我们将重点讨论情况(1)：</p>


<p>实例 Fun.Inhabited <span class="math">\(\{\alpha \beta\)</span> : 类型 <span class="math">\(\}\)</span> [Inhabited <span class="math">\(\beta]\)</span> : Inhabited <span class="math">\((\alpha \rightarrow \beta):=\)</span> { 默认值 := fun a : <span class="math">\(\alpha \mapsto\)</span> Inhabited.default }
该实例自身依赖于相同类型类但作用于不同类型的另一个实例。这种情况经常发生。</p>

<pre><code>instance Prod.Inhabited <span class="math">\(\{\alpha \beta\)</span> : Type \}
    [Inhabited <span class="math">\(\alpha]\)</span> [Inhabited <span class="math">\(\beta]\)</span> :
Inhabited <span class="math">\((\alpha \times \beta):=\)</span>
\{ default := (Inhabited.default, Inhabited.default) \}
</code></pre>

<p>类型 <span class="math">\(\alpha \times \beta\)</span> 表示有序对（也称为积类型），其值的形式为 <span class="math">\((a, b)\)</span>，其中 <span class="math">\(a: \alpha\)</span> 且 <span class="math">\(b: \beta\)</span>。给定一个有序对 <span class="math">\(a b: \alpha \times \beta\)</span>，可以通过 Prod.fst ab 和 Prod.snd ab 分别提取第一和第二分量。要为 <span class="math">\(\alpha \times \beta\)</span> 提供居元，我们需要同时具备 <span class="math">\(\alpha\)</span> 的居元和 <span class="math">\(\beta\)</span> 的居元：</p>

<pre><code>def head { }\alpha\mathrm{ : Type} [Inhabited }\alpha\mathrm{ ] : List }\alpha\mathrm{ \rightarrow }\alpha
    | [] =&gt; Inhabited.default
    | x :: _ =&gt; x
</code></pre>
<p>利用Inhabited类型类，我们可以定义列表的head操作：该函数返回列表的首个元素。由于空列表不包含任何元素，这种情况下无法返回有意义的值。给定一个属于Inhabited类型类的类型时，我们可以直接返回默认值：</p>
<p>我们通过书写[Inhabited <span class="math">\(\alpha\)</span> ]来要求<span class="math">\(\alpha\)</span>属于Inhabited类型类。这使得我们可以在定义中访问Inhabited.default值。</p>

<p>语法[Inhabited <span class="math">\(\alpha\)</span> ]会添加一个关于头常量的隐式参数。但与其他隐式参数不同，Lean会通过所有已声明的实例进行类型类搜索以确定该参数的值。因此，在执行命令时</p>


<h4>#eval head ([] : List <span class="math">\(\mathbb{N}\)</span> )</h4>
<p>Lean将寻找Inhabited <span class="math">\(\mathbb{N}\)</span>实例并找到我们之前声明的Nat.Inhabited实例。在该声明中，我们将default设置为<span class="math">\(\theta\)</span>，因此这就是#eval输出的值。如果有多个适用实例且Lean选择了错误的实例，我们可以使用<span class="math">\(\square\)</span>语法将类型类参数转换为显式参数，并提供所需的类型类实例。</p>

<div class="math">$$
\text { Inhabited.default }\{\alpha: \text { Type }\}[\text { Inhabited } \alpha]: \alpha
$$</div>
<p>让我们更仔细地看看 Inhabited.default：</p>

<p>请注意，普通结构的选择器使用圆括号( )，而类型类的选择器使用方括号[ ]。当我们使用Inhabited.default <span class="math">\(\alpha\)</span>来定义head时，Lean会在已注册实例的全局表和局部上下文中查找Inhabited <span class="math">\(\alpha\)</span>的实例。全局表中存在Inhabited <span class="math">\(\mathbb{N}\)</span>的条目，但没有匹配Inhabited <span class="math">\(\alpha\)</span>的条目。而局部上下文中包含一个类型为Inhabited <span class="math">\(\alpha\)</span>的匿名参数，该参数可以被使用。</p>


<p>Lean的核心库与我们定义的方式完全一致地实现了List.head。实际上，几乎所有类型都是非空的（False是显著例外），因此Inhabited的类型约束几乎不会造成问题。</p>

<p>我们可以证明关于Inhabited类型类的抽象定理，例如定理head_head { <span class="math">\(\alpha\)</span> : Type} [Inhabited <span class="math">\(\alpha\)</span> ] (xs : List <span class="math">\(\alpha\)</span> ) : head [head xs] = head xs</p>
<p>需要[Inhabited <span class="math">\(\alpha\)</span>]假设才能对List <span class="math">\(\alpha\)</span>类型的列表使用head操作符。若省略此假设，Lean将抛出错误提示类型类合成失败。</p>
<pre><code>class Zero ( }\alpha\mathrm{ : Type) where
    zero : }\alpha
class Neg ( }\alpha\mathrm{ : Type) where
    neg : }\alpha\mathrm{ \rightarrow }\alpha
class Add ( }\alpha\mathrm{ : Type) where
    add : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha
</code></pre>

<p>还存在更多仅包含常量而无属性的类型类，例如</p>


<p>类 One (<span class="math">\(\alpha\)</span> : Type) 其中 one : <span class="math">\(\alpha\)</span>
类 Inv (<span class="math">\(\alpha\)</span> : Type) 其中 inv : <span class="math">\(\alpha \rightarrow \alpha\)</span>
类 Mul (<span class="math">\(\alpha\)</span> : Type) 其中 mul : <span class="math">\(\alpha \rightarrow \alpha \rightarrow \alpha\)</span></p>


<p>这些语法类型类引入了在不同上下文中具有不同语义的常量。例如，one可以表示自然数1、整数1、实数1、单位矩阵以及其他多种"一"的概念。这些类型类的主要目的是为代数类型类（群、幺半群、环、域等）构建丰富的层次结构奠定基础，并允许重载常见的数学符号，如<span class="math">\(* \mathrm{,}, \mathrm{,}\)</span>和-1。</p>


<p>语法类型类并不对可声明实例的类型施加严格限制。相比之下，语义类型类包含的属性会约束给定常量的行为方式。</p>

<pre><code>class IsCommutative ( }\alpha\mathrm{ : Type) (f : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ ) where
    comm : \Ya b, f a b = f b a
class IsAssociative ( }\alpha\mathrm{ : Type) (f : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ ) where
    assoc : \Ya b c, f(f a b) c = f a(f b c)
</code></pre>

<p>在3.6节中，我们遇到了以下语义类型类：</p>


<p>这次关联并非从类型到常量，而是从类型和函数到属性。Lean并不介意这种用法：尽管它们被称为类型类，但Lean的类型类非常灵活，可用于表达各种约束条件。</p>


<p>从概念上讲，IsCommutative 是一个依赖于三元组(<span class="math">\(\alpha, f\)</span>, comm)的依赖类型，IsAssociative同理。<span class="math">\(f\)</span>的类型取决于<span class="math">\(\alpha\)</span>，而comm的类型则取决于<span class="math">\(\alpha\)</span>和<span class="math">\(f\)</span>。尽管它们都是参数，<span class="math">\(\alpha\)</span>和<span class="math">\(f\)</span>也会与comm一同存储。</p>

<pre><code>instance Associative_add : Std.Associative add :=
    { assoc := add_assoc }
instance Commutative_add : Std.Commutative add :=
    { comm := add_comm }
</code></pre>

<p>在3.6节中，我们将<span class="math">\(\mathbb{N}\)</span>上的加法函数注册为可交换且可结合的运算：</p>


<p>每当我们尝试访问@IsCommutative.comm <span class="math">\(\mathbb{N}\)</span> add时，就会得到add_comm；同理，对于@IsAssociative.assoc <span class="math">\(\mathbb{N}\)</span> add也是如此。ac_rfl策略会尝试查找问题中所有二元运算符的交换律(comm)和结合律(assoc)属性，并在这些属性存在时加以利用。</p>

<pre><code>class class-name (params_{1}: type_{1})...(params_{k}: type_{k})
    [extends structure
    constant-name : constant-type
    \vdots
    constant-name: : constant-type,
    property-name : proposition
    \vdots
    property-name : proposition
</code></pre>

<p>定义类型类的通用语法如下：</p>

<pre><code>instance instance-name : type-class arguments :=
    { constant : = definition
        \vdots
    constant <span class="math">\(_{n}:=\)</span> definition <span class="math">\(_{n}\)</span>
    property <span class="math">\(_{1}:=\operatorname{proof}_{1}\)</span>,
        \vdots
    property <span class="math">\(_{p}:=\operatorname{proof}_{p}\)</span>
</code></pre>
<p>实例化类型类的通用语法如下：</p>

<h3>5.7 列表</h3>
<p>Lean为有限列表提供了丰富的函数库。本节我们将回顾其中部分函数，并自行定义一些函数；这些练习能帮助我们熟悉Lean中的函数式编程。</p>

<pre><code>theorem head_head_cases { <span class="math">\(\alpha\)</span> : Type \} [Inhabited <span class="math">\(\alpha]\)</span>
    (xs : List <span class="math">\(\alpha\)</span> ) :
    head [head xs] = head xs :=
    by
    cases xs with
    | nil =&gt; rfl
    | cons x xs' =&gt; rfl
</code></pre>
<p>在第一个示例中，我们对列表进行了情况分析：</p>

<p>该证明采用分情形法，这是归纳法的近亲。它对参数进行情形区分但不生成归纳假设。调用cases xs将目标<span class="math">\(\vdash \mathrm{P}[\mathrm{xs}]\)</span>转化为两个子目标：<span class="math">\(\vdash \mathrm{P}[[]]\)</span>和<span class="math">\(\vdash \mathrm{P}\left[\mathrm{x}::\right.\)</span> xs']。我们本也可以使用induction xs。若在归纳法与分情形法间犹豫不决，可优先选择归纳法，随后观察是否需要归纳假设——若最终未使用归纳假设，最佳实践是通过将induction替换为cases来记录这一事实。</p>

<pre><code>theorem head_head_match <span class="math">\(\{\alpha\)</span> : Type \} [Inhabited <span class="math">\(\alpha]\)</span>
    (xs : List <span class="math">\(\alpha\)</span> ) :
    head [head xs] = head xs :=
match xs with
| List.nil <span class="math">\(\quad=&gt;\)</span> by rfl
| List.cons x xs' =&gt; by rfl
</code></pre>

<p>在结构化证明中，我们可以使用匹配表达式来进行情况区分：</p>

<pre><code>theorem injection_example <span class="math">\(\{\alpha\)</span> : Type \} (x y : <span class="math">\(\alpha\)</span> ) (xs ys : List <span class="math">\(\alpha\)</span> )
        <span class="math">\((h: x:: x s=y:: y s):\)</span>
    <span class="math">\(x=y \wedge x s=y s:=\)</span>
    by
    cases <span class="math">\(h\)</span>
    simp
</code></pre>

<p>在下一个示例中，我们将展示如何利用构造子的单射性。cases策略通过单射性来简化两边应用了相同构造子的等式。在下面的证明中，简化前的等式是<span class="math">\(x:: x s=y:: y s:\)</span></p>

<div class="math">$$
\vdash x=x \wedge x s=x s
$$</div>

<p>cases策略将目标中的<span class="math">\(y\)</span>替换为<span class="math">\(x\)</span>，并将<span class="math">\(y s\)</span>替换为<span class="math">\(x s\)</span>，从而生成子目标</p>

<pre><code>theorem distinctness_example <span class="math">\(\{\alpha\)</span> : Type \} (y : <span class="math">\(\alpha\)</span> ) (ys : List <span class="math">\(\alpha\)</span> )
        <span class="math">\((h:[]=y::\)</span> ys) :
        False :=
    by cases <span class="math">\(h\)</span>
</code></pre>

<p>这一子目标simp策略可以轻松证明。当构造函数不同时，cases策略同样适用于检测不可能出现的情况：</p>

<pre><code>def map { <span class="math">\(\alpha \beta\)</span> : Type \} (f : <span class="math">\(\alpha \rightarrow \beta)\)</span> : List <span class="math">\(\alpha \rightarrow\)</span> List <span class="math">\(\beta\)</span>
    | [] <span class="math">\(\quad=&gt;[]\)</span>
    | x :: xs =&gt; f x :: map f xs
</code></pre>

<p>接下来，我们定义列表的映射函数：该函数将其参数f（本身也是一个函数）应用于存储在集合中的所有元素。</p>

<pre><code>def mapArgs { <span class="math">\(\alpha \beta\)</span> : Type \} : <span class="math">\((\alpha \rightarrow \beta) \rightarrow\)</span> List <span class="math">\(\alpha \rightarrow\)</span> List <span class="math">\(\beta\)</span>
    | _, [] <span class="math">\(\quad=&gt;[]\)</span>
    | f, x :: xs =&gt; f x :: mapArgs f xs
</code></pre>
<p>注意由于<span class="math">\(f\)</span>在递归调用中保持不变，我们将其作为整个定义的参数传入。另一种处理方式（这是对递归调用中变化参数唯一可行的方案）如下所示：</p>
<pre><code>theorem map_ident <span class="math">\(\{\alpha\)</span> : Type \} (xs : List <span class="math">\(\alpha\)</span> ) :
    map (fun <span class="math">\(x \mapsto x) x s=x s:=\)</span>
    by
    induction xs with
    | nil =&gt; rfl
    | cons x xs' ih =&gt; simp [map, ih]
</code></pre>

<p>映射函数的一个基本性质是：当参数为恒等函数（fun <span class="math">\(x \mapsto x\)</span>）时，它们不会产生任何效果：</p>

<pre><code>theorem map_comp <span class="math">\(\{\alpha \beta \gamma\)</span> : Type \} (f : <span class="math">\(\alpha \rightarrow \beta\)</span> ) (g : <span class="math">\(\beta \rightarrow \gamma\)</span> )
        (xs : List <span class="math">\(\alpha\)</span> ) :
    map g (map f xs) = map (fun <span class="math">\(x \mapsto g(f x)) x s:=\)</span>
    by
        induction xs with
    | nil =&gt; rfl
    | cons x xs' ih =&gt; simp [map, ih]
</code></pre>

<p>另一个基本特性是连续的映射操作可以被压缩为单一映射，其参数是所涉及函数的组合：</p>

<pre><code>theorem map_append <span class="math">\(\{\alpha \beta\)</span> : Type \} (f : <span class="math">\(\alpha \rightarrow \beta\)</span> )
            (xs ys : List <span class="math">\(\alpha\)</span> ) :
    map f (xs ++ ys) = map f xs ++ map f ys :=
    by
        induction xs with
    | nil =&gt; rfl
    | cons x xs' ih =&gt; simp [map, ih]
</code></pre>

<p>在引入新运算时，展示这些运算与其他运算结合使用时的行为十分有用。示例如下：</p>

<p>值得注意的是，最后三个证明在文本上完全相同。这些都是典型的归纳-rfl-simp式证明。</p>
<pre><code>def tail <span class="math">\(\{\alpha\)</span> : Type \} : List <span class="math">\(\alpha \rightarrow\)</span> List <span class="math">\(\alpha\)</span>
    | [] <span class="math">\(\quad=&gt;[]\)</span>
    | _ :: xs =&gt; xs
</code></pre>
<p>下一个列表操作是移除列表的首个元素，返回剩余部分：</p>
<pre><code>def headOpt <span class="math">\(\{\alpha\)</span> : Type \} : List <span class="math">\(\alpha \rightarrow\)</span> Option <span class="math">\(\alpha\)</span>
    | [] <span class="math">\(\quad=&gt;\)</span> Option. none
    | x :: _ =&gt; Option. some x
</code></pre>

<p>对于空列表[ ]，我们直接返回[ ]作为其自身的尾部。与tail对应的函数是提取列表首元素的函数。我们已在5.6节通过Inhabited类型类讨论过一种解决方案。另一种可能的定义使用Option包装器：</p>

<pre><code>match headOpt xs with
    | Option.none =&gt; handleTheError
    | Option.some x =&gt; doSomethingWithValue x
</code></pre>

<p>类型 Option <span class="math">\(\alpha\)</span> 有两个构造子：Option.none 和 Option.some a，其中 a : <span class="math">\(\alpha\)</span>。当没有有意义的值可返回时我们使用 Option.none，否则使用 Option.some。我们可以将 Option.none 视为函数式编程中的空指针，但与空指针（及空引用）不同，类型系统会防止不安全的解引用操作。要获取存储在 option 中的值，我们必须进行模式匹配。示意如下：</p>


<p>我们不能直接写成doSomethingWithValue (headOpt xs)，因为这在类型上是错误的。类型系统迫使我们必须考虑错误处理。</p>

<pre><code>def headPre { }\alpha\mathrm{ : Type} : (xs : List }\alpha)\rightarrowxs\neq[]\rightarrow\alpha
    | [], hxs =&gt; by simp at *
    | x :: _, hxs =&gt; x
</code></pre>

<p>借助依赖类型的力量，我们还有另一种实现部分函数的方法——即可以指定一个前置条件。调用者必须随后传递一个证明该前置条件满足的参数：</p>


<p>headPre函数接收两个显式参数。第一个参数xs是一个列表，第二个参数<span class="math">\(h x s\)</span>是<span class="math">\(x s \neq[]\)</span>的证明。由于第二个参数的类型<span class="math">\(x s \neq[]\)</span>依赖于第一个参数，我们必须使用依赖类型语法(xs : List <span class="math">\(\alpha\)</span> ) <span class="math">\(\rightarrow\)</span>而非List <span class="math">\(\alpha \rightarrow\)</span>，以便命名第一个参数。函数返回类型为<span class="math">\(\alpha\)</span>的值；得益于前置条件，这里不需要Option包装器。</p>


<p>第二个参数用于排除xs为[]的情况。在这种情况下，参数（称为hxs）是[] <span class="math">\(\neq[]\)</span>的证明，这是不可能的。该证明推导出一个矛盾并利用它来生成任意<span class="math">\(\alpha\)</span>。从矛盾出发，我们可以推导出任何命题，甚至是<span class="math">\(\alpha\)</span>的实例。</p>

<pre><code>\#eval headPre [3, 1, 4] (by simp)
</code></pre>

<p>我们可以按如下方式调用该函数：</p>

<pre><code>def zip { }\alpha\beta\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; List }\beta\mathrm{ -&gt; List ( }\alpha\times\beta\mathrm{ )
    | x :: xs, y :: ys =&gt; (x, y) :: zip xs ys
    | [], _ =&gt; []
    | _ :: _, [] =&gt; []
</code></pre>

<p>这将打印出3。第二个参数通过simp证明[3, 1, 4]不是空列表[]。现在，给定两个长度相同的列表<span class="math">\(\left[x_{1}, \ldots, x_{n}\right]\)</span>和<span class="math">\(\left[y_{1}, \ldots, y_{n}\right]\)</span>，zip操作会构造一个由配对组成的列表<span class="math">\(\left[\left(x_{1}, y_{1}\right), \ldots,\left(x_{n}, y_{n}\right)\right]\)</span>：</p>


<p>该函数在其中一个列表比另一个短时也有定义。例如，zip <span class="math">\([a, b, c][x, y]=[(a, x),(b, y)]\)</span>。请注意，这个递归包含三种情况，偏离了结构递归模式。</p>

<pre><code>def length { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; N
    | [] =&gt; 0
    | x :: xs =&gt; length xs + 1
</code></pre>

<p>列表的长度通过递归定义：</p>

<pre><code>theorem length_zip { }\alpha\beta\mathrm{ : Type} (xs : List }\alpha\mathrm{ ) (ys : List }\beta\mathrm{ ):
    length (zip xs ys) = min (length xs) (length ys) :=
    by
    induction xs generalizing ys with
    | nil =&gt; simp [min, length]
    | cons x xs' ih =&gt;
    cases ys with
    | nil =&gt; rfl
    | cons y ys' =&gt; simp [zip, length, ih ys', min_add_add]
</code></pre>
<p>关于zip操作结果的长度，我们可以得出一个有趣的结论——它等于两个输入列表长度的最小值：</p>
<div class="math">$$
\text { ih : } \forall \text { ys : list } \beta \text {, length (zip xs ys) = min (length xs) (length ys) }
$$</div>

<p>上述证明还教会了我们另一个技巧。这里的归纳假设是</p>


<p>为什么会出现<span class="math">\(\forall\)</span>量词？归纳策略中的"xs generalizing ys"将定理陈述泛化，使得归纳假设不再局限于证明目标中某个固定的ys，而是可以用于任意的ys值。这种灵活性在此是必要的，因为我们希望用ys的尾部（称为ys'）而非ys本身来实例化该量词。</p>

<pre><code>theorem min_add_add (l m n : N) :
    min (m + l) (n + l) = min m n + l :=
    by
        cases Classical.em (m \leq n) with
        | inl h =&gt; simp [min, h]
        | inr h =&gt; simp [min, h]
</code></pre>

<p>该证明依赖于一个关于min函数的定理，我们需要自行证明该定理：</p>


<p>回顾min函数的定义：min a b = (若 a <span class="math">\(\leq\)</span> b 则取 a 否则取 b)。为推理min函数，我们通常需要对条件<span class="math">\(a \leq b\)</span>进行情形划分。这通过调用cases Classical.em(<span class="math">\(a \leq b\)</span>)实现，该方法会生成两个子目标：一个以<span class="math">\(a \leq b\)</span>作为假设，另一个以<span class="math">\(\neg a \leq b\)</span>作为假设。在各情形中，该假设均以<span class="math">\(h\)</span>的形式存在。</p>

<pre><code>theorem min_add_add_match (l m n : N) :
    min (m + l) (n + l) = min m n + l :=
    match Classical.em (m \leq n) with
    | Or.inl h =&gt; by simp [min, h]
    | Or.inr h =&gt; by simp [min, h]
theorem min_add_add_if (l m n : N) :
    min (m + l) (n + l) = min m n + l :=
    if h : m \leq n then
        by simp [min, h]
    else
        by simp [min, h]
</code></pre>

<p>在结构化证明中，有两种方法可以对命题进行情形区分：</p>

<table>
<thead>
<tr>
  <th style="text-align:left">Tactical proof</th>
  <th style="text-align:left">Structured proof</th>
  <th style="text-align:left">Raw proof term</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">cases t</td>
  <td style="text-align:left">match t with</td>
  <td style="text-align:left">match t with</td>
</tr>
<tr>
  <td style="text-align:left">cases Classical.em Q</td>
  <td style="text-align:left">if Q then...else</td>
  <td style="text-align:left">if Q then...else</td>
</tr>
</tbody>
</table>

<p>我们再次看到，用于编写函数式程序的机制（如模式匹配和if-then-else条件语句）同样适用于编写结构化证明（毕竟这些证明本质上也是项）。现在我们可以向4.7节末尾的表格中添加几行内容：</p>

<pre><code>theorem map_zip <span class="math">\(\left\{\alpha \alpha^{\prime} \beta \beta^{\prime}: \text { Type }\right\}\left(f: \alpha \rightarrow \alpha^{\prime}\right)\)</span>
    <span class="math">\((g: \beta \rightarrow \beta')\)</span> :
    <span class="math">\(\forall x s\)</span> ys,
        map (fun ab : <span class="math">\(\alpha \times \beta \mapsto\)</span>
            (f (Prod.fst ab), g (Prod.snd ab)))
            (zip xs ys) <span class="math">\(=\)</span>

        zip (map f xs) (map g ys)
| x :: xs, y :: ys =&gt; by simp [zip, map, map_zip f g xs ys]
| [], —_ =&gt; by rfl
| _ :: _, [] =&gt; by rfl
</code></pre>
<p>我们最后给出关于map和zip的分配律，该定律通过使用Prod.fst和Prod.snd这对选择器来表达：</p>

<p>左侧的模式与zip定义中使用的模式完全对应。这比我们证明length_zip时分别对xs进行归纳和对ys进行案例分析更简洁。优秀的证明通常遵循其所基于的定义结构。</p>

<pre><code>def f { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow \cdots
    | [] =&gt; ...
    | xs =&gt; ... xs ...
</code></pre>
<p>在zip函数的定义和map_zip的证明中，我们特意指定了三个互不重叠的模式。当然也可以编写具有重叠模式的等式，例如</p>
<pre><code>def f { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow \cdots
    | [] =&gt; ...
    | x :: xs =&gt; ... (x :: xs) ...
</code></pre>

<p>由于模式是按顺序应用的，上述命令定义了与以下相同的函数</p>

<p>我们通常推荐后者这种更显式的风格，因为它带来的意外情况更少。</p>
<pre><code>inductive Tree ( }\alpha\mathrm{ : Type) : Type
    | nil : Tree }\alpha
    | node : }\alpha\mathrm{ \rightarrow Tree }\alpha\mathrm{ \rightarrow Tree }\alpha\mathrm{ \rightarrow Tree }\alpha
</code></pre>

<h3>5.8 二叉树</h3>
<p>带有多个递归参数的构造函数的归纳类型定义了树状对象。二叉树的节点最多有两个子节点。Lean对二叉树的定义如下：</p>

<div class="math">$$
\begin{gathered}
\vdash P[\text { Tree.nil }] \\
\mathrm{a}: \alpha, 1 \mathrm{r}: \text { Tree } \alpha, \text { ih_l }: \mathrm{P}, \text { ih_r }: \mathrm{P}[\mathrm{r}] \vdash \mathrm{P}[\text { Tree.node a } 1 \mathrm{r}]
\end{gathered}
$$</div>

<p>对于二叉树，结构归纳法会生成两个归纳假设，分别对应内部节点的每个子树。要通过结构归纳法证明目标<span class="math">\(t\)</span> : Tree <span class="math">\(\alpha \vdash P[t]\)</span>，我们需要展示以下子目标：</p>

<pre><code>def mirror { }\alpha\mathrm{ : Type} : Tree }\alpha\mathrm{ \rightarrow Tree }\alpha
    | Tree.nil =&gt; Tree.nil
    | Tree.node a l r =&gt; Tree.node a (mirror r) (mirror l)
</code></pre>

<p>与列表反转对应的树操作是镜像操作：</p>

<pre><code>theorem mirror_mirror { }\alpha\mathrm{ : Type} (t : Tree }\alpha\mathrm{ ):
    mirror (mirror t) = t :=
    by
        induction t with
        | nil =&gt; rfl
        | node a l r ih_l ih_r =&gt; simp [mirror, ih_l, ih_r]
</code></pre>
<p>镜像操作可以直接定义，而无需依赖某种追加操作。因此，如我们下文所见，对镜像的推理比对反转的推理更为简单：</p>
<div class="math">$$
(\text { ih_l) mirror (mirror l) }=1 \quad(\text { ih_r) mirror (mirror r) }=r
$$</div>

<p>更详细的非形式化证明如下：该证明基于对<span class="math">\(t\)</span>的结构归纳法。情形Tree.nil：需要证明mirror (mirror Tree.nil) = Tree.nil。这直接由mirror的定义可得。情形Tree.node a l r：归纳假设为</p>

<pre><code>    mirror (mirror (Tree.node a l r))
= mirror (Tree.node a (mirror r) (mirror l)) (by def. of mirror)
= Tree.node a (mirror (mirror l)) (mirror (mirror r)) (ditto)
= Tree.node a l (mirror (mirror r)) (by ih_l)
= Tree.node a l r
</code></pre>
<p>我们需要证明 mirror (mirror (Tree.node a l r)) = Tree.node a l r。根据定义可得</p>
<pre><code>theorem mirror_mirror_calc { }\alpha\mathrm{ : Type} :
    \forallt : Tree }\alpha\mathrm{ , mirror (mirror t) = t
| Tree.nil =&gt; by rfl
| Tree.node a l r =&gt;
    calc
        mirror (mirror (Tree.node a l r))
        = mirror (Tree.node a (mirror r) (mirror l)) :=
            by rfl
            _ = Tree.node a (mirror (mirror l))
            (mirror (mirror r)) :=
            by rfl
            _ = Tree.node a l (mirror (mirror r)) :=
            by rw [mirror_mirror_calc l]
            _ = Tree.node a l r :=
            by rw [mirror_mirror_calc r]
</code></pre>
<p>要在Lean证明中实现同等细节程度，我们可以使用计算块（第4.4节）而非simp：</p>
<pre><code>theorem mirror_Eq_nil_Iff { }\alpha\mathrm{ : Type} :
    \forallt : Tree }\alpha\mathrm{ , mirror t = Tree.nil }\leftrightarrow\mathrm{t}=\text { Tree.nil
| Tree.nil =&gt; by simp [mirror]
| Tree.node _ _ =&gt; by simp [mirror]
</code></pre>
<p>我们以以下定理作为总结，该定理将在第六章中发挥作用：</p>
<pre><code>cases term [with
| constructor, names, =&gt; tactics
    \vdots
    | constructor, names, =&gt; tactics
</code></pre>
<pre><code>cases hypothesis-of-the-form-1-equals-r
</code></pre>

<h3>5.9 分情形策略</h3>
<h4>cases</h4>
<p>cases策略对指定项进行情形划分，根据该项类型定义中的构造子数量生成相应子目标。该策略与induction类似，但不会生成归纳假设且自动排除不可能的情形。可选名称names<span class="math">\(_{1}, \ldots\)</span>, names<span class="math">\(_{n}\)</span>用于命名新出现的变量或假设。</p>

<pre><code>cases Classical.em (proposition) with
| inl name-if-true =&gt; tactics-if-true
| inr name-if-false =&gt; tactics-if-false
</code></pre>

<p>cases策略也可用于形式为<span class="math">\(1=r\)</span>的假设<span class="math">\(h\)</span>。该策略会将<span class="math">\(r\)</span>与1进行匹配，并将目标中所有出现的<span class="math">\(r\)</span>变量替换为1中对应的项。剩余的假设<span class="math">\(1=1\)</span>可通过clear h指令移除（如需）。</p>

<p>cases策略同样可用于对命题进行情形分析。此时会产生两种情形：一种命题为真，另一种命题为假。可选参数name-if-true和name-if-false分别用于命名真情形和假情形中的假设。</p>
<pre><code>inductive Vec ( }\alpha\mathrm{ : Type) : N -&gt; Type where
    | nil : Vec }\alpha\mathrm{ \emptyset
    | cons (a : \alpha) {n : N}(v : Vec \alpha n): Vec \alpha(n+1)
</code></pre>

<h3>5.10 依赖归纳类型</h3>
<p>List <span class="math">\(\alpha\)</span> 和 Tree <span class="math">\(\alpha\)</span> 这类归纳类型属于 Lean 的简单类型片段。归纳类型也可以依赖于（非类型的）项。一个典型例子是长度为 <span class="math">\(n\)</span> 的列表类型，或称向量：</p>


<p>因此，项 Vec.cons 3 (Vec.cons 1 Vec.nil) 的类型为 Vec <span class="math">\(\mathbb{N}_{2}\)</span>。通过在类型中编码向量长度，我们可以提供关于函数结果的更精确信息。像 Vec.reverse 这样的函数（用于反转向量）会将值 <span class="math">\(\operatorname{Vec} \alpha n\)</span> 映射为另一个相同类型的值，且保持相同的 <span class="math">\(n\)</span>。而 Vec.zip 可能要求其两个参数具有相同长度。固定长度的向量和矩阵在计算机科学和数学中非常有用。</p>


<p>遗憾的是，这种更精确的信息是以代价换取的。当依赖归纳类型所依赖的项在可证明相等但计算上不满足语法等价时（例如<span class="math">\(m+n\)</span>与<span class="math">\(n+m\)</span>），会导致处理困难。本指南通常会避免使用依赖归纳类型，本节仅为完整性对其简要说明。明确强调：这部分不属于考试范围。</p>

<pre><code>def listOfVec { }\alpha\mathrm{ : Type} : V{n:N}, Vec \alpha n \rightarrow List \alpha
    | _, Vec.nil =&gt; []
    | _, Vec.cons a v =&gt; a :: listOfVec v
def vecOfList { }\alpha\mathrm{ : Type} :
    Vxs : List }\alpha\mathrm{ , Vec }\alpha\mathrm{ (List.length xs)
    | [] =&gt; Vec.nil
    | x :: xs =&gt; Vec.cons x (vecOfList xs)
</code></pre>
<p>以下定义介绍了列表与向量之间的转换：</p>

<p>listOfVec转换函数接受一个类型<span class="math">\(\alpha\)</span>、一个长度<span class="math">\(n\)</span>以及一个基于<span class="math">\(\alpha\)</span>的长度为<span class="math">\(n\)</span>的向量作为参数，并返回一个基于<span class="math">\(\alpha\)</span>的列表。虽然我们不关心长度<span class="math">\(n\)</span>的具体值，但由于它出现在第三个参数的类型中，仍需将其作为参数。我们将前两个参数<span class="math">\(\alpha\)</span>和<span class="math">\(n\)</span>设为隐式参数，因为它们可以从第三个参数的类型中推断得出。</p>


<p>vecOfList转换函数接收一个类型<span class="math">\(\alpha\)</span>和一个基于<span class="math">\(\alpha\)</span>的列表作为参数，并返回一个与列表长度相同的向量。Lean的类型检查器足够强大，可以确定这两个右侧表达式具有所需的类型。</p>

<pre><code>theorem length_listOfVec { }\alpha\mathrm{ : Type} :
    V(n : N)(v : Vec }\alpha\mathrm{n}), List.length (listOfVec v) = n
    | _, Vec.nil =&gt; by rfl
    | _, Vec.cons a v =&gt;
    by simp [listOfVec, length_listOfVec _ v]
</code></pre>

<p>根据PAT原理，证明过程类似于函数定义。让我们验证将向量转换为列表时能保持其长度不变：</p>

<div class="math">$$
\begin{gathered}
\vdash P[\text { Vec.nil }] \\
m: \mathbb{N}, a: \alpha, u: \operatorname{Vec} \alpha m, i h: P[u] \vdash P[\text { Vec. cons } a u]
\end{gathered}
$$</div>

<p>为了通过结构归纳法证明目标<span class="math">\(v: \operatorname{Vec} \alpha n \vdash P[v]\)</span>，我们可能天真地认为只需证明以下两个子目标即可：</p>

<div class="math">$$
\begin{gathered}
\vdash P_{\theta}[\text { Vec.nil }] \\
m: \mathbb{N}, a: \alpha, u: \operatorname{Vec} \alpha m, i h: P_{\theta}[u] \vdash P_{m+1}[\operatorname{Vec} \text {. cons } a u]
\end{gathered}
$$</div>

<p>这种想法是幼稚的，因为子目标甚至类型不正确：P[ ]中的空缺具有类型Vec <span class="math">\(\alpha n\)</span>（即其原始占位符<span class="math">\(v\)</span>的类型），因此我们不能简单地填入Vec.nil、<span class="math">\(u\)</span>或Vec.cons a <span class="math">\(u\)</span>——它们分别具有类型Vec <span class="math">\(\alpha \theta\)</span>、Vec <span class="math">\(\alpha m\)</span>和<span class="math">\(\operatorname{Vec} \alpha(m+1)\)</span>。每次我们都必须调整<span class="math">\(P\)</span>，将<span class="math">\(n\)</span>替换为<span class="math">\(\theta, m\)</span>或<span class="math">\(m+1\)</span>。使用符号<span class="math">\(P_{t}[\)</span> ]表示将<span class="math">\(P[]\)</span>中所有<span class="math">\(n\)</span>替换为项<span class="math">\(t\)</span>的变体，我们得到</p>


<p>使用cases策略进行分情况证明的过程类似，但不包含归纳假设。通常，长度<span class="math">\(n\)</span>并非变量而是复杂项。此时在<span class="math">\(P[]\)</span>中替换<span class="math">\(n\)</span>可能缺乏直观意义。使用cases策略时，对应的子目标会被静默消除。因此，对类型为<span class="math">\(\operatorname{Vec} \alpha \theta\)</span>的值进行情况区分时，由于<span class="math">\(\theta\)</span>永远不可能等于<span class="math">\(m+1\)</span>形式的项，只会产生一个形如<span class="math">\(\vdash P[\)</span> Vec.nil]的子目标。</p>

<pre><code>match v with
| Vec.nil =&gt; ...
| Vec.cons a u =&gt; ...
</code></pre>
<p>依赖类型的模式匹配颇为微妙，因为待匹配值的类型可能随构造器而变化。给定<span class="math">\(v: \operatorname{Vec} \alpha n\)</span>时，我们可能会试图编写</p>
<pre><code>match n, v with
| 0, Vec.nil =&gt; ...
| m + 1, Vec.cons a u =&gt; ...
</code></pre>

<p>但这与我们之前首次尝试的归纳证明同样天真。由于类型<span class="math">\(\operatorname{Vec} \alpha n\)</span>中的项<span class="math">\(n\)</span>可能随构造器而变化，我们必须同时对<span class="math">\(n\)</span>进行模式匹配：</p>

<pre><code>match n, v with
| 0, @Vec.nil }\alpha\mathrm{ =&gt; ...
| m + 1, @Vec.cons }\alpha\mathrm{ a m u =&gt; ...
</code></pre>

<p>展示隐式参数后，我们得到</p>

<pre><code>match n, v with
| _, Vec.nil =&gt; ...
| _, Vec.cons a u =&gt; ...
</code></pre>

<p>通常，在第一列放置占位符就足够了：</p>


<p>虽然对<span class="math">\(n\)</span>进行模式匹配却忽略结果看似矛盾，但若不这样做，Lean就无法推断Vec.cons的第二个隐式参数。在这方面，cases比match更用户友好。</p>


<h3>5.11 新引入的Lean结构摘要</h3>
<h4>声明</h4>
<p>class
instance
structure
将结构类型声明为类型类
将结构值声明为类型类实例
引入结构类型及其选择器</p>


<h4>表达式</h4>
<p>if... then... else 对可判定命题进行条件分支
match... with 执行模式匹配</p>


<h4>策略</h4>
<p>cases
执行情况分析</p>


<h2>第六章：归纳谓词</h2>
<p>归纳谓词，或称归纳定义的命题，是规范类型为<span class="math">\(\cdots \rightarrow\)</span> Prop函数的一种便捷方式。它们让人联想到形式系统（第1.3节）和Prolog风格的逻辑编程。但Lean的表达能力远超Prolog，因此我们需要通过一些工作来建立定理，而不仅仅是运行Prolog解释器。对Lean的一种可能看法是：</p>

<p>Lean <span class="math">\(=\)</span> 函数式编程 + 逻辑编程 + 更多逻辑</p>

<h3>6.1 入门示例</h3>
<p>除非您接触过Prolog或逻辑编程，否则可能会疑惑归纳谓词是什么以及为何有用。我们首先回顾三个展示其多样用途的示例：偶数、网球比赛及自反传递闭包。</p>


<h3>6.1.1 偶数</h3>
<p>数学家常将特定集合定义为满足某些条件的最小集合。考虑以下定义：</p>


<p>偶数自然数集<span class="math">\(E\)</span>被定义为满足以下规则的最小闭集<span class="math">\(S\)</span>：
(1) <span class="math">\(0 \in S\)</span>；
(2) 对于任意<span class="math">\(k \in \mathbb{N}\)</span>，若<span class="math">\(k \in S\)</span>，则<span class="math">\(k+2 \in S\)</span>。</p>


<p>根据Knaster-Tarski定理，这样的集合存在。（最后一句话通常被隐去不言。）我们很容易确信<span class="math">\(E\)</span>包含且仅包含所有偶数。现在让我们戴上数学家的帽子，证明4是偶数：</p>

<div class="math">$$
\underset{0 \in E}{-} \text { ZERO } \quad \frac{h \in E}{h+2 \in E} \text { ADDtwo }{ }_{R}
$$</div>
<p>根据规则(1)，我们有<span class="math">\(0 \in E\)</span>。因此，通过规则(2)（令<span class="math">\(k:=0\)</span>），可得<span class="math">\(2 \in E\)</span>。同理，应用规则(2)（令<span class="math">\(k:=2\)</span>）可证<span class="math">\(4 \in E\)</span>，得证。相比之下，计算机科学家可能会使用由两条推导规则组成的形式系统来定义同一集合：</p>
<div class="math">$$
\frac{\frac{0 \in E}{-} \text { ZERO }}{2 \in E} \text { ADDTwo }{ }_{0}
$$</div>

<p>此时证明就是一个推导树：</p>

<pre><code>inductive Even : <span class="math">\(\mathbb{N} \rightarrow\)</span> Prop where
    | zero : Even \0
    | add_two : Yk : N, Even k <span class="math">\(\rightarrow\)</span> Even (k + 2)
</code></pre>

<p>当我们自上而下阅读时，该证明是正向的；而自下而上阅读时则是反向的。归纳谓词是逻辑学家实现相同效果的方式。在Lean中，我们会通过归纳方式定义一个特征谓词，而非集合：</p>

<p>这看起来应该很熟悉。我们使用了相同的语法，只不过是用Type替代了Prop，来定义归纳类型。在Lean中，归纳类型和归纳谓词由同一机制提供，符合PAT原则。</p>

<p>上述命令定义了一个一元谓词Even（偶数）以及两个引入规则Even.zero和Even.add_two，这些规则可用于证明形如<span class="math">\(\vdash\)</span> Even...的目标。回想一下，符号（例如Even）的引入规则是指结论包含该符号的定理（见第4.3节）。根据PAT原理，Even n可视为类似Vec <span class="math">\(\propto \mathrm{n}\)</span>（见第5.10节）的依赖归纳类型，而Even.zero和Even.add_two则可视为类似Vec.nil和Vec.cons的构造子。</p>

<p>若将Lean定义转译回英语表述，我们会得到与上述Knaster-Tarski式定义相似的结构：</p>

<p>以下条款定义了偶数：
(1) <span class="math">\(\varnothing\)</span> 是偶数；
(2) 任何形如 <span class="math">\(k+2\)</span> 的数字都是偶数，前提是 <span class="math">\(k\)</span> 为偶数。</p>


<p>其他任何数字都不是偶数。值得注意的是，归纳定义的符号没有具体定义。因此，我们无法使用simp展开其定义。唯一可用的推理原则是引入规则和消去规则。</p>

<pre><code>theorem Even_4 :
    Even 4 :=
have Even_0 : Even 0 :=
    Even.zero
have Even_2 : Even 2 :=
    Even.add_two _ Even_0
show Even 4 from
    Even.add_two _ Even_2
</code></pre>

<p>作为热身练习，这里给出Even 4的证明：</p>


<p>例如，证明项Even.add_two _ Even_0的类型为Even (0 + 2)，该类型在计算后与Even 2语法等价，因此从类型检查器的角度来看是相等的。下划线代表0。</p>

<p>得益于归纳定义的"无冗余"保证，Even.zero和Even.add_two是构造<span class="math">\(\vdash\)</span> Even ...证明的唯二方式。通过检查结论Even 0和Even (<span class="math">\(k+2\)</span> )，我们可以确认不存在证明1为偶数的可能性。</p>
<pre><code>opaque Even : N -&gt; Prop
axiom Even. zero : Even 0
axiom Even.add_two : VK : N, Even k -&gt; Even (k + 2)
</code></pre>

<p>另一种理解上述归纳定义的方式如下：第一行引入了一个谓词，而第二行和第三行则引入了我们希望该谓词满足的公理。因此，我们本可以这样书写：</p>


<p>将"inductive"替换为"opaque"、"|"替换为"axiom"即可。但这种公理化版本并未提供关于Even何时为假的信息。我们无法用它来证明<span class="math">\(\neg\)</span> Even 1或<span class="math">\(\neg\)</span> Even 17。就我们所知，Even可能对所有自然数都为真。相比之下，归纳定义保证了我们获得的是满足引入规则Even.zero和Even.add_two的最小（即最假）谓词，并提供了消去和归纳原则，使我们能够证明<span class="math">\(\neg\)</span> Even 1、<span class="math">\(\neg\)</span> Even 17或<span class="math">\(\neg\)</span> Even <span class="math">\((2+n+1)\)</span>。</p>

<pre><code>def evenRec : N -&gt; Bool
    | 0 =&gt; true
    | 1 =&gt; false
    | k + 2 =&gt; evenRec k
</code></pre>
<p>既然可以定义递归函数，我们为何还要费心使用归纳谓词？事实上，以下定义完全合理：</p>

<p>每种风格各有优劣。递归版本强制我们指定否定情形（第二个等式），并要求考虑终止性问题。但正因其基于等式计算，它能与rfl、simp、#eval和#reduce良好协作。归纳版本则更具抽象性与优雅性，每条引入规则都可独立陈述，增删规则时无需考虑终止性或可执行性问题。</p>

<pre><code>def evenNonrec (k : N) : Prop :=
    k % 2 = 0
</code></pre>
<p>定义偶数的另一种方式是非递归定义，使用取模运算符（%）：</p>

<p>数学家们可能更青睐这个版本。但归纳版本是个便利的"Hello, World!"示例，它类似于许多现实的归纳定义。虽然这或许是个玩具模型，却是个有用的玩具模型。</p>


<h4>6.1.2 网球比赛</h4>
<p>迁移系统由连接"前"与"后"状态的迁移规则构成。作为迁移系统的范例，我们考察网球比赛中从0-0（"零比零"）开始的可能状态迁移。网球比赛同样是个简化模型，但在第9章中，我们将以类似风格将命令式编程语言的语义定义为迁移系统。</p>


<p>以下摘录自国际网球联合会《网球规则》中的网球计分规则。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">No point</th>
  <th style="text-align:left">- "Love"</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">First point</td>
  <td style="text-align:left">- "15"</td>
</tr>
<tr>
  <td style="text-align:left">Second point</td>
  <td style="text-align:left">- "30"</td>
</tr>
<tr>
  <td style="text-align:left">Third point</td>
  <td style="text-align:left">- "40"</td>
</tr>
<tr>
  <td style="text-align:left">Fourth point</td>
  <td style="text-align:left">- "Game"</td>
</tr>
</tbody>
</table>
<p>标准局的得分规则如下（发球方分数报在前）：</p>
<p>但若双方各赢得三分，则比分称为"平分"。在"平分"后，赢得下一分的球员/队伍将获得"占先"。若该球员/队伍继续赢得下一分，则赢得该"局"；若对方球员/队伍赢得下一分，则比分再次回到"平分"。球员/队伍需在"平分"后连续赢得两分才能赢得该"局"。</p>
<pre><code>inductive Score : Type where
    | vs <span class="math">\(\quad: \mathbb{N} \rightarrow \mathbb{N} \rightarrow\)</span> Score
    | advServ : Score
    | advRecv : Score
    | gameServ : Score
    | gameRecv : Score
</code></pre>

<p>我们首先定义一个归纳类型来表示比分：</p>


<p>例如30-15这样的比分被表示为Score.vs 3015，我们也会用中缀记法写作<span class="math">\(30-15\)</span>。我们忽略了计分规则中某些最不重要的细节，用o表示"Love"，用40-40表示"Deuce"。如果需要，我们可以引入别名，例如def love : <span class="math">\(\mathbb{N}:=\)</span> Score.vs 00。</p>

<pre><code>inductive Step : Score <span class="math">\(\rightarrow\)</span> Score <span class="math">\(\rightarrow\)</span> Prop where
    | serv_0_15 : <span class="math">\(\forall n\)</span>, Step ( <span class="math">\(0-n\)</span> ) (15-n)
    | serv_15_30 : <span class="math">\(\forall n\)</span>, Step (15-n) (30-n)
    | serv_30_40 : <span class="math">\(\forall n\)</span>, Step (30-n) (40-n)
    | serv_40_game : <span class="math">\(\forall n, n&lt;40 \rightarrow\)</span> Step (40-n) Score.gameServ
    | serv_40_adv : Step (40-40) Score.advServ
    | serv_adv_40 : Step Score.advServ (40-40)
    | serv_adv_game : Step Score.advServ Score.gameServ
    | recv_0_15 : <span class="math">\(\forall n\)</span>, Step ( <span class="math">\(n-0\)</span> ) ( <span class="math">\(n-15\)</span> )
    | recv_15_30 : <span class="math">\(\forall n\)</span>, Step ( <span class="math">\(n-15\)</span> ) ( <span class="math">\(n-30\)</span> )
    | recv_30_40 : <span class="math">\(\forall n\)</span>, Step ( <span class="math">\(n-30\)</span> ) ( <span class="math">\(n-40\)</span> )
    | recv_40_game : <span class="math">\(\forall n, n&lt;40 \rightarrow\)</span> Step ( <span class="math">\(n-40\)</span> ) Score.gameRecv
    | recv_40_adv : Step (40-40) Score.advRecv
    | recv_adv_40 : Step Score.advRecv (40-40)
    | recv_adv_game : Step Score.advRecv Score.gameRecv
</code></pre>

<p>下一步是引入一个二元谓词Step，用于判断是否可以进行状态转移：</p>


<p>设<span class="math">\(s \sim t\)</span>表示Step<span class="math">\(s t\)</span>的缩写。一个比赛就是形如<span class="math">\(s_{0} \sim s_{1} \sim s_{2} \sim \cdots \sim s_{n}\)</span>的链条，其中<span class="math">\(s_{0}=0-0\)</span>且无法从<span class="math">\(s_{n}\)</span>继续转移。该谓词允许诸如15-99转30-99这类无意义的过渡，但由于分数15-99不可能从<span class="math">\(0-0\)</span>达到，这些转移是无害的。</p>

<pre><code>theorem no_Step_to_0_0 (s : Score) :
    <span class="math">\(\neg \mathrm{s} \sim 0-0:=\)</span>
    by
        intro h
        cases h
</code></pre>
<p>在获得正式定义的基础上，我们可以提出并严谨回答以下问题：比赛是否存在最大长度？可能出现的不同最终比分有多少种？比分15-99能否从"Love all"状态达到？分数是否可能回归o-o状态？让我们使用Lean来证伪最后一个命题：</p>

<p>下图总结了从哪些比分可以到达哪些比分：</p>


<p><img src="img-6.jpeg" alt="img-6.jpeg"></p>

<div class="math">$$
\begin{aligned}
&amp; r=\{(1,2),(2,4),(4,8)\} \\
&amp; r^{*}=\{(n, n) \mid n \in \mathbb{N}\} \cup\{(1,2),(1,4),(1,8),(2,4),(2,8),(4,8)\}
\end{aligned}
$$</div>

<h4>6.1.3 自反传递闭包</h4>
<p>作为归纳谓词的一个特别有用的应用，考虑二元关系<span class="math">\(r\)</span>的自反传递闭包<span class="math">\(r^{*}\)</span>。非正式地说，<span class="math">\(r^{*}\)</span>是表示零次或多次<span class="math">\(r\)</span>步骤的关系。例如，如果<span class="math">\(r\)</span>对应于在转移系统（如自动机）中采取一次转移，那么<span class="math">\(r^{*}\)</span>对应于采取任意次数（包括零次）的步骤。更具体的例子如下：</p>

<div class="math">$$
\frac{(a, b) \in r}{(a, b) \in r^{*}} \text { BASE } \quad \frac{(a, a) \in r^{*}(b, c) \in r^{*}}{(a, c) \in r^{*}} \text { TRANS }
$$</div>
<p>星号运算符（<span class="math">\(\left.{ }^{*}\right)\)</span>通常被严格定义为一个形式系统：</p>

<p>这些规则将<span class="math">\(r^{*}\)</span>定义为包含<span class="math">\(r\)</span>（通过BASE规则）的最小关系，且该关系具有自反性（通过REFL规则）和传递性（通过TRANS规则）。若需定义传递闭包<span class="math">\(r^{*}\)</span>，只需省略REFL规则；若需定义自反对称闭包，则需将TRANS规则替换为SYMM规则。在形式化系统中，我们只需声明所需的属性成立，而无需考虑终止性或可执行性问题。</p>

<pre><code>inductive Star <span class="math">\(\{\alpha:\)</span> Type \} (R : \alpha \rightarrow \alpha \rightarrow\) Prop) : <span class="math">\(\alpha \rightarrow \alpha \rightarrow\)</span> Prop
where
    | base (a b : <span class="math">\(\alpha) \quad: R\)</span> a b <span class="math">\(\rightarrow\)</span> Star R a b
    | refl (a : <span class="math">\(\alpha) \quad\)</span> : Star R a a
    | trans (a b c : <span class="math">\(\alpha\)</span> ) : Star R a b <span class="math">\(\rightarrow\)</span> Star R b c <span class="math">\(\rightarrow\)</span> Star R a c
</code></pre>
<p>将上述推导规则转换为归纳谓词的引入规则是直截了当的：</p>
<div class="math">$$
\text { | base : } \forall \mathrm{a} \mathrm{~b}: \alpha, \mathrm{R} \text { a } \mathrm{b} \rightarrow \text { Star } \mathrm{R} \text { a } \mathrm{~b}
$$</div>

<p>我们将关系表示为二元谓词而非有序对的集合，用R a b表示<span class="math">\((a, b) \in R\)</span>。关系与谓词可互换使用，但在证明助手中谓词通常更为便利。关系<span class="math">\(R\)</span>的自反传递闭包记作Star R。注意<span class="math">\(a, b\)</span>和<span class="math">\(c\)</span>被声明为引入规则的参数，位于冒号左侧。我们亦可写作</p>

<div class="math">$$
\text { | base (a b : } \alpha \text { ) (hab : R a b) : Star R a b }
$$</div>

<p>或者在另一个极端情况下</p>

<pre><code>inductive predicate-name (params <span class="math">\({ }_{1}:\)</span> type <span class="math">\(_{1}\)</span> ) ... (params<span class="math">\(_{k}:\)</span> type <span class="math">\(_{k}\)</span> ) :
    type <span class="math">\(_{k+1} \rightarrow \cdots \rightarrow\)</span> type <span class="math">\(_{k+p} \rightarrow\)</span> Prop where
    | rule-name <span class="math">\(_{1}\)</span> (params <span class="math">\(_{11}:\)</span> type <span class="math">\(_{11}\)</span> ) ... (params <span class="math">\(_{1 m_{1}}:\)</span> type <span class="math">\(_{1 m_{1}}\)</span>) :
        proposition <span class="math">\(_{1}\)</span>
        \vdots
    | rule-name <span class="math">\(_{n}\)</span> (params <span class="math">\(_{n 1}:\)</span> type <span class="math">\(_{n 1}\)</span> ) ... (params <span class="math">\(_{n m_{n}}:\)</span> type <span class="math">\(_{n m_{n}}\)</span>) :
        proposition <span class="math">\(_{n}\)</span>
</code></pre>

<p>所有这些形式在逻辑和操作上都是等价的。归纳谓词的一般格式如下：</p>


<p>其中每个命题<span class="math">\(j\)</span>的结论必须是定义的谓词predicate-name对某些参数的应用。这些参数可以是任意项，不需要是构造器模式。如果我们想让参数对应隐式参数，也可以使用花括号<span class="math">\(\}\)</span>替代圆括号( )。</p>

<pre><code>def starRec { }\alpha: Type} (R : \alpha -&gt; \alpha -&gt; \text { Bool}):\mathrm{
    \alpha -&gt; \alpha -&gt; Bool :=
</code></pre>

<p>上述Star的定义堪称优雅典范。若仍存疑虑，不妨尝试将其实现为递归函数：</p>

<p>综上所述，归纳谓词<span class="math">\(P\)</span>的每条引入规则从左至右包含以下组成部分：</p>
<ul>
<li>名称；</li>
<li>规则中可能出现的变量；</li>
<li>零个或多个必须满足的条件，这些条件可能递归地应用P；</li>
<li>将P应用于某些参数所形成的模式。</li>
</ul>

<p>相应地，对于规则Star.base而言，其模式为Star R a b，条件是R a b，变量为<span class="math">\(a\)</span>和<span class="math">\(b\)</span>。</p>

<pre><code>-- fails
inductive Illegal : Prop where
    | intro : ~ Illegal -&gt; Illegal
</code></pre>

<h4>6.1.4 反例说明</h4>
<p>并非所有归纳定义都存在最小解。最简单的反例是</p>


<p>若Lean接受此定义，我们就能用它证明等价关系Illegal <span class="math">\(\leftrightarrow \neg\)</span> Illegal，并由此轻易推导出False。所幸Lean拒绝了该定义：'Illegal.intro'的第一个参数在声明数据类型时出现了非正出现</p>


<p>Lean所抱怨的非正出现（nonpositive occurrence）是指非法性（Illegal）在否定符号下的出现。数学家们会拒绝这一定义，理由是它不满足Knaster-Tarski定理的单调性条件。</p>

<pre><code>inductive And (a b : Prop) : Prop where
    | intro : a -&gt; b -&gt; And a b
inductive Or (a b : Prop) : Prop where
    | inl : a -&gt; Or a b
    | inr : b -&gt; Or a b
inductive Iff (a b : Prop) : Prop where
    | intro : (a -&gt; b) -&gt; (b -&gt; a) -&gt; Iff a b
inductive Exists {a : Type} (P : \alpha -&gt; Prop) : Prop where
    | intro : Va : \alpha, P a -&gt; Exists P
inductive True : Prop where
    | intro : True
inductive False : Prop where
inductive Eq {a : Type} : \alpha -&gt; \alpha -&gt; Prop where
    | refl : Va : \alpha, Eq a a
</code></pre>

<h3>6.2 逻辑符号</h3>
<p>尽管Even是本指南中首个公开出现的归纳谓词，但前几章已暗中介绍了其他归纳谓词。其中最早出现的是等号（<span class="math">\(=\)</span>），在第二章引入，随后是逻辑符号<span class="math">\(\wedge\)</span>、<span class="math">\(V, \leftrightarrow, \exists\)</span>，以及True和False。这些定义值得仔细研读：</p>


<p>（严格来说，在Lean中，上述部分定义实际上是结构体而非归纳谓词，但这种差异只是表面上的。正如我们在5.5节所见，结构体本质上就是带有语法糖的单构造器归纳谓词。）</p>


<p>传统记法 <span class="math">\(\exists x: \alpha, P\)</span> 和 <span class="math">\(x=y\)</span> 分别是 Exists (fun <span class="math">\(x: \alpha \mapsto P\)</span> ) 及 Eq <span class="math">\(x\)</span> y 的语法糖。注意 fun 如何作为通用绑定器使用。还需注意 False 没有对应的构造子——正如 Even 1 不存在证明一样，False 也不存在任何证明。通过归纳谓词，我们仅声明那些希望成立的规则。</p>


<p>符号<span class="math">\(\vee\)</span>（包括其特例<span class="math">\(\rightarrow\)</span>）直接内置于逻辑系统中，并未定义为归纳谓词。它也不具有显式的引入或消解规则。其引入原则是匿名函数fun <span class="math">\(x \mapsto\)</span> _ ，消解原则则是函数应用 _ u。</p>


<p>对于任何归纳谓词，仅需指定其引入规则。第3.3节和3.4节中提出的消解规则必须手动推导。</p>

<h3>6.3 规则归纳法</h3>
<p>正如我们可以对归纳类型的项进行归纳那样，我们也可以对归纳谓词的证明实施归纳。例如给定目标<span class="math">\(h\)</span> : Even <span class="math">\(n \vdash P n\)</span>时，可以对<span class="math">\(h\)</span>调用归纳法，得到对应于Even.zero和Even.add_two的两个子目标。这被称为基于<span class="math">\(h\)</span>推导结构的归纳法，或简称为规则归纳法——因为归纳过程作用于谓词的引入规则（即证明项的构造子）。</p>

<p>规则归纳有两种理解方式："最小谓词满足观"和"PAT观"。要理解最小谓词满足观，需回顾归纳定义将符号引入为满足引入规则的最小（即最假）谓词。因此，Even是满足性质Q<span class="math">\(\theta\)</span>和<span class="math">\(\forall k, Q k \rightarrow Q(k+2)\)</span>的最小谓词Q。若能证明某个谓词<span class="math">\(P\)</span>满足<span class="math">\(P \theta\)</span>和<span class="math">\(\forall k, P k \rightarrow P(k+2)\)</span>，则<span class="math">\(P\)</span>要么等于Even，要么比Even更大（即更真）。因此，Even n蕴含P n，这正是证明目标h : Even <span class="math">\(\mathrm{n} \vdash \mathrm{Pn}\)</span>所需的结论。</p>


<p>"最小谓词满足条件"视角为规则归纳提供了一个直观的解释，可用于非形式化论证，例如以下证明：对于所有n，Even n蕴含<span class="math">\(\mathrm{n} \% 2=\theta\)</span>：</p>


<p>该证明通过对假设Even n进行规则归纳来完成。情形Even.zero：我们需要证明<span class="math">\(\theta \% 2=\theta\)</span>，这可通过计算得出。情形Even.add_two k：归纳假设为<span class="math">\(\mathrm{k} \% 2=\theta\)</span>，需证明<span class="math">\((k+2) \% 2=\theta\)</span>，这可通过基础算术推理得证。</p>

<pre><code>theorem mod_two_Eq_zero_of_Even (n : N) (h : Even n) :
    n % 2 = 0 :=
    by
        induction h with
        | zero =&gt; rfl
        | add_two k hk ih =&gt; simp [ih]
</code></pre>

<p>Lean的证明具有相同的结构：</p>

<div class="math">$$
\begin{gathered}
\vdash P_{0}[\text { Even. zero : Even } \theta] \\
k: \mathbb{N}, h k: \text { Even } k, i h: P_{k}[h k] \vdash P_{k+2}[\text { Even.add_two } k h k: \text { Even }(k+2)]
\end{gathered}
$$</div>

<p>PAT原则为我们提供了审视规则归纳法的另一富有成效的视角。其核心思想是：在形如<span class="math">\(h\)</span> : Even <span class="math">\(n \vdash P[h]\)</span>的目标中对<span class="math">\(h\)</span>进行规则归纳，本质上完全类似于对依赖归纳类型值（如Vec <span class="math">\(\alpha n\)</span>，见第5.10节）的结构归纳。若用<span class="math">\(P_{u}[\)</span> ]表示将<span class="math">\(n\)</span>替换为某术语<span class="math">\(u\)</span>后的<span class="math">\(P[\)</span> ]变体，我们将得到以下子目标：</p>


<p>这些实际上就是归纳策略生成的子目标。无论归纳谓词Q是什么，计算子目标的过程始终相同：</p>
<ol>
<li>将<span class="math">\(P[h]\)</span>中的<span class="math">\(h\)</span>替换为每个可能引入规则应用到新变量后的形式（例如Even.add_two k hk），并实例化<span class="math">\(P[ ]\)</span>中的n以保证类型正确。这会生成与引入规则数量相同的子目标。</li>
<li>将这些新变量（例如<span class="math">\(k, h k\)</span>）添加到局部上下文中。</li>
<li>为所有断言<span class="math">\(Q \ldots\)</span>的新假设添加归纳假设。</li>
</ol>


<p>注意上述假设中存在hk : Even k这一项。在最小谓词满足条件的视图中它并不存在，也非必需，因为总可以通过将<span class="math">\(P\)</span>强化为Even <span class="math">\(n \wedge \cdots\)</span>的形式来恢复该条件。</p>

<div class="math">$$
\vdash P_{0} \quad k: \mathbb{N}, h k: \text { Even } k, i h: P_{k} \vdash P_{k+2}
$$</div>

<p>在几乎所有实际情况下，<span class="math">\(h\)</span>不会出现在<span class="math">\(P[h]\)</span>中。此时我们可以直接写作</p>


<p>在极少数情况下，<span class="math">\(h\)</span>会出现在<span class="math">\(P[h]\)</span>中。如我们在5.7节尝试提取列表头部时所看到的，证明可能以子项形式出现在任意项中。</p>

<div class="math">$$
\begin{gathered}
a b: \alpha, h a b: R a b \vdash P_{a, b} \\
a: \alpha \vdash P_{a, a}
\end{gathered}
$$</div>

<p>接下来，我们考虑自反传递闭包Star R。给定目标h : Star <span class="math">\(R x y \vdash P\)</span>，对<span class="math">\(h\)</span>进行规则归纳会产生以下子目标，其中<span class="math">\(P_{t, u}\)</span>表示将<span class="math">\(P\)</span>中的<span class="math">\(x\)</span>和<span class="math">\(y\)</span>分别替换为<span class="math">\(t\)</span>和<span class="math">\(u\)</span>后的变体：</p>

<pre><code>theorem Star_Star_IIff_Star {\alpha : Type} (R : \alpha \rightarrow \alpha \rightarrow \text { Prop) }
    (a b : \alpha) :
    Star (Star R) a b \leftrightarrows Star R a b :=
    by
        apply Iff.intro
        { intro h
            induction h with
            | base a b hab =&gt; exact hab
            | refl a =&gt; apply Star.refl
            | trans a b c hab hbc ihab ihbc =&gt;

    apply Star.trans a b
    { exact ihab }
    { exact ihbc } }
{ intro h
    apply Star.base
    exact h }
</code></pre>

<p><span class="math">\(a b c: \alpha, h a b: S t a r R a b, h b c: S t a r R b c, i h a b: P_{a, b}, i h b c: P_{b, c} \vdash P_{a, c}\)</span>这里正是"证明辅助"中"辅助"特性的体现。Star的关键性质之一是幂等性——对Star R再次应用Star操作不会产生任何效果。在Lean中可通过规则归纳法证明这一点，用于等价关系的<span class="math">\(\rightarrow\)</span>方向推导：</p>


<p>我们谨慎地为新出现的变量赋予直观的名称。在包含冗长且自动生成名称的目标中很容易迷失方向。第3.8节介绍的清理策略也能帮助应对大型目标。</p>

<pre><code>@[simp] theorem Star_Star_Eq_Star {a : Type}
    (R : α -&gt; α \Prop) :
    Star (Star R) = Star R :=
    by
    apply funext
    intro a
    apply funext
    intro b
    apply propext
    apply Star_Star_Iff_Star
</code></pre>

<p>我们可以更传统地用等式而非等价关系来表述幂等性：</p>

<div class="math">$$
\begin{gathered}
\text { funext }:(\forall x, ? f x=? g x) \rightarrow ? f=? g \\
\text { propext }:(? a \leftrightarrow ? b) \rightarrow ? a=? b
\end{gathered}
$$</div>
<p>该证明使用了两个定理，由于Lean采用的是经典逻辑，这些定理是可用的：</p>
<p>函数外延性（funext）指出若两个函数对所有输入都产生相同结果，则这两个函数必然相等。命题外延性（propext）则声明命题的等价性与相等性一致。在这些表述中，"外延性"意味着某种"所见即所得"的特性。尽管这些性质看似显而易见，但某些基于较弱直觉主义逻辑构建的证明助手中，这些性质通常并不成立。</p>

<p>我们将定理Star_Star_Eq_Star注册为simp规则，因为当将其视为从左到右的重写规则时，它确实用更简单的项替换了复杂项。很难想象在什么情况下我们会不希望simp将Star(Star...)重写为Star...</p>

<p>对于规则归纳，我们使用induction策略。由于某些微妙的逻辑原因（第12章将更清晰地阐明），不允许通过模式匹配和递归进行规则归纳。</p>

<p>在5.4节中，我们曾看到并排展示Bool与Prop解释的示意图。该示意图暗示存在无限多个命题，但现在我们已知命题实际上只有两个：False和True。以下是修正后的示意图：</p>


<p><img src="img-7.jpeg" alt="img-7.jpeg"></p>


<p>可见仅存在两个命题：一个无任何证明，另一个则有若干证明。图中展示了三个证明实例。我们将在第12章再次完善这一图示。</p>


<h3>6.4 线性算术策略</h3>
<h4>linarith</h4>
<p>linarith策略可用于证明涉及线性算术等式（<span class="math">\(\circ\)</span>）、不等式（<span class="math">\(&lt;,&gt;, \leq\)</span>和<span class="math">\(\geq\)</span>）以及非等式（<span class="math">\(\neq\)</span>）的目标。线性意味着不出现乘除法运算，若出现则其中一个操作数必须是数值常量。例如<span class="math">\(2 * x&lt;y\)</span>是线性约束（可重写为<span class="math">\(x+x&lt;y\)</span>），而<span class="math">\(x * y&lt;y\)</span>则是非线性的。</p>


<h3>6.5 消解规则</h3>
<p>给定一个归纳谓词Q，其引入规则通常形如<span class="math">\(\forall \ldots, \cdots \rightarrow Q \ldots\)</span>，可用于证明形如<span class="math">\(\vdash Q \ldots\)</span>的目标。消解规则则反向运作：它从定理或假设h : Q...中提取信息。消解有多种形式：cases和induction策略、模式匹配、以及消解规则（例如And.left）。</p>


<p>当作用于h : <span class="math">\(\mathrm{Q} \ldots\)</span>时，cases h策略执行的规则归纳与induction <span class="math">\(h\)</span>大致相同，但不会生成任何归纳假设。我们在第5章遇到的两个惯用法现在终于可以进行分析。</p>

<div class="math">$$
a: \alpha \vdash P_{a, a}[E q . r e f l a: a=a]
$$</div>

<p>第一种惯用法是当<span class="math">\(h\)</span>具有<span class="math">\(1=r\)</span>的形式时——即Eq <span class="math">\(1 r\)</span>（第6.2节）。假设目标为<span class="math">\(h: 1=r \vdash P[h]\)</span>，第6.3节所述流程将生成子目标</p>

<div class="math">$$
1: \alpha \vdash P_{1,1}
$$</div>

<p>其中<span class="math">\(\mathrm{P}_{\mathrm{t}, \mathrm{o}}[\mathrm{l}\)</span>表示P[]的变体，其中1和r分别被替换为t和<span class="math">\(u\)</span>。（严格来说，无用的假设<span class="math">\(h: a=a\)</span>也会出现在子目标中。）实际上，<span class="math">\(P[h]\)</span>很可能不依赖于<span class="math">\(h\)</span>。此外，cases复用名称1而非使用其他名称如a。因此我们将得到</p>


<p>换言之，原目标中所有<span class="math">\(r\)</span>的出现都已被替换为1。这对应我们在5.7节观察到的行为。</p>

<div class="math">$$
\begin{gathered}
h Q: Q \vdash P[O r . i n l h Q: Q \vee \neg Q] \\
h n Q: \neg Q \vdash P[O r . i n r h n Q: Q \vee \neg Q]
\end{gathered}
$$</div>

<p>第二种惯用法是策略 cases Classical.em Q，其中 Q 是一个命题。Classical.em Q 部分是<span class="math">\(Q \vee \neg Q\)</span>的证明项——即 Or <span class="math">\(Q(\neg Q)\)</span>（第6.2节）。随后应用 cases 策略来消解<span class="math">\(\vee\)</span>连接词。假设目标为<span class="math">\(\vdash P[\)</span> Classical.em Q]，根据 Or 谓词的定义，新的子目标为</p>

<div class="math">$$
h Q: Q \vdash P \quad h n Q: \neg Q \vdash P
$$</div>

<p>无需修改<span class="math">\(P\)</span>，因为Or.inl hQ和Or.inr hnQ与Classical.em Q具有相同的类型——即<span class="math">\(Q \vee \neg Q\)</span>。实际应用中，目标通常不会包含Classical.em Q而简化为<span class="math">\(\vdash P\)</span>，此时我们将得到以下子目标</p>


<p>同样，这正是我们在5.7节观察到的行为。在结构化证明中，可以使用匹配表达式（第5.4节）实现与cases相同的效果。这对逻辑符号效果良好。但对于像Even和Star这样的谓词，其参数会随着归纳过程演变，我们最终会遇到依赖类型的模式匹配，这十分微妙（第5.10节）。通常让cases自动推断子目标的形式比手动模式匹配更简便。下文我们将通过示例对比这两种风格的实现。</p>

<div class="math">$$
\forall x_{1} \ldots x_{n}, Q\left(c x_{1} \ldots x_{n}\right) \rightarrow(\exists \ldots, \cdots \wedge \cdots) \vee \cdots \vee(\exists \ldots, \cdots \wedge \cdots)
$$</div>

<p>对于形如<span class="math">\(Q(c \ldots)\)</span>的假设（其中<span class="math">\(c\)</span>是构造器或其他常量）进行展开可能很有用。我们可以陈述并证明一个反演规则来支持这种消解推理。典型的反演规则具有如下形式：</p>

<div class="math">$$
\forall x_{1} \ldots x_{n}, Q\left(c x_{1} \ldots x_{n}\right) \leftrightarrow(\exists \ldots, \cdots \wedge \cdots) \vee \cdots \vee(\exists \ldots, \cdots \wedge \cdots)
$$</div>

<p>将引入规则和消解规则结合成单一定理会很有用，该定理可用于重写目标的假设和结论部分。格式与之前相同，只是中间的连接词变为<span class="math">\(\leftrightarrow\)</span>：</p>

<pre><code>theorem Even_Iff ( <span class="math">\(n: \mathbb{N}\)</span> ) :
    Even <span class="math">\(n \leftrightarrow n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge\)</span> Even m <span class="math">\():=\)</span>
    by
    apply Iff.intro
    \{ intro hn
        cases hn with
        | zero <span class="math">\(\quad=&gt;\)</span> simp
        | add_two k hk =&gt;
            apply Or.inr
            apply Exists.intro k
            simp [hk] \}
    \{ intro hor
        cases hor with
        | inl heq =&gt; simp [heq, Even.zero]
        | inr hex =&gt;
            cases hex with
            | intro k hand =&gt;
                cases hand with
                | intro heq hk =&gt;
                simp [heq, Even.add_two _ hk] \}
</code></pre>

<p>关于偶数的反演规则如下：</p>


<p>与往常一样，战术性证明并不特别易读，但我们看到引入规则和消解情形策略发挥了主要作用，无论是对于逻辑符号还是Even谓词。simp策略完成了最后的润色。</p>

<pre><code>theorem Even_Iff_struct ( <span class="math">\(n: \mathbb{N}\)</span> ) :
    Even <span class="math">\(n \leftrightarrow n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge\)</span> Even m <span class="math">\():=\)</span>
    Iff.intro
    (assume hn : Even n

    match n, hn with
    | _, Even.zero =&gt;
        show 0 = 0 V _ from
            by simp
    | _, Even.add_two k hk =&gt;
        show _ V ( }\exists\mathrm{ m, k + 2 = m + 2 ^ Even m) from
            Or.inr (Exists.intro k (by simp [*])))
(assume hor : n = 0 V ( }\exists\mathrm{ m, n = m + 2 ^ Even m)
    match hor with
    | Or.inl heq =&gt;
        show Even n from
            by simp [heq, Even.zero]
    | Or.inr hex =&gt;
        match hex with
        | Exists.intro m hand =&gt;
        match hand with
            | And.intro heq hm =&gt;
                show Even n from
                    by simp [heq, Even.add_two _ hm])
</code></pre>

<p>若您偏好结构化证明，以下是基于 hn : Even n 的依赖类型模式匹配的证明版本：</p>


<h3>6.6 更多示例</h3>
<p>在深入理解归纳谓词的基础上，我们现在可以依次回顾四个进一步的应用案例。</p>

<pre><code>inductive Sorted : List }\mathbb{N} \rightarrow \text { Prop where }
    | nil : Sorted []
    | single (x : N) : Sorted [x]
    | two_or_more (x y : N) {zs : List N} (hle : x \leq y)
        (hsorted : Sorted (y :: zs)) :
    Sorted (x :: y :: zs)
</code></pre>

<h3>6.6.1 有序列表</h3>
<p>我们的第一个示例是用于检查自然数列表是否按递增顺序排列的谓词：</p>


<p>该定义捕捉了以下数学直觉：排序列表集合被定义为满足以下规则的最小闭集：(1) 列表[]是已排序的；(2) 给定数字<span class="math">\(x\)</span>，列表<span class="math">\([x]\)</span>是已排序的；(3) 给定两个数字<span class="math">\(x, y\)</span>和列表<span class="math">\(z s\)</span>，若<span class="math">\(x \leq y\)</span>且<span class="math">\(y:: z s\)</span>已排序，则<span class="math">\(x:: y:: z s\)</span>是已排序的。</p>

<pre><code>theorem Sorted_3_5 :
    Sorted [3, 5] :=
    by
        apply Sorted.two_or_more
        { simp }
        { exact Sorted.single _ }
</code></pre>

<p>通过小规模示例测试定义总是一个好方法。列表<span class="math">\([3,5]\)</span>是否有序？看起来确实如此：</p>

<pre><code>theorem Sorted_3_5_raw :
    Sorted [3, 5] :=
    Sorted.two_or_more _ _ (by simp) (Sorted.single _)
</code></pre>

<p>该示例使用了两个关于已排序列表的引入规则。以下是一个更简洁的证明，使用证明项：</p>

<pre><code>theorem sorted_7_9_9_11 :
    Sorted [7, 9, 9, 11] :=
    Sorted.two_or_more _ _ (by simp)
    (Sorted.two_or_more _ _ (by simp)
        (Sorted.two_or_more _ _ (by simp)
            (Sorted.single _)))
</code></pre>
<p>同样的思路可用于证明<span class="math">\([7,9,9,11]\)</span>是已排序的：</p>
<pre><code>theorem Not_Sorted_17_13 :
    ~ Sorted [17, 13] :=
    by
        intro h
        cases h with
        | two_or_more _ _ hlet hsorted =&gt; simp at hlet
</code></pre>

<p>反过来，我们可以证明某些列表是未排序的。为此，我们需要使用排除法：</p>


<p>从列表<span class="math">\([17,13]\)</span>已排序的假设出发，我们可以推导出不等式17<span class="math">\(\leq 13\)</span>。cases策略会静默地排除空列表和单元素列表的情况，因为它们无法匹配双元素列表。随后我们调用simp策略来利用这个不可能成立的假设<span class="math">\(17 \leq 13\)</span>。</p>

<pre><code>inductive Palindrome <span class="math">\(\{\alpha\)</span> : Type\} : List <span class="math">\(\alpha \rightarrow\)</span> Prop where
    | nil : Palindrome []
    | single (x : <span class="math">\(\alpha\)</span> ) : Palindrome [x]
    | sandwich (x : <span class="math">\(\alpha\)</span> ) (xs : List <span class="math">\(\alpha\)</span> ) (hxs : Palindrome xs) :
        Palindrome ([x] ++ xs ++ [x])
</code></pre>

<h4>6.6.2 回文</h4>
<p>回文是指正读反读都相同的列表。例如，<span class="math">\([a, b, b, a]\)</span>和<span class="math">\([a, h, a]\)</span>都是回文。以下归纳谓词当且仅当传入的列表是回文时为真：</p>

<pre><code>-- fails
def palindromeRec { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; Bool
    | [] =&gt; true
    | [_] =&gt; true
    | ([x] ++ xs ++ [x]) =&gt; palindromeRec xs
    | _ =&gt; false
</code></pre>

<p>该定义区分了三种情况：(1) 空列表[]是回文；(2) 对于任意元素<span class="math">\(x\)</span>，单元素列表<span class="math">\([x]\)</span>是回文；(3) 对于任意元素<span class="math">\(x\)</span>和任意回文<span class="math">\(\left[y_{1}, \ldots, y_{n}\right]\)</span>，列表<span class="math">\(\left[x, y_{1}, \ldots, y_{n}, x\right]\)</span>也是回文。回文是归纳谓词展现优势的另一个典型案例。以下这种简单的递归定义无法成立，因为[x] ++ xs ++ [x]不是构造器模式，且变量<span class="math">\(x\)</span>出现了重复：</p>

<pre><code>theorem Palindrome_reverse { }\alpha\mathrm{ : Type} (xs : List }\alpha\mathrm{ )
    (hxs : Palindrome xs) :
    Palindrome (reverse xs) :=
    by
        induction hxs with
        | nil =&gt; exact Palindrome.nil
        | single x =&gt; exact Palindrome.single x
        | sandwich x xs hxs ih =&gt;
            { simp [reverse, reverse_append]
                exact Palindrome.sandwich _ _ ih }
</code></pre>

<p>正确的递归定义是可能的，但超出了本指南的范围。自然地，回文的逆序仍是回文。这是一个很好的练习：</p>


<p>非正式证明：
该证明通过对假设hxs进行规则归纳。
情况Palindrome.nil：需证明Palindrome (reverse [])。根据reverse [] = []，可直接应用Palindrome.nil得证。
情况Palindrome.single x：需证明Palindrome (reverse [x])。利用reverse <span class="math">\([x]=[x]\)</span>，通过Palindrome.single即可得证。
情况Palindrome.sandwich x xs hxs：在假设Palindrome xs（hxs）下，需证明Palindrome (reverse ([x] ++ xs ++ [x]))。归纳假设为Palindrome (reverse xs)。经化简后，只需证明Palindrome ([x] ++ reverse xs ++ [x])。根据Palindrome.sandwich规则，最终归结为证明Palindrome (reverse xs)，而这正是归纳假设本身。</p>

<pre><code>inductive IsFull { }\alpha\mathrm{ : Type} : Tree }\alpha\mathrm{ -&gt; Prop where
    | nil : IsFull Tree.nil
    | node (a : }\alpha\mathrm{ ) (l r : Tree }\alpha\mathrm{ )
        (hl : IsFull l) (hr : IsFull r)
        (hiff : l = Tree.nil ++ r = Tree.nil) :
    IsFull (Tree.node a l r)
</code></pre>

<h4>6.6.3 满二叉树</h4>
<p>我们的第三个例子基于5.8节介绍的二叉树类型。如果二叉树的所有节点要么没有子节点，要么有两个子节点，则称该树为满二叉树。这可以通过归纳谓词进行编码：</p>


<p>第一种情况表明nil树是满二叉树。第二种情况表明，非nil树若具有两个子树且这两个子树自身都是满的，并且同时为nil或同时为非nil，则该树为满二叉树。这两种情况完美遵循了归纳类型的结构，因此自然地复用nil和node这两个名称。</p>

<pre><code>theorem IsFull_singleton {\alpha : Type} (a : \alpha) :
    IsFull (Tree.node a Tree.nil Tree.nil) :=
    by
        apply IsFull.node
        { exact IsFull.nil }
        { exact IsFull.nil }
        { rfl }
</code></pre>

<p>以nil树作为子节点的节点所构成的树是满树。这里给出一个简单证明：</p>

<pre><code>theorem IsFull_mirror { }\alpha\mathrm{ : Type} (t : Tree \alpha)
    (ht : IsFull t) :
    IsFull (mirror t) :=
    by
        induction ht with
    | nil =&gt; exact IsFull.nil
    | node a l r hl hr hiff ih_l ih_r =&gt;
        { rw [mirror]
            apply IsFull.node
            { exact ih_r }
            { exact ih_l }
            { simp [mirror_Eq_nil_Iff, *] } }
</code></pre>

<p>满树一个更有趣的特性是镜像操作会保持其满树性质。我们的第一个证明是通过对ht : IsFull t进行规则归纳：</p>

<pre><code>theorem IsFull_mirror_struct_induct { }\alpha\mathrm{ : Type} (t : Tree \alpha) :
    IsFull t -&gt; IsFull (mirror t) :=
    by
        induction t with
    | nil =&gt;
        { intro ht
            exact ht }
    | node a l r ih_l ih_r =&gt;
        { intro ht
            cases ht with
            | node _ _ _ hll hr hiff =&gt;
                { rw [mirror]
                    apply IsFull.node
                    { exact ih_r hr }
                    { apply ih_l hl }
                    { simp [mirror_Eq_nil_Iff, *] } } }
</code></pre>
<p>由于IsFull的定义遵循Tree的定义，对树t进行结构归纳也是合理的：</p>

<p>此处的关键在于对假设ht : IsFull (Tree. node a l r)进行情形区分。cases策略注意到IsFull.nil引入规则不可能被用于推导ht，因此仅生成一个对应于IsFull.node的情形。与往常一样，若在Visual Studio Code中查看并移动光标检查，该战术性证明将更易理解。</p>

<pre><code>inductive Term ( }\alpha\beta\mathrm{ : Type) : Type where
    | var : <span class="math">\(\beta \rightarrow\)</span> Term <span class="math">\(\alpha \beta\)</span>
    | fn : }\alpha\mathrm{ List (Term }\alpha\beta\mathrm{ ) } \rightarrow\) Term }\alpha\beta\mathrm{ }
</code></pre>

<h4>6.6.4 一阶项</h4>
<p>我们的最后一个示例基于一阶项的归纳类型：</p>


<p>一阶项要么是变量<span class="math">\(x\)</span>，要么是函数符号<span class="math">\(f\)</span>作用于参数列表的形式：<span class="math">\(f\left(t_{1}, \ldots, t_{n}\right)\)</span>，其中数学变量<span class="math">\(t_{1}, \ldots, t_{n}\)</span>代表参数，而这些参数本身也是项。因此，<span class="math">\(\sin (\max (x, y))\)</span>属于一阶项。参数<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>分别表示函数符号和变量的类型。</p>


<p>并非所有项都是合法的。例如，项<span class="math">\(\min (\cos (a), \cos (a, b))\)</span>被视为格式错误，因为函数cos被调用的参数数量不一致（1个与2个参数）。除<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>外，我们还需考虑由函数arity: <span class="math">\(\alpha \rightarrow \mathbb{N}\)</span>表示的元数，它表明每个函数符号接受的参数数量。例如，二元符号的元数为2。</p>

<pre><code>inductive WellFormed <span class="math">\(\{\alpha \beta\)</span> : Type \} (arity : <span class="math">\(\alpha \rightarrow \mathbb{N})\)</span> :
    Term <span class="math">\(\alpha \beta \rightarrow\)</span> Prop where
    | var <span class="math">\((x: \beta)\)</span> : WellFormed arity (Term.var x)
    | fn (f : <span class="math">\(\alpha\)</span> ) (ts : List (Term <span class="math">\(\alpha \beta\)</span> ))
        (hargs : <span class="math">\(\forall \mathrm{t} \in \mathrm{ts}\)</span>, WellFormed arity t )
        (hlen : length ts = arity f) :
    WellFormed arity (Term.fn f ts)
</code></pre>

<p>wellFormed谓词随后检查给定项是否仅包含具有指定参数数量的函数符号应用：</p>


<p>变量(var)情形规定变量总是良构的。函数(fn)情形则递归检查参数<span class="math">\(t s\)</span>是否良构，并验证<span class="math">\(t s\)</span>的长度是否等于当前函数符号<span class="math">\(f\)</span>所规定的元数。</p>

<pre><code>inductive VariableFree <span class="math">\(\{\alpha \beta\)</span> : Type \} : Term <span class="math">\(\alpha \beta \rightarrow\)</span> Prop where
    | fn (f : <span class="math">\(\alpha\)</span> ) (ts : List (Term <span class="math">\(\alpha \beta\)</span> ))
        (hargs : <span class="math">\(\forall \mathrm{t} \in \mathrm{ts}\)</span>, VariableFree t) :
        VariableFree (Term.fn f ts)
</code></pre>

<p>一阶项的另一个有趣特性是它们是否包含变量。这可以通过归纳谓词轻松验证：</p>


<p>由于变量永远不可能是无变量的，因此不存在与Term.var对应的引入规则。</p>


<h3>6.7 归纳法陷阱</h3>
<p>对归纳谓词进行归纳调用时需要格外谨慎。归纳谓词的参数通常会在归纳过程中演变。这些细节在非形式化证明中常被忽略，但证明辅助工具要求我们必须精确处理。</p>

<pre><code>inductive Even : <span class="math">\(\mathbb{N} \rightarrow\)</span> Prop where
    | zero : Even \ 0
    | add_two : <span class="math">\(\forall \mathrm{k}: \mathbb{N}\)</span>, Even <span class="math">\(\mathrm{k} \rightarrow\)</span> Even <span class="math">\((k+2)\)</span>
</code></pre>

<p>回顾偶数的定义：</p>

<div class="math">$$
\vdash P \text { 0 } \quad k: \mathbb{N}, h k: P k \vdash P(k+2)
$$</div>
<p>若目标具有形式<span class="math">\(h\)</span> : Even <span class="math">\(n \vdash P n\)</span>，对<span class="math">\(h\)</span>进行归纳将产生以下子目标：</p>
<div class="math">$$
m: 2 * n+1, \text { hev : Even } m \vdash \text { False }
$$</div>

<p>这种方法能达到预期效果。问题在于当Even的参数不是变量时。在目标hev : Even <span class="math">\((2 * n+1) \vdash\)</span> False中对假设hev应用归纳法会失败并报错：目标类型中的索引不是变量（考虑改用'cases'策略）。要解决这个问题，我们需要将<span class="math">\(2 * n+1\)</span>替换为变量<span class="math">\(m\)</span>，并添加等式<span class="math">\(m=2 * n+1\)</span>作为假设：</p>

<div class="math">$$
\begin{gathered}
m n: \mathbb{N}, h m: \emptyset=2 * n+1 \vdash \text { False } \\
m: 2 * n+1, i h: m=2 * n+1 \rightarrow \text { False, } h m: m+2=2 * n+1 \vdash \text { False }
\end{gathered}
$$</div>
<p>这个目标在逻辑上是等价的，但现在归纳法会产生两个子目标：</p>
<p>遗憾的是，第二个子目标无法被证明。问题在于我们希望用<span class="math">\(n-1\)</span>来实例化归纳假设<span class="math">\(i h\)</span>中的<span class="math">\(n\)</span>，但<span class="math">\(n\)</span>本身不可实例化。</p>
<div class="math">$$
\begin{gathered}
m n: \mathbb{N}, h m: \emptyset=2 * n+1 \vdash \text { False } \\
m: 2 * n+1, i h: \forall n, m=2 * n+1 \rightarrow \text { False, } h m: m+2=2 * n+1 \vdash \text { False }
\end{gathered}
$$</div>

<p>解决方案？我们需要对<span class="math">\(n\)</span>进行全称量化，以便能在归纳假设中实例化它。这通过在归纳<span class="math">\(h\)</span>后指定泛化<span class="math">\(n\)</span>来实现。现在我们得到以下子目标：</p>


<p>现在归纳假设中的变量<span class="math">\(n\)</span>与目标其余部分的变量<span class="math">\(n\)</span>已解耦，我们可以用<span class="math">\(n-1\)</span>来实例化假设中的<span class="math">\(n\)</span>。</p>

<pre><code>theorem Not_Even_two_mul_add_one (m n : N)
    (hm : m = 2 * n + 1) :
    \sim Even m :=
    by
    intro h
    induction h generalizing n with
    | zero =&gt; linarith
    | add_two k hk ih =&gt;
        apply ih (n - 1)
        cases n with
</code></pre>
<p>综合以上所有内容，我们得出</p>

<p>| zero =&gt; 使用 [Nat.ctor_eq_zero] 对所有假设进行简化
| succ n' =&gt;
使用 [Nat.succ_eq_add_one] 对所有假设进行简化
随后调用线性算术策略
我们运用定理 Nat.succ_eq_add_one 将 Nat.succ n 形式的项重写为<span class="math">\(\mathrm{n}+1\)</span>，并通过 linarith 策略执行基础算术推理。当遇到 Nat.succ 与加法混合运算时，该定理尤为实用。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">funext</th>
  <th style="text-align:left">functional extensionality</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">propext</td>
  <td style="text-align:left">propositional extensionality</td>
</tr>
</tbody>
</table>

<h3>6.8 新引入的Lean结构总结</h3>
<h4>定理</h4>
<h4>策略</h4>
<p>linarith调用线性算术推理过程</p>


<h2>第七章：带效应的函数式编程</h2>
<p>纯函数式编程有时会显得过于受限。带效应的函数式编程提供了一些惯用法来缓解这些限制，让我们能够以带有副作用、异常、非确定性以及其他效应的方式进行编程。</p>


<p>其底层抽象称为单子(monad)。单子将带有副作用的程序泛化。在Haskell中，单子常用于编写命令式程序；而在Lean中，它们既用于表达命令式程序，也用于相关推理。正如我们将在第8章看到的，单子甚至对Lean自身的编程也很有用。</p>

<p>这些笔记的灵感来源于《Lean编程》第七章。同时我们参考了《Real World Haskell》第十四章中关于效应式函数式编程的通用介绍。</p>

<h3>7.1 入门示例</h3>
<p>考虑以下编程任务：
实现一个函数 sum257 ns，用于计算自然数列表 ns 中第二、第五和第七项的总和。使用 Option N 作为返回类型，以便在列表项数不足时返回 Option.none。</p>

<pre><code>def nth { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; Nat -&gt; Option }\alpha
    | [], _ =&gt; Option.none
    | x :: _, 0 =&gt; Option.some x
    | _ :: xs, n + 1 =&gt; nth xs n
def sum257 (ns : List N) : Option N :=
    match nth ns 1 with
    | Option.none =&gt; Option.none
    | Option.some n 2 =&gt;
        match nth ns 4 with
        | Option.none =&gt; Option.none
        | Option.some n 5 =&gt;
            match nth ns 6 with
            | Option.none =&gt; Option.none
            | Option.some n 7 =&gt; Option.some ( }\mp@subsup{n}{2}{}+\mathrm{n}_{5}+\mathrm{n}_{7}\right)
</code></pre>
<p>一个直接的解决方案如下所示：</p>

<p>（令人困惑的是，nth从0开始计数元素。）这段代码相当不优雅，因为充斥着对option的模式匹配。虽然这个编程任务是人为设计的，但我们都能回想起写过那些嵌套错误处理和不断缩进层级增加的代码。</p>

<pre><code>def connect { }\alpha\mathrm{ : Type} { }\beta\mathrm{ : Type} :
    Option }\alpha\mathrm{ \rightarrow ( }\alpha\mathrm{ \rightarrow Option }\beta\mathrm{ ) }-&gt;\mathrm{ Option }\beta
    | Option.none, _ =&gt; Option.none
    | Option.some a, f =&gt; f a
</code></pre>

<p>我们可以做得更好，通过将丑陋的部分集中到一个函数中：</p>

<pre><code>def sum257Connect (ns : List N) : Option N :=
    connect (nth ns 1)
    (fun n}\mp@subsup{n}{2}{}\mapsto\mathrm{ connect (nth ns 4)
        (fun n}\mp@subsup{n}{5}{}\mapsto\mathrm{ connect (nth ns 6)
        (fun n}\mp@subsup{n}{7}{}\mapsto\mathrm{ Option.some ( }\mp@subsup{n}{2}{}+n
</code></pre>

<p>connect函数作用于一个option类型值。若该值为option.none，则保持原样返回——这对应错误状态，且错误具有"粘性"。否则，当值为option.some a形式时，我们将操作f应用于a（或将f的参数绑定到a）。现在我们可以使用connect来编写求和函数：</p>


<p>直观上，该程序执行以下步骤：</p>
<ol>
<li>使用nth从列表中提取第二项。若该项不存在，nth返回option.none；直接返回该值。否则，将n2绑定至此项并继续下一步。</li>
<li>对第五和第七项执行相同操作，细节相应调整。</li>
<li>将<span class="math">\(n 2, n 5\)</span>和<span class="math">\(n 7\)</span>的和包裹在option.some中返回。</li>
</ol>


<p>从数学角度而言，我们新定义的函数sum257Connect等同于原始函数sum257。</p>

<pre><code>def sum257Bind (ns : List N) : Option N :=
    bind (nth ns 1)
    (fun n}\mp@subsup{n}{2}{}\mapsto\mathrm{ bind (nth ns 4)
        (fun n}\mp@subsup{n}{5}{}\mapsto\mathrm{ bind (nth ns 6)
            (fun n}\mp@subsup{n}{7}{}\mapsto\mathrm{ pure ( }\mp@subsup{n}{2}{}+n
</code></pre>

<p>我们本可以使用Lean预定义的通用bind操作来替代自行定义connect函数。该操作以相同顺序接收相同参数。以下是新代码：</p>


<p>我们还使用预定义的pure函数替代option.some方法，将纯量值<span class="math">\(\alpha\)</span>转换为可选类型<span class="math">\(\alpha\)</span>。</p>

<pre><code>def sum2570p (ns : List N) : Option N :=
    nth ns 1 &gt;&gt;=
    fun n}\mp@subsup{n}{2}{}\mapsto\mathrm{ nth ns 4 &gt;&gt;=
        fun n}\mp@subsup{n}{5}{}\mapsto\mathrm{nth ns 6 &gt;&gt;=
            fun n}\mp@subsup{n}{7}{}\mapsto\mathrm{ pure ( }\mp@subsup{n}{2}{}+n
</code></pre>

<p>使用预定义bind的优势之一在于它提供了语法糖，即<span class="math">\(&gt;&gt;=\)</span>运算符的形式：</p>

<pre><code>def sum257Dos (ns : List N) : Option N :=
    do
    let }\mp@subsup{n}{2}{}\leftarrow\mathrm{ nth ns 1
    do
        let }\mp@subsup{n}{5}{}\leftarrow\mathrm{ nth ns 4
        do
            let }\mp@subsup{n}{7}{}\leftarrow\mathrm{ nth ns 6
            pure ( }\mp@subsup{n}{2}{}+{ }_{5}{}+{ }_{7}{}\)
</code></pre>

<p>语法结构 oa <span class="math">\(&gt;&gt;=\)</span> f 展开为 bind oa <span class="math">\(f\)</span>，其中 oa 的类型为 Option <span class="math">\(\alpha\)</span>。倒数第二个版本的求和程序使用了更重量级的语法糖：</p>


<p>do表示法为带效用的程序提供了一种便捷语法。程序do let a <span class="math">\(\leftarrow\)</span> oa ... 等价于oa <span class="math">\(\gg&gt;=\)</span> (fun a <span class="math">\(\mapsto \ldots\)</span> )。若我们对oa的计算结果不感兴趣，可省略let a <span class="math">\(\leftarrow\)</span> 绑定，直接写作do oa ...，这会展开为oa <span class="math">\(\gg&gt;=\)</span> (fun <span class="math">\(\_\)</span> <span class="math">\(\mapsto \ldots\)</span> )。</p>

<pre><code>def sum257Do (ns : List N) : Option N :=
    do
    let n}\mp@subsup{n}{2}{}\leftarrow\mathrm{ nth ns 1
    let n}\mp@subsup{n}{5}{}\leftarrow\mathrm{ nth ns 4
    let n}\mp@subsup{n}{7}{}\leftarrow\mathrm{ nth ns 6
    pure ( }\mp@subsup{n}{2}{}+{ }_{5}{}+{ }_{7}{}\)
</code></pre>

<p>do表示法可便捷地在单个代码块中实现多个let绑定，这使我们得到程序的最终版本：</p>


<p>每个带有箭头<span class="math">\(\leftarrow\)</span>的行都会尝试读取一个值。若读取失败，整个程序将求值为option.none。</p>


<p>上述函数可解读为一个命令式程序，其中每次第n次调用都可能抛出异常。但尽管该表示法带有命令式风格，该函数实则是一个纯函数式程序。</p>

<div class="math">$$
\begin{gathered}
\text { pure }\{\alpha: \text { Type }\}: \alpha \rightarrow \mathrm{m} \alpha \\
\text { bind }\{\alpha \beta: \text { Type }\}: \mathrm{m} \alpha \rightarrow(\alpha \rightarrow \mathrm{~m} \beta) \rightarrow \mathrm{m} \beta
\end{gathered}
$$</div>

<h3>7.2 两种操作与三条法则</h3>
<p>可选类型构造子是单子（monad）的一个实例，称为可选单子。一般而言，单子是一个一元类型构造子<span class="math">\(m\)</span>：Type <span class="math">\(\rightarrow\)</span> Type，它依赖于某个类型参数<span class="math">\(\alpha\)</span>，并配备两种特定操作：</p>


<p>按照惯例，花括号表示隐式参数。对于选项类型，pure操作即为option.some，而bind操作相当于我们的connect。</p>


<p>类型为<span class="math">\(m \alpha\)</span>的值代表一个具有副作用的程序。纯操作(pure operation)将一个无副作用的纯程序（类型为<span class="math">\(\alpha\)</span>）嵌入到<span class="math">\(m \alpha\)</span>中。绑定操作(bind operation)将两个具有副作用的程序（类型分别为<span class="math">\(m \alpha\)</span>和<span class="math">\(m \beta\)</span>）组合起来：第一个程序的输出（类型为<span class="math">\(\alpha\)</span>）会传递给第二个程序，而第二个程序的输出即为组合程序的最终输出。</p>


<p>我们可以将单子(monad)视为一个包含数据的盒子。这个盒子封装了某种特殊效应（例如异常、可变状态等）。pure操作将数据放入盒中，而bind操作则允许我们访问盒中数据并修改它——甚至可能改变其类型，因为结果类型是<span class="math">\(m \beta\)</span>而非<span class="math">\(m \alpha\)</span>。但通常无法从盒中提取数据——即无法从<span class="math">\(m \alpha\)</span>获得<span class="math">\(\alpha\)</span>。盒中可能不存在任何<span class="math">\(\alpha\)</span>值，也可能存在多个。总结来说，pure a是一个仅包含值a且无效应的盒子；而bind ma f（也可写作ma &gt;&gt;= f 或 do a <span class="math">\(\leftarrow \mathrm{ma}, \mathrm{f}\)</span> a）会先执行ma，然后用ma解包后的结果a执行f。习惯上使用ma或mb表示类型为<span class="math">\(m \alpha\)</span>或<span class="math">\(m \beta\)</span>的盒装值，用<span class="math">\(a\)</span>或<span class="math">\(b\)</span>表示类型为<span class="math">\(\alpha\)</span>或<span class="math">\(\beta\)</span>的数据。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">Type</th>
  <th style="text-align:left">Effect</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">id</td>
  <td style="text-align:left">no effects</td>
</tr>
<tr>
  <td style="text-align:left">Option</td>
  <td style="text-align:left">simple exceptions</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto \sigma \rightarrow \alpha \times \sigma\)</span>
</td>
  <td style="text-align:left">threading through a state of type <span class="math">\(\sigma\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">Set</td>
  <td style="text-align:left">nondeterministic computations returning <span class="math">\(\alpha\)</span> values</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto t \rightarrow \alpha\)</span>
</td>
  <td style="text-align:left">reading elements of type <span class="math">\(t\)</span> (e.g., a configuration)</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto \mathbb{N} \times \alpha\)</span>
</td>
  <td style="text-align:left">adjoining running time (e.g., to model time complexity)</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto\)</span> String <span class="math">\(\times \alpha\)</span>
</td>
  <td style="text-align:left">adjoining text output (e.g., for logging)</td>
</tr>
<tr>
  <td style="text-align:left">IO</td>
  <td style="text-align:left">interaction with the operating system</td>
</tr>
<tr>
  <td style="text-align:left">TacticM</td>
  <td style="text-align:left">interaction with the proof assistant</td>
</tr>
</tbody>
</table>

<p>单子是一个具有多种应用的抽象概念。Option类型只是众多实例中的一种。下表概述了一些单子实例及其效应。</p>


<p>上述所有实例均为一元类型构造器m : Type <span class="math">\(\rightarrow\)</span> Type。部分效果可被组合（例如函子<span class="math">\(\alpha \mapsto\)</span> Option ( <span class="math">\(t \rightarrow \alpha\)</span> )）。某些效果不可执行（如Set），但在抽象建模程序时仍具实用价值。特定类型构造器<span class="math">\(m\)</span>可能提供超越pure和bind的额外运算符，例如可能提供提取封装值的方法。</p>


<p>单子（Monad）具有多重优势。它们提供了高度可读的do表示法，支持通用操作，例如List.mmap <span class="math">\(\{\alpha \beta\)</span> : Type <span class="math">\(\}:(x \rightarrow m \beta) \rightarrow\)</span> List <span class="math">\(\alpha \rightarrow m\)</span> (List <span class="math">\(\beta\)</span> )，这种操作能统一适用于所有单子m。如《Lean编程》所述：</p>


<p>这种抽象的强大之处不仅在于它提供了可用于所有这些不同实例的通用函数和符号表示法，更在于它提供了一种有助于理解它们共性的思维方式。</p>


<p>除了作为计算机科学中的实用概念外，单子（monad）还为公理化推理提供了一个绝佳范例。</p>

<div class="math">$$
\begin{aligned}
&amp; \text { do } \\
&amp; \text { let } a^{\prime} \leftarrow \text { pure a } \quad=\quad f a \\
&amp; f a^{\prime}
\end{aligned}
$$</div>

<p>绑定操作和纯操作通常需要遵循三条定律。绑定操作将两个程序组合起来。如果其中一个是纯程序，我们可以将其内联并消除绑定。这就得到了前两条定律：</p>

<div class="math">$$
\begin{aligned}
&amp; \text { do } \\
&amp; \text { let } a \leftarrow \mathrm{ma} \quad=\quad \mathrm{ma} \\
&amp; \text { pure a }
\end{aligned}
$$</div>

<p>以及</p>

<table>
<thead>
<tr>
  <th style="text-align:center">do</th>
  <th style="text-align:center"></th>
  <th style="text-align:center"></th>
  <th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center">let b <span class="math">\(\leftarrow\)</span>
</td>
  <td style="text-align:center"></td>
  <td style="text-align:center">do</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">do</td>
  <td style="text-align:center"></td>
  <td style="text-align:center">let a <span class="math">\(\leftarrow\)</span> ma</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">let a <span class="math">\(\leftarrow\)</span> ma</td>
  <td style="text-align:center"><span class="math">\(=\)</span></td>
  <td style="text-align:center">let <span class="math">\(b \leftarrow f a\)</span>
</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">f a</td>
  <td style="text-align:center"></td>
  <td style="text-align:center">g b</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">g b</td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
</tr>
</tbody>
</table>

<p>第三条定律是bind操作的结合律。它允许我们将嵌套的计算扁平化：</p>

<p>此前我们将单子比作盒子。更具体地将其想象为瑞士银行账户可能有助于理解，其中<span class="math">\(\alpha:=\)</span>代表资金。第一定律意味着如果你将资金存入账户，你可以随时取出。第二定律表示若你取出资金后又立即存回，系统不会察觉。第三定律则说明：将两个银行操作合并执行后再进行第三个操作，与先执行第一个操作再执行剩余两个操作是等效的。鉴于瑞士银行以保密性著称，这三条定律都显得合情合理。</p>

<h3>7.3 类型类</h3>
<p>单子(Monad)是一种数学结构，因此我们使用类型类在Lean中对其进行规范。需知类型类是一种参数化的结构类型，通常由类型参数化，但此处由类型构造器<span class="math">\(m\)</span> : Type <span class="math">\(\rightarrow\)</span> Type参数化。当我们在具体<span class="math">\(m\)</span>上使用类型类的字段时，类型类推断机制会检索相关的结构值——即类型类实例。</p>

<pre><code>class LawfulMonad (m : Type <span class="math">\(\rightarrow\)</span> Type)
    extends Pure m, Bind m where
    pure_bind <span class="math">\(\{\alpha \beta\)</span> : Type <span class="math">\(\}(\mathrm{a}: \alpha)(\mathrm{f}: \alpha \rightarrow \mathrm{m} \beta)\)</span> :
        (pure a <span class="math">\(\gg&gt;=\mathrm{f})=\mathrm{f}\)</span> a
    bind_pure <span class="math">\(\{\alpha\)</span> : Type <span class="math">\(\}(\)</span> ma : <span class="math">\(\mathrm{m} \alpha)\)</span> :
        (ma &gt;&gt;= pure) <span class="math">\(=\)</span> ma
    bind_assoc <span class="math">\(\{\alpha \beta \gamma\)</span> : Type <span class="math">\(\}(f: \alpha \rightarrow m \beta)(\mathrm{g}: \beta \rightarrow \mathrm{m} \gamma)\)</span>
        (ma : <span class="math">\(m \alpha\)</span> ) :
        <span class="math">\(((\)</span> ma <span class="math">\(\gg&gt;=f) \gg&gt;=g)=(\mathrm{ma} \gg&gt;=(\mathrm{fun} \mathrm{a} \mapsto \mathrm{f} \mathrm{a} \gg&gt;=g))\)</span>
</code></pre>
<p>以下是单子(Monad)及其三条定律在Lean中的可能定义：</p>
<p>让我们逐步解析这个定义：</p>
<ul>
<li>我们正在创建一个由一元类型构造器m参数化的结构——即一个类型为Type <span class="math">\(\rightarrow\)</span> Type的值。</li>
<li>该结构继承自名为Pure和Bind结构的字段及任何语法糖。这些结构提供了m上的pure和bind操作，包含预期的类型和语法糖。</li>
<li>最后，在Pure和Bind已提供的字段基础上，新增三个字段（pure_bind、bind_pure和bind_assoc）。每个字段都是三条定律之一的证明。</li>
</ul>
<p>我们将该类型类命名为LawfulMonad，因为必须满足这三条定律。要实例化此定义，我们需要提供类型构造器m、合适的bind和pure运算符，以及这些定律的证明。</p>

<p>Lean包含其自身的单子概念，同样称为LawfulMonad。它与我们的定义大致等效，但分散在多个类型类中。</p>


<h3>7.4 无副作用</h3>
<p>在本节及7.5至7.7节中，我们将回顾特定单子提供的各类副作用。首先讨论恒等单子，它完全不提供任何特殊副作用。</p>

<pre><code>def id.pure { }\alpha\mathrm{ : Type} : \alpha-&gt;\mathrm{ id }\alpha
    | a =&gt; a
def id.bind { }\alpha\beta\mathrm{ : Type} : id }\alpha-&gt;(\alpha-&gt;\mathrm{ id }\beta)-&gt;\mathrm{ id }\beta
    | a, f =&gt; f a
instance id.LawfulMonad : LawfulMonad id :=
    { pure := id.pure
        bind := id.bind
        pure_bind :=
            by
                intro }\alpha\beta\mathrm{ a f
            rfl
        bind_pure :=
            by
                intro }\alpha\mathrm{ ma
            rfl
        bind_assoc :=
            by
                intro }\alpha\beta\gamma\mathrm{ f g ma
            rfl }
</code></pre>
<p>Lean的常量id <span class="math">\(\{\alpha\)</span> : Type <span class="math">\(\}: \alpha \rightarrow \alpha\)</span>被定义为恒等函数fun <span class="math">\(x \mapsto x\)</span>。通过取<span class="math">\(\alpha:=\)</span> Type可获得恒等类型构造器。我们可以将其注册为单子：</p>

<p>注册过程需要我们提供五个组件：纯操作和绑定操作，以及三条定律的证明。</p>


<p>恒等单子是最简单的单子结构。它提供了一个仅包含单一值的简单容器，不产生任何附加效应。其作用类似于加法算术中的零元素。我们可以将其他单子视为其变体；例如，可选单子就是在恒等单子基础上扩展了一个特殊的Option.none值，用于表示错误状态。</p>

<pre><code>def Option.pure { }\alpha\mathrm{ : Type} : \alpha-&gt;\mathrm{ Option }\alpha\mathrm{ :=
    Option.some
def Option.bind { }\alpha\beta\mathrm{ : Type} :
    Option }\alpha\mathrm{ -&gt; ( }\alpha\mathrm{ -&gt; Option }\beta\mathrm{ ) -&gt; Option }\beta
    | Option.none, _ =&gt; Option.none

    | Option.some a, f =&gt; f a
instance Option.LawfulMonad : LawfulMonad Option :=
    { pure := Option.pure
        bind := Option.bind
        pure_bind :=
            by
            intro }\alpha\beta\mathrm{ a f
            rfl
    bind_pure :=
        by
            intro }\alpha\mathrm{ ma
            cases ma with
            | none =&gt; rfl
            | some _ =&gt; rfl
    bind_assoc :=
        by
            intro }\alpha\beta\gamma\mathrm{ f g ma
            cases ma with
            | none =&gt; rfl
            | some _ =&gt; rfl }
</code></pre>

<h3>7.5 基础异常处理</h3>
<p>如前所述，选项类型提供了一种基础的异常机制。以下代码展示了如何将 Option : Type <span class="math">\(\rightarrow\)</span> Type 注册为合法的单子：</p>

<pre><code>def Option.throw { }\alpha\mathrm{ : Type} : Option \alpha :=
    Option.none
def Option.catch { }\alpha\mathrm{ : Type} : Option \alpha \rightarrow Option \alpha \rightarrow Option \alpha
    | Option.none, ma' =&gt; ma'
    | Option.some a, _ =&gt; Option.some a
</code></pre>

<p>这三个证明过程都很直接。除了标准操作外，抛出和捕获异常的功能也很有用。具体实现方式如下：</p>

<p>Option.throw操作会抛出异常，使程序进入错误状态（Option.none）。Option.catch操作可用于从先前的异常中恢复。若程序当前处于错误状态，option.catch会调用异常处理代码（其第二个参数）。该代码可能继而引发新的异常。若将Option.catch应用于正常状态（形式为Option.some a），则不会执行任何操作。</p>
<pre><code>do
    ~..
    if ... then
        Option.throw
    else
        ...
    .catch do
    ...
</code></pre>

<p>作为Option.catch ma ma'的便捷替代方案，Lean支持ma.catch ma'语法。以下是通过该语法演示抛出和捕获异常的示意性示例：</p>

<pre><code>try {
    ...
    if (...) {
        throw new UnknownException();
    } else {
        ...
    }
} catch (UnknownException e) {
    ...
}
</code></pre>

<p>对应的Java代码如下所示：</p>

<p>选项仅能处理单一类型的错误状态。一种更通用的抽象称为错误单子（error monad），可支持多种错误类型，类似于Java等编程语言中的异常机制。</p>
<h3>7.6 可变状态</h3>
<p>状态单子提供了一种对应于可变状态的抽象。对于某些编程语言，编译器能够检测状态单子的使用，并将使用它们的程序翻译为更高效的命令式程序。</p>
<pre><code>def welcomeNewUser (userName : String) (ctxt : Context) :
    (N}\times\mathrm{ String) \times Context :=
    let
        (user, ctxt') := createUser userName ctxt
        (password, ctxt'') := generateTemporaryPassword user ctxt'
        (ok, ctxt''') := sendUnencryptedEmail user password ctxt''
    in
        ((user, password), ctxt''')
</code></pre>
<p>必须承认，"对应可变状态的抽象"这一说法可能听起来有些抽象，因此让我们考虑一个半具体的例子。如果您有函数式编程经验，很可能在某些场合写过与下面这段代码非常相似的代码：</p>

<p>（通过未加密邮件发送密码并忽略函数的ok状态是极其危险的做法。）该函数接收某些全局状态或上下文作为输入，依次调用三个函数，每个函数都接收上下文值并返回若干数据及一个新上下文。上下文实际上以线程式贯穿整个程序。这使得我们能在无副作用的编程语言中实现可变状态。</p>

<pre><code>def welcomeNewUserDo (userName : String) :
    Context }-&gt;\mathrm{ (N} \times\mathrm{ String) } \times\mathrm{ Context :=
    do
        let user \leftarrow createUser userName
        let password \leftarrow generateTemporaryPassword user

    let ok \leftarrow sendUnencryptedEmail user password
pure (user, password)
</code></pre>

<p>上述方法容易出错——稍不留神就会漏掉一个撇号（'），从而将错误的上下文传递给函数。代码也因所有上下文变量而显得杂乱。如果我们能直接写成下面这样呢？</p>

<pre><code>def Action ( }\sigma\alpha\mathrm{ : Type) : Type :=
    }\sigma\mathrm{ \rightarrow \alpha \times \sigma
</code></pre>

<p>这正是状态单子所提供的功能。状态单子建立在二元类型构造器Action之上，该构造器封装了针对类型为<span class="math">\(\sigma\)</span>的状态进行计算或操作的概念，并返回类型为<span class="math">\(\alpha\)</span>的值。在Lean中，Action <span class="math">\(\sigma \alpha\)</span>被定义为等同于<span class="math">\(\sigma \rightarrow \alpha \times \sigma:^{1}\)</span>。</p>


<p>（由于类型本身也是项，我们同样可以使用def来定义类型别名。）对于给定类型<span class="math">\(\sigma\)</span>，Action <span class="math">\(\sigma\)</span> : Type <span class="math">\(\rightarrow\)</span> Type 构成一个单子。该类型<span class="math">\(\sigma\)</span>抽象了具体的内存布局——例如我们可以用元组或列表来表示内存，并相应地实例化这个抽象状态<span class="math">\(\sigma\)</span>。</p>


<p>有状态动作是一个接收某些状态并返回一个值及新状态的函数。Action定义中的<span class="math">\(\sigma \rightarrow\)</span>部分表示旧状态；笛卡尔积的左分量<span class="math">\(\alpha\)</span>表示计算结果；右分量<span class="math">\(\sigma\)</span>则表示新状态。因此，状态会隐式地在程序中传递。与其他带副作用的程序类似，do表示法仅暴露数据（类型为<span class="math">\(\alpha\)</span>的值），而隐藏了副作用（新旧<span class="math">\(\sigma\)</span>状态）。</p>


<p>当<span class="math">\(\sigma:=\)</span> Unit时（Unit是一个基数为1的类型，类似于C或Java中的void，其唯一值写作( )），这种情况对应于恒等单子：类型Unit <span class="math">\(\rightarrow \alpha \times\)</span> Unit与<span class="math">\(\alpha\)</span>同构。这一直观理解可以指导我们定义pure和bind操作。</p>

<pre><code>def Action.read { }\sigma\mathrm{ : Type} : Action \sigma\sigma
    | s =&gt; (s, s)
def Action.write { }\sigma\mathrm{ : Type} (s : \sigma)\mathrm{ : Action \sigma Unit
    | _ =&gt; ((), s)
def Action.pure { }\sigma\alpha\mathrm{ : Type} (a : \alpha)\mathrm{ : Action \sigma\alpha
    | s =&gt; (a, s)
def Action.bind { }\sigma\mathrm{ : Type} { }\alpha\beta\mathrm{ : Type} (ma : Action \sigma\alpha)
            (f : }\alpha\mathrm{ \rightarrow Action \sigma\beta):
        Action \sigma\beta
    | s =&gt;
        match ma s with
        | (a, s') =&gt; f a s'
</code></pre>

<p>我们首先定义基本操作：两个用于访问内存的读写操作，以及标准操作bind与pure：</p>

<p>读取操作简单地返回当前状态<span class="math">\(s\)</span>（作为序对的第一分量）并保持状态不变（作为序对的第二分量）。写入操作将当前状态替换为<span class="math">\(s\)</span>并返回空值( )。pure操作保持当前状态<span class="math">\(s\)</span>不变，仅将其与给定值a组成序对。bind操作将初始状态传递给ma参数，产生结果a和新状态s'，这些值随后被传递给<span class="math">\(f\)</span>函数，该函数返回新的计算结果和更新后的状态。</p>
<pre><code>instance Action.LawfulMonad {\sigma: Type} :
    LawfulMonad (Action \sigma) :=
    { pure := Action.pure
        bind := Action.bind
        pure_bind :=
            by
            intro <span class="math">\(\alpha \beta\)</span> a f
            rfl
    bind_pure :=
        by
            intro <span class="math">\(\alpha\)</span> ma
            rfl
    bind_assoc :=
        by
            intro <span class="math">\(\alpha \beta \gamma\)</span> f g ma
            rfl }
</code></pre>

<p>要将Action类型构造器注册为合法的单子，我们需如先前一样证明三条定律：</p>

<pre><code>def increasingly : List N -&gt; Action N (List N)
    | [] =&gt; pure []
    | (n :: ns) =&gt;
        do
            let prev \leftarrow Action.read
            if n &lt; prev then
                increasingly ns
            else
                do
                    Action.write n
                    let ns' \leftarrow increasingly ns
                    pure (n :: ns')
</code></pre>
<p>具体而言，以下程序会移除列表中所有小于前一个元素的元素，从而得到一个递增元素列表。最大元素被存储为状态<span class="math">\(\sigma\)</span>。请注意状态是如何通过读写操作进行访问的。</p>
<pre><code>#eval increasingly [1, 2, 3, 2] 0
#eval increasingly [1, 2, 3, 2, 4, 5, 2] 0
</code></pre>

<p>要执行该程序，必须提供初始状态。最终状态将与结果列表一同返回，它对应于列表中遇到的最大元素或起始状态。因此，以下命令</p>

<div class="math">$$
\begin{aligned}
&amp; ([1,2,3], 3) \\
&amp; ([1,2,3,4,5], 5)
\end{aligned}
$$</div>

<p>产生输出结果</p>


<h3>7.7 非确定性</h3>
<p>选项单子（option monad）存储零个或一个<span class="math">\(\alpha\)</span>值，恒等单子（identity monad）和状态单子（state monad）严格存储一个值，而集合单子（set monad）则可能存储无限多个值。这种特性可用于建模非确定性，即表示一组可能的行为集合。</p>

<p>Lean中的Set类型<span class="math">\(\alpha\)</span>被定义为<span class="math">\(\alpha \rightarrow\)</span> Prop。换言之，集合由其特征谓词所标识。支持常见的运算符如空集<span class="math">\((\emptyset)\)</span>、全集(Set.univ)、并集<span class="math">\((\cup)\)</span>、交集<span class="math">\((\cap)\)</span>和属于关系<span class="math">\((\in)\)</span>，以及传统的大括号表示法如<span class="math">\(\{a\},\{a, b\}\)</span>和<span class="math">\(\{x \mid\)</span> <span class="math">\(P \times\}\)</span>。许多集合构造可通过simp进行简化。</p>
<pre><code>def Set.pure { }\alpha\mathrm{ : Type} : \alpha \rightarrow \text { Set }\alpha
    | a =&gt; {a}
def Set.bind { }\alpha\beta\mathrm{ : Type} : Set }\alpha\mathrm{ \rightarrow ( }\alpha\mathrm{ \rightarrow Set }\beta\mathrm{ ) } \rightarrow \text { Set }\beta
    | A, f =&gt; {b | | |a, a \in A \wedge b \in f a}
instance Set.LawfulMonad : LawfulMonad Set :=
    { pure := Set.pure
        bind := Set.bind
        pure_bind :=
            by
            intro }\alpha\beta\mathrm{ a f
            simp [Pure.pure, Bind.bind, Set.pure, Set.bind]
    bind_pure :=
        by
            intro }\alpha\mathrm{ ma
            simp [Pure.pure, Bind.bind, Set.pure, Set.bind]
    bind_assoc :=
        by
            intro }\alpha\beta\mathrm{ \gamma f g ma
            simp [Pure.pure, Bind.bind, Set.pure, Set.bind]
            apply Set.ext
            aesop }
</code></pre>

<p>Set类型构造器可按如下方式注册为合法单子：</p>


<p>pure操作简单地将给定值a放入单例集合<span class="math">\(\{\mathrm{a}\}\)</span>中。bind操作会对集合<span class="math">\(A\)</span>中的所有值调用<span class="math">\(f\)</span>，并返回所有结果的并集。例如，若<span class="math">\(A:=\{3,8\}\)</span>且<span class="math">\(f:=\)</span> (fun a <span class="math">\(\mapsto\{a \cdot 1, a \cdot 2\}\)</span> )，则Set.bind A f的结果为<span class="math">\(\{4,5,9,10\}\)</span>。</p>


<p>请注意，在这三个证明中，我们都先展开了泛型pure和bind常量的定义，随后是Set.pure和Set.bind的定义。</p>


<p>最后一个证明依赖于集合外延性公理，该公理指出包含相同元素的两个集合必须相等：</p>

<div class="math">$$
\begin{aligned}
&amp; \forall x, x \in b|\exists a,(\exists a \_1, a \_1 \in m a \wedge a \in f a \_1) \wedge b \in g a \\
&amp; \quad \leftrightarrow x \in b \mid \exists a, a \in m a \wedge \exists a \_1, a \_1 \in f a \wedge b \in g a \_1
\end{aligned}
$$</div>

<p>集合外延性原理Set.ext <span class="math">\(\{\alpha\)</span> : 类型 <span class="math">\(\}\{A B:\)</span> 集合 <span class="math">\(\alpha\}:(\forall x, x \in A \leftrightarrow x \in B) \rightarrow A=B\)</span>。另一个值得注意的点是使用了aesop策略。该目标的核心在于</p>


<p>其中<span class="math">\(\leftrightarrow\)</span>符号的两侧内容完全相同，除了存在量词的位置差异（以及令人困惑的约束变量命名差异）。这个冗赘的命题本可以通过一系列繁琐的引入和消解规则来证明，但我们理应获得更高效的自动化支持。</p>


<h3>7.8 Aesop策略</h3>
<h4>aesop</h4>
<p>aesop策略全称为"自动化可扩展显式证明搜索"，是一种通用型证明搜索策略。其功能包括消除假设中的逻辑符号<span class="math">\(\wedge, \vee, \leftrightarrow\)</span>和<span class="math">\(\exists\)</span>，引入目标中的<span class="math">\(\wedge, \leftrightarrow\)</span>和<span class="math">\(\exists\)</span>，并会定期调用simp。该策略可能成功证明目标、完全失败或部分成功，将未完成的子目标留给用户处理。</p>

<pre><code>def nthsFine { }\alpha\mathrm{ : Type} (xss : List (List }\alpha\mathrm{ ) (n : N) :
    List (Option }\alpha\mathrm{ ) :=
    List.map (fun xs }\mapsto\mathrm{ nth xs n) xss
</code></pre>

<h3>7.9 通用算法：列表迭代</h3>
<p>假设我们使用map函数对列表中的所有元素应用一个具有副作用效应的函数<span class="math">\(f\)</span>。这样我们将得到一个由带效应值组成的常规列表。例如：</p>

<pre><code>#eval nthsFine [[11, 12, 13, 14], [21, 22, 23]] 2
</code></pre>

<p>函数nthsFine xss n尝试从xss中的每个列表中提取第<span class="math">\((n+1)\)</span>个元素。运行</p>

<pre><code>def mmap {m : Type }-&gt;\mathrm{ Type} [LawfulMonad m] { }\alpha\beta\mathrm{ : Type}
    (f : }\alpha\mathrm{ \rightarrow m \beta) :
    List }\alpha\mathrm{ \rightarrow m (List }\beta\mathrm{ )
    | [] =&gt; pure []
    | a :: as =&gt;
        do
            let b \leftarrow f a
            let bs \leftarrow mmap f as
            pure (b :: bs)
</code></pre>

<p>返回 [Option.some 13, Option.some 23]。这些 Option.some 构造器可能带来不便。通常，我们只关心是否出现错误。这引出了最后一个示例：一个通用的带效应程序 mmap，它遍历列表并对每个元素应用带效应函数<span class="math">\(f\)</span>。该定义采用递归形式：</p>


<p>注意该函数返回的是包含列表的单个<span class="math">\(m\)</span>值，而非<span class="math">\(m\)</span>值的列表。请尝试理解为何这种类型定义是合理的，并能产生预期行为。</p>

<pre><code>def nthsCoarse { }\alpha\mathrm{ : Type} (xss : List (List }\alpha\mathrm{ ) (n : N) :
    Option (List }\alpha\mathrm{ ) :=
    mmap (fun xs }\mapsto\mathrm{ nth xs n) xss
</code></pre>

<p>我们现在可以尝试使用mmap替代List.map：</p>

<pre><code>theorem mmap_append \{m : Type <span class="math">\(\rightarrow\)</span> Type\} [LawfulMonad m]
    <span class="math">\(\{\alpha \beta\)</span> : Type \} (f : <span class="math">\(\alpha \rightarrow \mathrm{m} \beta\)</span> ) :
    Yas as' : List <span class="math">\(\alpha\)</span>, mmap f (as ++ as') =
        do
            let bs <span class="math">\(\leftarrow\)</span> mmap f as
            let bs' <span class="math">\(\leftarrow\)</span> mmap f as'
            pure (bs ++ bs')
    | [], _ =&gt;
    by simp [mmap, LawfulMonad.bind_pure, LawfulMonad.pure_bind]
    | a :: as, as' =&gt;
    by simp [mmap, mmap_append _ as as', LawfulMonad.pure_bind,
        LawfulMonad.bind_assoc]
</code></pre>

<p>执行
#eval nthsCoarse [[11, 12, 13, 14], [21, 22, 23]] 2
返回 Option.some [13, 23]，即单个 Option.some 包裹纯列表。
mmap 函数对追加运算符 ++ 满足分配律。do 符号不仅可用于定义函数，还能用于表述其性质：</p>


<h3>7.10 新引入的Lean结构摘要</h3>
<h4>符号表示</h4>
<p>do  表示一个带效程序的开始
let ... <span class="math">\(\leftarrow\)</span>...  在带效程序中分配变量
&gt;&gt;=  组合带效计算</p>


<h4>定理</h4>
<p>Set.ext 集合外延性原理</p>


<h4>策略</h4>
<p>aesop 通过通用搜索程序来证明命题</p>


<h2>第8章：元编程</h2>
<p>与大多数证明助手类似，Lean可以通过自定义策略和其他功能进行扩展。对Lean本身进行编程（而非仅使用它）被称为元编程。Lean的元编程框架主要采用与Lean输入语言相同的概念和语法，因此我们无需学习另一种语言即可为Lean编程。其中使用了单子（Monad）来访问Lean的状态。</p>

<p>以归纳类型呈现的抽象语法树反映了内部数据结构。我们可以通过Lean函数访问证明助理的内部机制，这些函数可用于获取当前目标、统一项、查询和修改全局上下文以及设置属性（例如@[simp]）。</p>

<p>以下是元编程的一些应用示例：</p>
<ul>
<li>目标转换（例如应用安全引入规则、将目标转化为否定范式）；</li>
<li>启发式证明搜索（例如通过回溯应用非安全引入规则）；</li>
<li>决策过程（例如用于线性算术、命题逻辑）；</li>
<li>定义生成器（例如为归纳类型实现Haskell风格的派生功能）；</li>
<li>顾问工具（例如定理查找器、反例生成器）；</li>
<li>导出工具（例如文档生成器）；</li>
<li>特殊用途的证明自动化（避免样板代码或重复）。</li>
</ul>


<p>正如数学家兼Lean用户凯文·巴扎德所写：<span class="math">\({ }^{1}\)</span>如果你发现自己正在"刷经验"（借用电子游戏术语），反复进行同类操作以推动进度，那么你可以尝试说服计算机科学家为你编写一个策略（tactic）来完成这项工作——或者如果你足够勇敢去写元Lean代码，甚至可以自己编写策略。</p>


<h3>8.1 策略组合子</h3>
<p>首先明确术语：若应用策略时产生错误则称为失败；否则称为成功。策略成功的一种方式是完整证明目标，另一种是生成替代当前目标的新子目标。有些策略会以"无操作"的形式成功。</p>

<pre><code>theorem repeat'_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        repeat' apply Even.add_two
</code></pre>

<p>在编写自定义策略时，我们经常需要对多个目标重复某些操作，或在策略失败时进行恢复。策略组合器在此类场景中非常有用。其中最实用的策略组合器之一是repeat' tactic。它会在所有目标上重复调用策略，然后在新生子目标上继续调用，接着在新生子子目标上调用，如此循环直至策略在所有可用目标上均失败。以下是一个涉及第6章介绍的Even谓词的repeat'示例：</p>

<div class="math">$$
\vdash \text { Even } 4 \quad \vdash \text { Even } 7 \quad \vdash \text { Even } 3 \quad \vdash \text { Even } 0
$$</div>

<p>在第一个repeat'行之后，证明状态包含四个目标：</p>

<div class="math">$$
\vdash \text { Even } 0 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 0
$$</div>

<p>注意所有合取项都已消失。第二个repeat'循环应用定理Even.add_two：<span class="math">\(\forall \mathrm{k}\)</span>, Even <span class="math">\(\mathrm{k} \rightarrow\)</span> Even <span class="math">\((\mathrm{k}+2\)</span> )，经过反复应用后，我们得到以下目标：</p>

<pre><code>theorem repeat'_first_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        repeat'
            first
            | apply Even.add_two
            | apply Even.zero
</code></pre>

<p>第一个和最后一个目标令人困扰，因为它们对应于定理Even.zero。我们可以通过在应用Even.add_two失败时尝试应用Even.zero来证明它们。具体实现如下：</p>

<div class="math">$$
\vdash \text { Even } 1 \quad \vdash \text { Even } 1
$$</div>

<p>策略组合子first <span class="math">\(\mid\)</span> tactic <span class="math">\(_{1}|\cdots|\)</span> tactic <span class="math">\(_{n}\)</span>会首先尝试执行其第一个参数tactic <span class="math">\(_{1}\)</span>。若失败，则尝试tactic <span class="math">\(_{2}\)</span>，依此类推。若所有指定策略均失败，则整个组合子失败。在上例中，我们仍有两个无法证明的目标：</p>

<pre><code>theorem all_goals_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        all_goals apply Even.add_two -- fails
</code></pre>

<p>下一个组合子all_goals tactic会在每个目标上精确调用一次策略。该组合子仅当策略在所有目标上都成功时才成功。在下面的示例中它会失败，因为Even.add_two无法应用于目标<span class="math">\(\vdash\)</span> Even <span class="math">\(\omega\)</span>：</p>

<pre><code>theorem all_goals_try_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        all_goals try apply Even.add_two
</code></pre>

<p>若要忽略策略的失败情况，可将其包裹在try组合器中：</p>

<div class="math">$$
\vdash \text { Even } 2 \quad \vdash \text { Even } 5 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 0
$$</div>

<p>最终得到的状态是</p>


<p>构造try策略等价于先执行| tactic | skip，其中skip是一个不做任何操作即成功的策略。因此try策略总会成功。相关策略是done：当没有剩余目标时它成功，否则失败。</p>

<pre><code>theorem any_goals_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        any_goals apply Even.add_two
</code></pre>

<p>另一种变体是any_goals策略组合器。它尝试在每个目标上调用一次策略，但与all_goals不同，只要策略在任何目标上成功，它就会成功。示例</p>

<div class="math">$$
\vdash \text { Even } 2 \quad \vdash \text { Even } 5 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 0
$$</div>

<p>得到的状态为</p>

<p>这与前例中的状态相同。一般而言，区别在于any_goals策略可能失败，而all_goals try策略总能成功。</p>
<pre><code>theorem any_goals_solve_repeat_first_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        any_goals
            solve
            | repeat'
                first
                | apply Even.add_two
                | apply Even.zero
</code></pre>

<p>有时我们希望保留目标不作处理，除非能完全证明它。组合子 solve <span class="math">\(\mid\)</span> tactic <span class="math">\(_{1}|\cdots|\)</span> tactic <span class="math">\(_{n}\)</span> 首先尝试执行其第一个参数 tactic <span class="math">\(_{1}\)</span>。若未能证明目标，则尝试 tactic <span class="math">\(_{2}\)</span>，以此类推。如果所有指定策略均未能证明目标，整个组合子将失败。（请将此行为与 first <span class="math">\(\mid\)</span> tactic <span class="math">\(_{1}|\cdots|\)</span> tactic <span class="math">\(_{n}\)</span> 进行对比，后者只需任一指定策略成功即可，不要求必须证明目标。）参考以下示例：</p>

<div class="math">$$
\vdash \text { Even } 7 \quad \vdash \text { Even } 3
$$</div>

<p>第一个和第四个目标得到证明，剩下两个无法证明的目标与定理陈述中的完全一致：</p>

<pre><code>theorem repeat'_Not_example :
    \ Even 1 :=
    by repeat' apply Not.intro
</code></pre>
<p>请注意，repeat'组合子可能导致无限循环。考虑以下示例：</p>

<p>Not.intro规则的格式为( <span class="math">\(? \mathrm{a} \rightarrow\)</span> False <span class="math">\() \rightarrow \neg\)</span> ?a，因此它首先将目标转换为<span class="math">\(\vdash\)</span> Even <span class="math">\(1 \rightarrow\)</span> False。由于<span class="math">\(\neg\)</span> ?a被定义为<span class="math">\(? a \rightarrow\)</span> False，该规则会再次应用，从而产生相同的目标。策略因此陷入循环。</p>

<pre><code>by
    induction n &lt;;&gt;
        aesop
</code></pre>

<p>最后，"然后"操作符&lt;; &gt;可用于连接两个策略。左侧部分会在第一个目标上执行，右侧部分则会在每个新产生的子目标上执行（但不会在原有的第二个目标、第三个目标等上执行）。因此，我们可以这样编写</p>

<pre><code>by
    induction n with
    | zero =&gt; aesop
    | succ n' ih =&gt; aesop
</code></pre>

<p>以替代更冗长的写法</p>

<pre><code>macro "intro_and_even" : tactic =&gt;
    '(tactic|
        (repeat' apply And.intro
        any_goals
            solve
            | repeat'
                first
                | apply Even.add_two
                | apply Even.zero))
</code></pre>
<h3>8.2 宏</h3>
<p>让我们通过编写自定义策略作为宏来进行实际的元编程。该策略体现了我们在上述solve示例中硬编码的行为：</p>

<p>第一行将intro_and_even声明为属于tactic语法范畴的宏。其余行中，'(tactic| tactic)结构将指定的战术tactic嵌入宏中。战术本身使用标准语法进行指定。</p>

<pre><code>theorem intro_and_even_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        intro_and_even
</code></pre>
<p>定义自定义策略后，我们可以在证明中调用它：</p>

<p>这将生成以下子目标</p>


<h3>8.3 元编程单子</h3>
<p>宏是一种可用于编写简单证明自动化的机制。但对于大多数元编程任务，我们需要使用元编程单子MetaM和TacticM。</p>


<p>MetaM融合了多种单子的特性：</p>
<ul>
<li>它是状态单子，提供对全局上下文（包括所有定义和归纳类型）、符号及属性（例如@[simp]定理列表）等的访问。</li>
<li>其行为类似可选单子。元程序失败表示策略执行失败。</li>
<li>支持追踪功能，因此我们可以使用程序logInfo来显示消息。</li>
<li>支持命令式结构，如for-in循环、continue语句和return语句。
TacticM在MetaM基础上扩展了目标管理功能：它提供对目标列表的访问，并允许我们运行Lean来填充表达式中的隐式参数{ }和类型类[ ]参数、展开宏等。</li>
</ul>

<p>在Lean内部，每个目标都表示为一个元变量?m，代表缺失的项（通常是证明项）。每个元变量都有一个类型（通常是一个命题）和一个局部上下文，该上下文指定了可用于证明与该元变量关联目标的变量和假设。</p>
<pre><code>def traceGoals : TacticM Unit :=
    do
        logInfo m!"Lean version {Lean.versionString}"
        logInfo "All goals:"
        let goals \leftarrow getUnsolvedGoals
        logInfo m!"{goals}"
        match goals with
        | [] =&gt; return
        | _ :: _ =&gt;
            logInfo "First goal's target:"
            let target \leftarrow getMainTarget
            logInfo m!"{target}"
elab "trace_goals" : tactic =&gt;
    traceGoals
</code></pre>
<p>让我们通过定义一个使用TacticM追踪功能的策略来实际运用TacticM，该策略会显示Lean版本号、目标列表以及第一个目标（Lean称之为主目标）的靶标：</p>

<p>这段代码具有多个值得注意的特性：</p>
<ul>
<li>首行声明了一个类型为TacticM Unit的函数traceGoals——该类型表示返回Unit（基数为1的平凡类型）的策略。注意元编程函数使用与普通Lean函数相同的语法定义。</li>
<li>第二行进入单子范畴。其余行是访问Lean内部结构的带副作用操作。- m!"..."语法指定了一个字符串模板，其中每个{term}（term为Lean表达式）都会被求值并序列化为字符串。例如若Lean.versionString为"v4.14.0"，则m!"Lean version {Lean. versionString}"会求值为字符串"Lean version v4.14.0"。</li>
<li>最后两行的elab命令指示Lean解析器将"trace_goals"识别为策略。当Lean遇到该策略时，将运行elab命令体中的元程序（此处即traceGoals）。
以下演示如何使用这个新策略：</li>
</ul>

<pre><code>theorem Even_18_and_Even_20 ( <span class="math">\(\alpha\)</span> : Type) (a : <span class="math">\(\alpha\)</span> ) :
    Even <span class="math">\(18 \wedge\)</span> Even <span class="math">\(20:=\)</span>
    by
    apply And.intro
    trace_goals
    intro_and_even
</code></pre>
<pre><code>Lean version v4.14.0
All goals:
[case left
\alpha: Type
a : \alpha
\ Even 18,
    case right
\alpha: Type
a : \alpha
\ Even 20]
First goal's target:
Even 18
</code></pre>

<p>当悬停在trace_goals上时，可见的输出如下：</p>


<p>尽管Lean使用熟悉的目标语法C <span class="math">\(\vdash \mathrm{P}\)</span>来显示目标，但它们实际上是元变量。</p>

<div class="math">$$
\begin{gathered}
\text { logInfo : MessageData } \rightarrow \text { TacticM Unit } \\
\text { getUnsolvedGoals : TacticM (List MVarId) } \\
\text { getMainTarget : TacticM Expr }
\end{gathered}
$$</div>

<p>上述程序中使用的常量具有以下类型：</p>

<p>其中MessageData表示消息，MVarId表示元变量标识符，Expr表示一个项。</p>
<pre><code>def hypothesis : TacticM Unit :=
    withMainContext
        (do

    let target \leftarrow getMainTarget
    let lctx \leftarrow getLCtx
    for ldecl in lctx do
        if ! LocalDecl.isImplementationDetail ldecl then
            let eq \leftarrow isDefEq (LocalDecl.type ldecl) target
            if eq then
                let goal \leftarrow getMainGoal
                MVarId.assign goal (LocalDecl.toExpr ldecl)
                return
    failure)
elab "hypothesis" : tactic =&gt;
    hypothesis
</code></pre>
<h3>8.4 首个示例：假设策略</h3>
<p>我们的第一个较大示例实现了一个假设策略，该策略与预定义的assumption策略类似，会寻找类型正确（即命题正确）的假设并应用它来证明目标：</p>

<p>在hypothesis函数中，我们首先提取第一个目标的目标类型和局部上下文。为确保get LCtx获取的是当前首要目标的局部上下文，我们将整个do代码块传递给withMainContext函数。一般而言，任何TacticM计算都是在提供表达式自由变量语义的环境局部上下文中执行的。withMainContext函数会将此局部上下文设置为当前首要目标的局部上下文。</p>


<p>在do代码块内部，我们使用便捷的monadic构造for-in遍历局部上下文中的所有声明。对于每个非实现细节（即Lean插入的、对用户不可见的假设）的局部变量或假设<span class="math">\(h\)</span>，我们会检查其类型（通常是其命题）是否在计算和元变量实例化后与目标相等。若满足条件，则获取第一个目标关联的元变量?m并赋值?m<span class="math">\(:=h\)</span>，从而完成目标证明。最后返回结果。</p>


<p>由于目标由元变量表示，给元变量?m赋值一个项是Lean底层证明目标的方式。该项中出现的新元变量对应着需要被证明的新子目标。</p>

<pre><code>theorem hypothesis_example {\alpha : Type} {p : \alpha -&gt; Prop} {a : \alpha}
    (hpa : p a) :
    p a :=
    by hypothesis
</code></pre>

<p>假设的简单调用如下：</p>


<p>如果添加追踪功能，我们可以看到在找到匹配假设hpa并成功应用之前，系统会依次尝试<span class="math">\(\alpha, \mathrm{p}\)</span>和a。</p>

<pre><code>getLCtx : TacticM LocalContext
LocalDecl.isImplementationDetail : LocalDecl -&gt; Bool
    isDefEq : Expr -&gt; Expr -&gt; TacticM Bool
    LocalDecl.type : LocalDecl -&gt; Expr
        getMainGoal : TacticM MVarId
    MVarId.assign : MVarId -&gt; Expr -&gt; TacticM Unit
    LocalDecl.toExpr : LocalDecl -&gt; Expr
    failure { }\alpha:\text { Type} : TacticM }\alpha
</code></pre>

<p>该示例使用了以下新常量：</p>


<h3>8.5 表达式</h3>
<p>元编程框架的核心是表达式（或项）类型Expr。表达式的重要组成部分是名称（Name类型），我们将由此展开讨论。</p>

<p>名称可通过单个反引号指定。例如，'<span class="math">\(x\)</span>表示名称<span class="math">\(x\)</span>，该名称可赋予变量或常量。引用常量时需指定包含命名空间的完整名称，因此若要引用第6章的Even谓词，必须写作'LoVe.Even而非'Even。</p>
<p>若需引用现有常量，Lean提供了双反引号语法，该语法会按照Lean常规的名称解析规则查找名称并扩展为全名。因此，无论是''Even还是''LoVe.Even都指向名称LoVe.Even，而如果我们写入未声明的名称（例如''EvenIf），Lean会报错。</p>
<pre><code>inductive Expr : Type where
    | const : Name <span class="math">\(\rightarrow\)</span> List Level <span class="math">\(\rightarrow\)</span> Expr
    | sort : Level <span class="math">\(\rightarrow\)</span> Expr
    | fvar : FVarId <span class="math">\(\rightarrow\)</span> Expr
    | mvar : MVarId <span class="math">\(\rightarrow\)</span> Expr
    | app : Expr <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr
    | lam : Name <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> BinderInfo <span class="math">\(\rightarrow\)</span> Expr
    | bvar : Nat <span class="math">\(\rightarrow\)</span> Expr
    | forallE : Name <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> BinderInfo <span class="math">\(\rightarrow\)</span> Expr
    | letE : Name <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Bool <span class="math">\(\rightarrow\)</span> Expr
    | lit : Literal <span class="math">\(\rightarrow\)</span> Expr
    | mdata : MData <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr
    | proj : Name <span class="math">\(\rightarrow\)</span> Nat <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> Expr
</code></pre>
<p>Expr类型的定义如下：</p>

<p>让我们回顾主要构造器：</p>
<ul>
<li>
<p>Expr.const name levels 表示名为 name 的常量，例如 Nat.add 或 <span class="math">\(\mathbb{N}\)</span>。levels 参数表示宇宙层级，该概念将在第12章解释。例如，Expr.const ''Nat.add [] 表示 Nat.add，而 Expr.const ''Nat [] 表示 Nat（即 <span class="math">\(\mathbb{N}\)</span>）。</p>
</li>
<li>
<p>Expr.sort level 用于表示类型的类型。例如，Expr.sort Level.zero 代表 Prop，而 Expr.sort (Level.succ Level.zero) 代表 Type。</p>
</li>
<li>
<p>Expr.fvar id 表示局部上下文中的自由变量（例如 a, h）。id 参数是该变量的唯一标识符。</p>
</li>
<li>
<p>Expr.mvar id 表示元变量（即带问号的变量 ?m）。id 参数是该元变量的唯一标识符。</p>
</li>
<li>
<p>Expr.app t u 表示函数 <span class="math">\(t\)</span> 对参数 <span class="math">\(u\)</span> 的应用。例如，Expr.app (Expr.const ''Nat.succ [])(Expr.const ''Nat.zero []) 表示 Nat.succ Nat.zero。</p>
</li>
<li>
<p>Expr.lam name <span class="math">\(\sigma\)</span> t bi 表示匿名函数（或 <span class="math">\(\lambda\)</span>-表达式）。name 参数是绑定变量的名称，<span class="math">\(\sigma\)</span> 参数是绑定变量的类型，<span class="math">\(t\)</span> 参数是函数体，bi 参数存储该变量是显式( )、隐式{ }还是类型类[ ]参数。</p>
</li>
<li>
<p>Expr.bvar i 表示绑定变量，使用德布鲁因索引表示法。Expr.var <span class="math">\(\theta\)</span> 指代由最近绑定器绑定的变量，Expr.var 1 指代由第二近绑定器绑定的变量，以此类推。因此，</p>
</li>
</ul>

<pre><code>Expr.lam 'x (Expr.const ''Nat []) (Expr.bvar <span class="math">\(\theta\)</span> )
    BinderInfo.default
</code></pre>
<pre><code>Expr.lam 'x (Expr.const ''Nat [])
    (Expr.lam 'y (Expr.const ''Nat []) (Expr.bvar 1)
        BinderInfo.default)
    BinderInfo.default
</code></pre>

<p>表示函数 fun <span class="math">\(x: \mathbb{N} \mapsto x\)</span>。</p>


<p>表示函数<span class="math">\(x y: \mathbb{N} \mapsto x\)</span>。</p>
<ul>
<li>Expr.forallE 名称<span class="math">\(\sigma \tau\)</span> bi 表示一个可能依赖的函数类型。名称参数是绑定变量的名称，<span class="math">\(\sigma\)</span>参数是定义域类型，<span class="math">\(\tau\)</span>参数是结果类型，bi参数与前述Expr.lam中的含义相同。例如，</li>
</ul>

<pre><code>Expr.forallE 'n (Expr.const ''Nat [])
    (Expr.app (Expr.const ''Even []) (Expr.bvar <span class="math">\(\theta\)</span> ))
    BinderInfo.default
</code></pre>
<pre><code>Expr.forallE 'dummy (Expr.const 'Nat [])
    (Expr.const 'Bool []) BinderInfo.default
</code></pre>

<p>表示<span class="math">\((n: \mathbb{N}) \rightarrow\)</span> 偶数<span class="math">\(n\)</span>（亦可写作<span class="math">\(\forall n: \mathbb{N}\)</span>, 偶数<span class="math">\(n\)</span>），并且</p>


<p>表示 <span class="math">\(\mathbb{N} \rightarrow\)</span> 布尔类型。</p>

<pre><code>theorem abc_a (a b c : Prop) (h : a ^ b ^ c) :
    a :=
    And.left h
theorem abc_b (a b c : Prop) (h : a ^ b ^ c) :
    b :=
    And.left (And.right h)
theorem abc_bc (a b c : Prop) (h : a ^ b ^ c) :
    b ^ c :=
</code></pre>

<h3>8.6 第二个示例：合取分解策略</h3>
<p>在本节及下一节中，我们将定义两个完成特定任务的策略。其中第一个策略名为destruct_and，用于自动化消除前提中的合取式。我们的目标是自动化完成如下证明：</p>

<pre><code>theorem abc_c (a b c : Prop) (h : a ^ b ^ c) :
    c :=
    And.right (And.right h)
</code></pre>
<p>And.right h</p>
<pre><code>partial def destructAndExpr (hP : Expr) : TacticM Bool :=
    withMainContext
        (do
            let target \leftarrow getMainTarget
            let P \leftarrow inferType hP
            let eq \leftarrow isDefEq P target
            if eq then
                let goal \leftarrow getMainGoal
                MVarId.assign goal hP
                return true
            else
                match Expr.and? P with
            | Option.none =&gt; return false
            | Option.some (Q, R) =&gt;
                let hQ \leftarrow mkAppM ''And.left #[hP]
                let success \leftarrow destructAndExpr hQ
                if success then
                    return true
                else
                    let hR \leftarrow mkAppM ''And.right #[hP]
                    destructAndExpr hR)
</code></pre>

<p>在每种情况下，我们都希望通过直接使用<code>destruct_and h</code>作为证明。我们的策略依赖于一个辅助函数，该函数以证明项hP（初始为假设h）作为参数，从中提取合取式：</p>


<p>与处理假设时类似，我们将整个do代码块传递给withMainContext函数。这确保inferType和isDefEq在正确的本地上下文中运行。在do块内部，我们首先提取第一个目标的目标类型和hP的类型（通常是其命题）P。若它们在计算和元变量实例化后相等，则通过给目标元变量赋值来闭合该目标（如假设示例所示），并返回true表示成功。否则，我们检查hP的命题是否具有<span class="math">\(Q \wedge R\)</span>的形式。若是，则递归调用辅助函数并传入证明项hQ := And.left hP（即Q的证明）。若递归成功则结束；否则尝试传入证明项hR := And.right hP（即R的证明）。</p>

<p>注意函数定义开头的关键字partial。此处需要它是因为Lean无法证明该函数总能终止。由于此函数仅用作元程序，而不会在命题内部使用，终止性是可选的，我们可以通过指定partial来禁用终止检查。</p>

<p>同样值得注意的是mkAppM函数，该函数用于构建一个常量到参数数组的携带式应用。数组与列表类似，但需以符号#为前缀书写（例如#[1, 2, 3]）。使用mkAppM比多次应用Expr.app构造函数更为便捷。此外，mkAppM允许我们省略隐式参数，例如命题<span class="math">\(Q\)</span>和<span class="math">\(R\)</span>——这些参数原本必须作为And.left和And.right的实参提供。</p>

<pre><code>def destructAnd (name : Name) : TacticM Unit :=
    withMainContext
        (do
            let h \leftarrow getFVarFromUserName name
            let success \leftarrow destructAndExpr h
            if ! success then
                failure)
elab "destruct_and" h:ident : tactic =&gt;
    destructAnd (getId h)
</code></pre>

<p>主函数需要完成的工作已所剩无几：</p>

<p>该函数通过getFVarFromUserName获取假设h并调用辅助函数。若辅助函数返回false，则策略执行失败。</p>
<pre><code>theorem abc_a_again (a b c : Prop) (h : a \wedge b \wedge c) :
    a :=
    by destruct_and h
theorem abc_b_again (a b c : Prop) (h : a \wedge b \wedge c) :
    b :=
    by destruct_and h
theorem abc_bc_again (a b c : Prop) (h : a \wedge b \wedge c) :
        b \wedge c :=
    by destruct_and h
theorem abc_c_again (a b c : Prop) (h : a \wedge b \wedge c) :
        c :=
    by destruct_and h
</code></pre>

<p>现在我们可以将新工具应用于初始示例：</p>

<div class="math">$$
\begin{gathered}
\text { inferType : Expr } \rightarrow \text { TacticM Expr } \\
\text { Expr. and? : Expr } \rightarrow \text { Option (Expr } \times \text { Expr) } \\
\text { mkAppM : Name } \rightarrow \text { Array Expr } \rightarrow \text { TacticM Expr } \\
\text { getFVarFromUserName : Name } \rightarrow \text { TacticM Expr }
\end{gathered}
$$</div>

<p>在上述元程序中使用了以下新常量：</p>


<h3>8.7 第三个示例：直接证明查找器</h3>
<p>有时我们陈述一个定理并完成证明后，才发现该定理已存在。使用prove_direct策略可避免这种情况，该策略会遍历所有可用定理并检查是否能验证当前目标。我们将逐步分析其代码实现。</p>

<pre><code>def isTheorem : ConstantInfo -&gt; Bool
    | ConstantInfo.axiomInfo _ =&gt; true
    | ConstantInfo.thmInfo _ =&gt; true
    | _ =&gt; false
</code></pre>

<p>第一步是定义isTheorem函数，若声明为公理或定理则返回true，否则返回false：</p>

<pre><code>def applyConstant (name : Name) : TacticM Unit :=
    do
        let cst \leftarrow mkConstWithFreshMVarLevels name
        liftMetaTactic (fun goal <span class="math">\(\mapsto\)</span> MVarId.apply goal cst)
</code></pre>

<p>我们将使用此函数过滤掉不感兴趣的声明。下一个函数将名为name的定理应用于当前目标：</p>


<p>给定名称时，mkConstWithFreshMVarLevels函数会创建一个表示该常量的表达式cst。函数名中提到的"新鲜元变量层级"将在第12章中变得更清晰。随后MVarId.apply（注意不要与MVarId.assign混淆）将该常量应用到当前目标，设置?m:= cst <span class="math">\(? \mathrm{~m}_{1} \ldots\)</span> ?m <span class="math">\(m_{n}\)</span> 并返回表示cst前提的新鲜元变量<span class="math">\(? \mathrm{~m}_{j}\)</span>。</p>


<p>liftMetaTactic函数会获取第一个目标的标识符，在较低层级的MetaM单子中对目标运行给定函数，并用该函数返回的子目标替换原目标。</p>

<pre><code>def andThenOnSubgoals (tac
    TacticM Unit :=
    do
        let origGoals \leftarrow getGoals
        let mainGoal \leftarrow getMainGoal
        setGoals [mainGoal]
        tac
        let subgoals
        let mut newGoals := []
        for subgoal in subgoals
            let assigned \leftarrow MVarId.isAssigned subgoal
            if ! assigned then
                setGoals [subgoal]
                tac
                let subgoals }\leftarrow\mathrm{ getUnsolvedGoals
                newGoals := newGoals ++ subgoals
    setGoals (newGoals ++ List.tail origGoals)
</code></pre>
<p>下一个函数实现了一个类似于&lt;; &gt;但可用于元程序中的组合器：</p>

<p>TacticM单子用于追踪当前待证明的目标。我们可以通过getGoals获取目标列表，并通过setGoals设置目标列表。设置子目标列表的功能非常有用，特别是当我们需要策略暂时聚焦于特定子目标时。</p>


<p>在此，我们首先聚焦于第一个目标（setGoals [mainGoal]）并调用第一个策略。对于每个新出现的子目标，我们将其设为当前焦点（setGoals [subgoal]）并调用第二个策略。由第二个策略产生的所有未解决子子目标都被收集到可变变量newGoals中。由于证明一个目标有时会实例化另一个元变量，我们在每次迭代时检查当前子目标元变量是否已被赋值，若已赋值则跳过该子目标。最后，我们更新目标列表以包含所有待处理目标：即newGoals中的目标以及origGoals中除首个目标外的所有目标（这些目标我们尚未考虑）。</p>

<pre><code>def proveDirect : TacticM Unit :=
    do
    let origGoals \leftarrow getUnsolvedGoals
    let goal \leftarrow getMainGoal
    setGoals [goal]
    let env \leftarrow getEnv
    for (name, info)
        in SMap.toList (Environment.constants env) do
        if isTheorem info 66 ! ConstantInfo.isUnsafe info then
        try
            proveUsingTheorem name
            logInfo m!"Proved directly by {name}"
            setGoals (List.tail origGoals)
            return
            catch _ =&gt;
            continue
        failure
elab "prove_direct" : tactic =&gt;
    proveDirect
</code></pre>

<p>通常而言，在策略执行结束时，我们应确保目标列表包含所有待证明的目标。否则可能会出现诸如"声明存在元变量"之类的隐晦错误。我们还需要一个策略：该策略尝试通过指定名称的定理来证明目标，并调用hypothesis来证明任何出现的子目标：
def proveUsingTheorem (name : Name) : TacticM Unit :=
andThenOnSubgoals (applyConstant name) hypothesis
这是对证明语句"apply name &lt;;&gt; hypothesis"的程序化等价实现。
最后，我们准备审视主函数：</p>

<p>我们首先聚焦第一个目标，随后遍历环境中声明的所有常量。若该常量是定理且不属"unsafe"（此为Lean概念，与我们所说的不安全规则及策略无关），则尝试使用辅助函数proveUsingTheorem应用该定理。若成功，则输出"由定理name直接得证"（其中name为定理名称）并返回；若失败则继续迭代。若遍历全部完成后仍未成功，则报告失败。</p>
<pre><code>theorem Nat.symm (x y : N) (h : x = y) :
    y = x :=
    by prove_direct
</code></pre>
<p>以下是该策略的实际应用：</p>
<pre><code>theorem Nat.symm_manual ( <span class="math">\(x\)</span> y : N) (h : x = y) :
    <span class="math">\(y=x:=\)</span>
    by
        apply symm
        hypothesis
</code></pre>
<p>这将打印出“由symm直接证明完成”。该提示信息很有帮助，因为我们可以直接应用指定的定理，而不必依赖相对缓慢的prove_direct策略。具体而言，我们可以结合假设按如下方式应用定理symm：</p>
<pre><code>mkConstWithFreshMVarLevels : Name <span class="math">\(\rightarrow\)</span> TacticM Expr
    liftMetaTactic : (MVarId <span class="math">\(\rightarrow\)</span> MetaM (List MVarId) ) <span class="math">\(\rightarrow\)</span>
        TacticM Unit
        MVarId.apply : MVarId <span class="math">\(\rightarrow\)</span> Expr <span class="math">\(\rightarrow\)</span> MetaM (List MVarId)
            getGoals : TacticM (List MVarId)
            setGoals : List MVarId <span class="math">\(\rightarrow\)</span> TacticM Unit
        MVarId.isAssigned : MVarId <span class="math">\(\rightarrow\)</span> TacticM Bool
            getEnv : TacticM Environment
            SMap.toList : ConstMap <span class="math">\(\rightarrow\)</span> List (Name <span class="math">\(\times\)</span> ConstantInfo)
        Environment.constants : Environment <span class="math">\(\rightarrow\)</span> ConstMap
        ConstantInfo.isUnsafe : ConstantInfo <span class="math">\(\rightarrow\)</span> Bool
</code></pre>

<p>以下是本例中涉及的新常量列表：</p>

<p>至此我们完成了对prove_direct的回顾。mathlib中提供了类似的策略apply?。</p>
<h3>8.8 杂项策略</h3>
<p>尽管本章重点在于开发新策略，但我们仍遇到了三个预定义策略。</p>

<h4>skip</h4>
<p>skip策略会不做任何操作直接成功。在开发自定义策略时，它有时可作为基础构建模块使用。</p>


<h4>done</h4>
<p>done策略会在仍有未完成目标时引发失败；否则不做任何操作直接成功。与skip类似，它可作为构建自定义策略的基础组件。</p>


<h4>apply?</h4>
<p>apply? 策略会在已加载的库中搜索能精确证明当前目标的定理。若成功，它将生成一个形如 exact ... 的策略调用建议，该建议可直接插入到形式化证明中。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">' <span class="math">\(n\)</span>
</th>
  <th style="text-align:left">quotes a literal name</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">''n</td>
  <td style="text-align:left">quotes a literal name with elaboration and checking</td>
</tr>
</tbody>
</table>

<h3>8.9 新引入的Lean结构摘要</h3>
<h4>声明</h4>
<h4>引述</h4>
<h4>策略</h4>
<p>apply? 搜索能证明当前目标的定理
done 若存在未完成目标则报错
skip 不执行任何操作</p>


<h4>策略组合器</h4>
<p><span class="math">\(&lt;;&gt;\)</span>
all_goals
any_goals
first | ... | ...
repeat'
solve | ... | ...
try
对第一个策略产生的所有子目标应用第二个策略 在每个目标上尝试应用策略一次，要求全部成功 在每个目标上尝试应用策略一次，要求至少一个成功 依次尝试多个策略直到其中一个成功
反复在所有目标和子目标上应用策略直至失败 依次尝试用多个策略完全证明当前目标 尝试应用策略，失败时不执行任何操作</p>


<h1>第三部分：程序语义学</h1>
<h2>第九章：操作语义</h2>
<p>在本章及随后两章中，我们将探讨如何运用Lean语言来规范编程语言的语法与语义，证明语义特性，并对具体程序进行逻辑推理。</p>


<p>本章内容深受《Concrete Semantics: With Isabelle/HOL》第七章的启发。</p>


<h3>9.1 形式语义学</h3>
<p>形式语义学使我们能够规范和推理编程语言以及用该语言编写的个体程序。它可以构成经过验证的编译器、解释器、验证器、静态分析器、类型检查器等工具的基础。若无形式化证明，这些工具几乎总是存在错误。</p>

<p>以WebAssembly为例，这是一种面向浏览器的新型类汇编语言，设计作为C++和Rust等高级语言的便携式编译目标。研究员Conrad Watt使用Isabelle/HOL证明助手对其语义和类型系统进行了形式化验证，并发现诸多问题（我们强调的）：</p>

<p>我们完成了WebAssembly语言核心执行语义与类型系统的完整Isabelle机械化验证。此外，我们还针对工作组论文中所述的类型可靠性特性构建了机械化证明。为完成该证明，必须由规范作者修正我们在验证建模过程中发现的官方WebAssembly规范中的若干缺陷。某些情况下，这些缺陷意味着原类型系统存在根本性不可靠。</p>
<p>我们与工作组部分成员保持着建设性对话，持续对新加入规范的功能进行机械化验证。特别值得注意的是，工作组原始论文中并未正式规定WebAssembly实现与宿主环境的交互机制。当我们扩展机械化模型以涵盖该特性时，暴露出一个破坏类型系统可靠性的WebAssembly规范缺陷。</p>

<p>瓦特的研究仅是众多案例之一。证明辅助工具在编程语言研究中被广泛应用。每年在程序设计原理（POPL）会议上发表的论文中，有相当比例都进行了形式化验证。这之所以可行，是因为入门所需的机制相对较少。此类证明往往包含大量分支情况，而这正适合计算机处理。此外，证明辅助工具能极其便捷地追踪编程语言新增功能时所需的修改。</p>
<table>
<thead>
<tr>
  <th style="text-align:center">
<span class="math">\(S::=\)</span> skip</th>
  <th style="text-align:center">(no-op)</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><span class="math">\(\mid x:=a\)</span></td>
  <td style="text-align:center">(assignment)</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\mid S ; S\)</span></td>
  <td style="text-align:center">(sequential composition)</td>
</tr>
<tr>
  <td style="text-align:center">if <span class="math">\(b\)</span> then <span class="math">\(S\)</span> else <span class="math">\(S\)</span>
</td>
  <td style="text-align:center">(conditional statement)</td>
</tr>
<tr>
  <td style="text-align:center">while <span class="math">\(b\)</span> do <span class="math">\(S\)</span>
</td>
  <td style="text-align:center">(while loop)</td>
</tr>
</tbody>
</table>

<h3>9.2 极简命令式语言</h3>
<p>我们引入WHILE<span class="math">\({ }^{1}\)</span>，这是一种极简命令式语言，其语法如下：</p>

<p>其中<span class="math">\(S\)</span>表示语句（亦称命令或程序），<span class="math">\(x\)</span>表示程序变量，<span class="math">\(a\)</span>表示算术表达式，<span class="math">\(b\)</span>表示布尔表达式。</p>

<p>在我们的语法中，我们有意不指定算术表达式和布尔表达式的具体语法。在Lean中，我们有两种选择：</p>
<ul>
<li>可以使用第2.1节中的AExp类型来表示算术表达式，布尔表达式同理。</li>
<li>也可以简单地定义算术表达式为从状态到数字的函数（例如State <span class="math">\(\rightarrow \mathbb{N}\)</span>），布尔表达式为关于状态的谓词（例如State <span class="math">\(\rightarrow\)</span> Bool或State <span class="math">\(\rightarrow\)</span> Prop）。状态（State）是从程序变量到值的映射。因此，<span class="math">\(x+y+1\)</span>可以表示为函数fun s : State <span class="math">\(\mapsto \mathrm{s}\)</span> "x" + s "y" + 1，而<span class="math">\(\mathrm{a} \neq \mathrm{b}\)</span>可以表示为谓词fun s : State <span class="math">\(\mapsto \mathrm{s}\)</span> "a" <span class="math">\(\neq \mathrm{s}\)</span> "b"。

这两种选择对应深层嵌入（deep embedding）和浅层嵌入（shallow embedding）的区别。深层嵌入是指将某种语法（表达式、公式、程序等）的抽象语法树在证明助手中显式定义（例如AExp），并赋予其语义（例如eval）。而浅层嵌入则是直接复用逻辑中的相应机制（例如函数和谓词）。</li>
</ul>


<p>深度嵌入允许我们推理程序的语法结构，而浅层嵌入则更为轻量，因其可直接使用而无需定义语义——浅层嵌入自身即为其语义。</p>

<pre><code>inductive Stmt : Type where
    | skip : Stmt
    | assign : String <span class="math">\(\rightarrow\)</span> (State <span class="math">\(\rightarrow \mathbb{N}) \rightarrow\)</span> Stmt
    | seq : Stmt <span class="math">\(\rightarrow\)</span> Stmt <span class="math">\(\rightarrow\)</span> Stmt
    | ifThenElse : (State <span class="math">\(\rightarrow\)</span> Prop) <span class="math">\(\rightarrow\)</span> Stmt <span class="math">\(\rightarrow\)</span> Stmt <span class="math">\(\rightarrow\)</span> Stmt
    | whileDo : (State <span class="math">\(\rightarrow\)</span> Prop) <span class="math">\(\rightarrow\)</span> Stmt <span class="math">\(\rightarrow\)</span> Stmt
</code></pre>

<p>在第七章中，我们采用了效应式程序的浅层嵌入。此处，我们将对程序采用深层嵌入（这是我们感兴趣且希望深入研究的部分），而对算术及布尔表达式采用浅层嵌入（这部分我们认为价值较低）。我们的Lean程序定义如下：</p>


<p>中缀语法<span class="math">\(S ; T\)</span>是Stmt.seq <span class="math">\(S T\)</span>的缩写。归纳类型的构造子与WHILE语法规则之间的对应关系应当清晰明了。变量由字符串表示，State类型被定义为String <span class="math">\(\rightarrow \mathbb{N}\)</span>，即从变量名到值的映射。为简化处理，我们所有的程序变量均为自然数类型，且所有可能的变量名都存在于状态中并被赋值。</p>

<pre><code>def sillyLoop : Stmt :=
    Stmt.whileDo (fun s \mapsto s "x" &gt; s "y")
        (Stmt.skip;
            Stmt.assign "x" (fun s \mapsto s "x" - 1))
</code></pre>

<p>以下小程序展示了深度嵌入的WHILE语法（及其浅层嵌入特性）：</p>


<h3>9.3 大步语义</h3>
<p>操作语义对应于理想化的解释器。其主要分为两种形式：大步语义和小步语义。我们将首先为WHILE语言定义大步语义。</p>

<p>在大步操作语义（亦称自然语义）中，判断具有形式<span class="math">\((S, s) \Longrightarrow t\)</span>，其直观解释如下：</p>

<p>从初始状态<span class="math">\(s\)</span>开始执行程序<span class="math">\(S\)</span>，可能终止于状态<span class="math">\(t\)</span>。对于WHILE这类确定性语言，由于程序执行结果唯一，"可能终止"等同于"必定终止"或"终止"。</p>

<div class="math">$$
(x:=x+y ; y:=0,[x \mapsto 3, y \mapsto 5]) \Longrightarrow[x \mapsto 8, y \mapsto 0]
$$</div>

<p>根据WHILE程序的定义，状态<span class="math">\(s\)</span>是一个String类型到<span class="math">\(\rightarrow \mathbb{N}\)</span>的函数。示例如下：</p>


<p>我们使用非正式符号<span class="math">\([x \mapsto 3, y \mapsto 5]\)</span>来表示函数fun <span class="math">\(v \mapsto\)</span> 若<span class="math">\(v=\)</span> "<span class="math">\(x\)</span>"则返回3，否则若<span class="math">\(v=\)</span> "<span class="math">\(y\)</span>"则返回5，否则返回0；类似地，<span class="math">\([x \mapsto 8, y \mapsto 0]\)</span>也遵循相同规则。直观上，该判断成立。</p>

<div class="math">$$
\begin{aligned}
&amp; \overline{(\text { skip }, s) \Longrightarrow s} \text { SKIP } \\
&amp; \overline{(x:=a, s) \Longrightarrow s[x \mapsto a s]} \text { ASSIGN } \\
&amp; \frac{(S, s) \Longrightarrow t \quad(T, t) \Longrightarrow u}{(S ; T, s) \Longrightarrow u} \text { SEQ } \\
&amp; \frac{(S, s) \Longrightarrow t}{(\text { if } b \text { then } S \text { else } T, s) \Longrightarrow t} \text { IF-TrUE if } b \text { is true }
\end{aligned}
$$</div>
<div class="math">$$
\begin{aligned}
&amp; (T, s) \Longrightarrow t \\
&amp; \text { (if } b \text { then } S \text { else } T, s) \Longrightarrow t \\
&amp; (S, s) \Longrightarrow t \quad \text { (while } b \text { do } S, t) \Longrightarrow u \\
&amp; \text { (while } b \text { do } S, s) \Longrightarrow u \\
&amp; \text { (while } b \text { do } S, s) \Longrightarrow s
\end{aligned}
$$</div>

<p>传统上，这类语义的规范方式是通过一个形式化的推导规则系统，其风格类似于第1.3节和第4.6节中介绍的类型规则。大步语义判断的推导规则如下所示。这些规则可视为WHILE程序的理想化解释器。</p>

<div class="math">$$
s[x \mapsto n]=(f u n v \mapsto i f v=x \text { then } n \text { else } s v)
$$</div>

<p>在这些规则中，<span class="math">\(a \mathrm{~s}\)</span>表示算术表达式a在状态<span class="math">\(s\)</span>下的值，<span class="math">\(b \mathrm{~s}\)</span>同理。此外，语法<span class="math">\(s[x \mapsto n]\)</span>表示与<span class="math">\(s\)</span>完全相同的状态，不同之处在于它将变量<span class="math">\(x\)</span>映射到<span class="math">\(n\)</span>。形式化表述如下：</p>


<p>该语法由LoVelib提供。最复杂的规则无疑是While-True。直观上可以这样理解：</p>


<p>假设在状态<span class="math">\(s\)</span>中条件<span class="math">\(b\)</span>为真。若(1)在状态<span class="math">\(s\)</span>中执行<span class="math">\(S\)</span>将导致状态<span class="math">\(t\)</span>，且(2)从状态<span class="math">\(t\)</span>执行while <span class="math">\(b\)</span> do <span class="math">\(S\)</span>将导致状态<span class="math">\(u\)</span>，则在状态<span class="math">\(s\)</span>中执行while b do <span class="math">\(S\)</span>将导致状态<span class="math">\(u\)</span>。</p>


<p>另一种理解While-True规则的方式是通过循环展开。若循环条件为真，while <span class="math">\(b\)</span> do <span class="math">\(S\)</span> 等价于复合语句 <span class="math">\(S\)</span>; while b do S。While-True的两个前提对应于Seq规则实例中针对 <span class="math">\(S\)</span>; while b do <span class="math">\(S\)</span> 的两个前提。</p>

<div class="math">$$
\begin{aligned}
&amp; \text { ASSIGN } \\
&amp; (x:=x+y, s) \Longrightarrow t \quad(y:=0, t) \Longrightarrow u \\
&amp; (x:=x+y ; y:=0, s) \Longrightarrow u
\end{aligned}
$$</div>

<p>作为练习，让我们推导上述示例判断。设<span class="math">\(s:=[x \mapsto 3\)</span>，<span class="math">\(y \mapsto 5]\)</span>，<span class="math">\(t:=[x \mapsto 8, y \mapsto 5]\)</span>，以及<span class="math">\(u:=[x \mapsto 8, y \mapsto \theta]\)</span>。于是我们有</p>


<p>推导规则可以直观地理解。以Seq规则为例：若(1)在状态<span class="math">\(s\)</span>下执行<span class="math">\(S\)</span>会到达状态<span class="math">\(t\)</span>，且(2)在状态<span class="math">\(t\)</span>下执行<span class="math">\(T\)</span>会到达状态<span class="math">\(u\)</span>，那么在状态<span class="math">\(s\)</span>下执行顺序组合<span class="math">\(S ; T\)</span>就会到达状态<span class="math">\(u\)</span>。</p>

<pre><code>inductive BigStep : Stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> State <span class="math">\(\rightarrow\)</span> Prop where
    | skip (s) :
        BigStep (Stmt.skip, s) s
    | assign (x a s) :
        BigStep (Stmt.assign x a, s) (s[x <span class="math">\(\mapsto\)</span> a s])
    | seq (S T s t u) (hS : BigStep (S, s) t)
        (hT : BigStep (T, t) u) :
        BigStep (S; T, s) u

    | if_true (B S T s t) (hcond : B s)
        (hbody : BigStep (S, s) t) :
    BigStep (Stmt.ifThenElse B S T, s) t
    | if_false (B S T s t) (hcond : - B s)
        (hbody : BigStep (T, s) t) :
    BigStep (Stmt.ifThenElse B S T, s) t
    | while_true (B S s t u) (hcond : B s)
        (hbody : BigStep (S, s) t)
        (hrest : BigStep (Stmt.whileDo B S, t) u) :
    BigStep (Stmt.whileDo B S, s) u
    | while_false (B S s) (hcond : - B s) :
    BigStep (Stmt.whileDo B S, s) s
</code></pre>
<p>条件(1)和(2)对应于Seq规则的两个前提。在Lean中，大步语义判断由一个归纳谓词表示，其引入规则严格遵循上述推导规则：</p>
<pre><code>def eval : Stmt -&gt; State -&gt; State
    | Stmt.skip, s =&gt; s
    | Stmt.assign x a, s =&gt; s[x }-&gt;\mathrm{ a s]
    | Stmt.ifThenElse b S T, s =&gt;
        if b s then eval S s else eval T s
    | S; T, s =&gt; eval T (eval S s)
    | Stmt.whileDo b S, s =&gt;
        if b s then eval (Stmt.whileDo b S) (eval S s) else s
</code></pre>

<p>与使用递归函数相比，采用归纳谓词使我们能够处理非终止情况（如发散循环）以及比WHILE更丰富的语言中的非确定性。这种方式还提供了更优雅的语法，更接近科学文献中传统使用的判定规则。如果我们尝试改用递归定义，例如</p>


<p>我们将面临Stmt.whileDo情况下的非终止问题。实际上，由于程序Stmt.whileDo (fun _ <span class="math">\(\mapsto\)</span> True) Stmt.skip会无限循环，尝试用eval对其进行求值将永远不会返回结果。</p>

<pre><code>theorem sillyLoop_from_1_BigStep :
    (sillyLoop, (fun _ }-&gt;\mathrm{ @)["x" }-&gt;\mathrm{ :]) }-&gt;\mathrm{ (fun _ }-&gt;\mathrm{ @) :=
    by
        rw [sillyLoop]
        apply BigStep.while_true
        { simp }
        { apply BigStep.seq
            { apply BigStep.skip }
            { apply BigStep.assign } }
        { simp
            apply BigStep.while_false
            simp }
</code></pre>

<p>配备了大步语义后，我们能够对具体程序（如第9.2节定义的示例）进行推理，并证明如下定理：</p>


<h3>9.4 大步语义的特性</h3>
<p>大步语义使我们能够推理具体程序，证明关于最终状态与初始状态关系的定理。同样重要的是，它允许我们证明编程语言的特性，例如确定性和非终止性。</p>

<pre><code>theorem BigStep_deterministic <span class="math">\(\{S s 1 \mathrm{r}\} \quad(\mathrm{hl}: S s \Longrightarrow 1)\)</span>
    <span class="math">\((h r: S s \Longrightarrow r)\)</span> :
    <span class="math">\(l=r\)</span>
</code></pre>
<p>我们从确定性开始讨论。这看似是个微不足道的特性，但规则若出现笔误就可能导致非确定性。例如在赋值规则中，如果我们错误地将BigStep (Stmt. assign x a, s) (s[y <span class="math">\(\mapsto\)</span> a s])中的<span class="math">\(x\)</span>写成y，就能随意用该规则修改任意变量<span class="math">\(y\)</span>。换言之，程序执行时可能随机修改任何变量。因此我们需要验证WHILE语言确实是确定性的：</p>

<p>Lean证明位于本章关联的演示文件中。由于技术原因，数对<span class="math">\((S, s)\)</span>被表示为单个变量<span class="math">\(S s\)</span>。我们在此仅给出非正式的证明概要：</p>

<p>该证明通过对<span class="math">\((S, s) \Longrightarrow 1\)</span>进行规则归纳。SKIP情形：要使(skip, s) <span class="math">\(\Longrightarrow 1\)</span>成立，需满足<span class="math">\(1=\)</span> s。类似地，通过对(skip, s) <span class="math">\(\Longrightarrow r\)</span>进行情形分析，可得<span class="math">\(r=s\)</span>。因此<span class="math">\(l=r\)</span>。</p>

<p>情形ASSIGN：与SKIP类似。
情形SEQ：我们有假设<span class="math">\((S, s) \Longrightarrow t,(T, t) \Longrightarrow 1,(S, s)\)</span> <span class="math">\(\Longrightarrow t^{\prime}\)</span>，以及<span class="math">\(\left(T, t^{\prime}\right) \Longrightarrow r\)</span>，且归纳假设为<span class="math">\(\forall r,(S, s) \Longrightarrow\)</span> <span class="math">\(r \rightarrow t=r\)</span>和<span class="math">\(\forall r,(T, t) \Longrightarrow r \rightarrow l=r\)</span>。由第一个归纳假设与<span class="math">\((S, s) \Longrightarrow t^{\prime}\)</span>可得<span class="math">\(t=t^{\prime}\)</span>。由第二个归纳假设与<span class="math">\(\left(T, t^{\prime}\right) \Longrightarrow r\)</span>可得<span class="math">\(l=r\)</span>。
情形IF-TRUE：由于<span class="math">\(b\)</span> s为真，(if <span class="math">\(b\)</span> then <span class="math">\(S\)</span> else <span class="math">\(T, s) \Longrightarrow r\)</span>只能通过IF-TRUE规则推导，因此有<span class="math">\((S, s) \Longrightarrow r\)</span>。归纳假设为<span class="math">\(\forall r,(S, s) \Longrightarrow r \rightarrow l=r\)</span>。将<span class="math">\((S, s) \Longrightarrow r\)</span>应用于该假设可得<span class="math">\(l=r\)</span>。</p>

<pre><code>theorem BigStep_terminates <span class="math">\(\{S \mathrm{~s}\}:\)</span>
    <span class="math">\(\exists t,(S, s) \Longrightarrow t\)</span>
</code></pre>

<p>CASE IF-FALSE: 与IF-TRUE情况类似。
CASE WHILE-TRUE: 与SEQ情况类似。
CASE WHILE-FALSE: 与SKIP情况类似。
鉴于WHILE语言具有确定性，在大步语义下，终止性可归结为以下结论：</p>

<p>该性质表明，对于每个语句<span class="math">\(S\)</span>和状态<span class="math">\(s\)</span>，总存在一个状态<span class="math">\(t\)</span>使得从<span class="math">\(s\)</span>开始执行<span class="math">\(S\)</span>可能终止于<span class="math">\(t\)</span>。由于WHILE语言具有确定性，"可能终止"等价于"必然终止"。然而，这一性质并不成立。</p>
<pre><code>@[simp] theorem BigStep_skip_Iff <span class="math">\(\{s t\}\)</span> :
    (Stmt.skip, s) <span class="math">\(\Longrightarrow t \leftrightarrow t=s\)</span>

@[simp] theorem BigStep_assign_Iff {x a s t} :
    (Stmt.assign x a, s) \(\Longrightarrow \mathrm{t} \leftrightarrow \mathrm{t}=\mathrm{s}[\mathrm{x} \mapsto \mathrm{a} \mathrm{s}\]
@[simp] theorem BigStep_seq_Iff \{S T s u\} :
    <span class="math">\((\mathrm{S} ; \mathrm{T}, \mathrm{s}) \Longrightarrow \mathrm{u} \leftrightarrow(\exists \mathrm{t},(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \wedge(\mathrm{T}, \mathrm{t}) \Longrightarrow \mathrm{u})\)</span>
@[simp] theorem BigStep_if_Iff \{B S T s t\} :
    (Stmt.ifThenElse B S T, s) <span class="math">\(\Longrightarrow \mathrm{t} \leftrightarrow\)</span>
    <span class="math">\((B \mathrm{~s} \wedge(\mathrm{~S}, \mathrm{~s}) \Longrightarrow \mathrm{t}) \vee(\neg \mathrm{B} \mathrm{s} \wedge(\mathrm{T}, \mathrm{s}) \Longrightarrow \mathrm{t})\)</span>
theorem BigStep_while_Iff \{B S s u\} :
    (Stmt.whileDo B S, s) <span class="math">\(\Longrightarrow u \leftrightarrow\)</span>
    <span class="math">\((B \mathrm{~s} \wedge \exists \mathrm{t},(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \wedge\)</span> (Stmt.whileDo B S, t) <span class="math">\(\Longrightarrow \mathrm{u})\)</span>
    <span class="math">\(\vee(\neg \mathrm{B} \mathrm{s} \wedge \mathrm{u}=\mathrm{s})\)</span>
@[simp] theorem BigStep_while_true_Iff \{B S s u\}
        (hcond : B s) :
    (Stmt.whileDo B S, s) <span class="math">\(\Longrightarrow u \leftrightarrow\)</span>
    <span class="math">\((\exists \mathrm{t},(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \wedge(\)</span> stmt.whileDo B S, t) <span class="math">\(\Longrightarrow \mathrm{u})\)</span>
@[simp] theorem BigStep_while_false_Iff \{B S s t\}
        (hcond : <span class="math">\(\neg \mathrm{B} \mathrm{s})\)</span>
    (Stmt.whileDo B S, s) <span class="math">\(\Longrightarrow \mathrm{t} \leftrightarrow \mathrm{t}=\mathrm{s}\)</span>
</code></pre>
<p>在推理归纳谓词时，使用反演规则（第6.5节）通常较为方便。因此，我们证明以下规则：</p>
<p>我们将这些规则添加到simp集合中，但BigStep_while_Iff除外，因为它会导致simp进入循环。</p>
<h3>9.5 小步语义</h3>
<p>大步语义的局限性在于无法推理中间状态。从判断式<span class="math">\((S, s) \Longrightarrow t\)</span>中，我们仅能看到初始状态<span class="math">\(s\)</span>和最终状态<span class="math">\(t\)</span>。这种粗粒度的表达难以用于多线程程序推理——在多个进程可能相互影响中间状态的场景下尤为明显。此外对于非确定性语言，大步语义无法通用地表达终止性：判断式仅表明可能性（在状态<span class="math">\(s\)</span>中执行<span class="math">\(S\)</span>可能得到状态<span class="math">\(t\)</span>），而非必然性。</p>

<p>小步操作语义提供了更精细的视角。转移谓词<span class="math">\(\Rightarrow\)</span>的类型为stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> Prop。直观而言，<span class="math">\((S, s) \Rightarrow(T\)</span>, <span class="math">\(t\)</span>)表示在状态<span class="math">\(s\)</span>下执行程序<span class="math">\(S\)</span>的一步后，剩余待执行的程序为<span class="math">\(T\)</span>，且状态变为<span class="math">\(t\)</span>。若无剩余代码需执行，则置为skip。</p>

<div class="math">$$
\begin{array}{rlrl}
(x:=x+y ; y:=0, &amp; {[x \mapsto 3, y \mapsto 5])} \\
\Rightarrow(\text { skip } ; y:=0, &amp; &amp; {[x \mapsto 8, y \mapsto 5])} \\
\Rightarrow(y:=0, &amp; &amp; {[x \mapsto 8, y \mapsto 5])} \\
\Rightarrow(\text { skip }, &amp; &amp; {[x \mapsto 8, y \mapsto 0])}
\end{array}
$$</div>

<p>执行过程是一个有限或无限的链式序列<span class="math">\(\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{1}, s_{1}\right) \Rightarrow \cdots\)</span>，由这些"微小"的<span class="math">\(\Rightarrow\)</span>步骤构成。一个二元组<span class="math">\((S, s)\)</span>称为配置；若对于任意<span class="math">\((T, t)\)</span>都不存在形如<span class="math">\((S, s) \Rightarrow(T, t)\)</span>的转移，则该配置为最终配置。执行示例如下：</p>


<p>如果以计算机处理器作类比，配置<span class="math">\((S, s)\)</span>中的<span class="math">\(S\)</span>组件可视为程序计数器，它指示接下来应执行哪些指令。程序的逐步执行类似于在调试器中运行程序，并在每一步设置断点。</p>

<div class="math">$$
\begin{aligned}
&amp; \overline{(x:=a, s) \Rightarrow(\text { skip }, s[x \mapsto a s])} \text { ASSIGN } \\
&amp; \frac{(S, s) \Rightarrow\left(S^{\prime}, s^{\prime}\right)}{\left(S ; T, s\right) \Rightarrow\left(S^{\prime} ; T, s^{\prime}\right)} \text { SEQ-STEP } \\
&amp; \text { (skip; } T, s) \Rightarrow(T, s) \text { SEQ-SKIP } \\
&amp; \text { (if b then } S \text { else } T, s) \Rightarrow(S, s) \text { IF-TrUE if } b \text { is true } \\
&amp; \text { (if b then } S \text { else } T, s) \Rightarrow(T, s) \text { IF-FALSE if } b \text { is false }
\end{aligned}
$$</div>

<p>有效的小步推导规则由以下派生规则给出：</p>


<p>(while b do S, s) <span class="math">\(\Rightarrow\)</span> (if b then (S; while b do S) else skip, s)
这些规则让人联想到6.1.2节中的网球比赛转移系统。它们同样规定了小步骤：从0-0到15-0，再到15-15，以此类推。</p>


<p>与大步语义不同，小步语义中没有关于skip的规则。这是因为形式为(skip, s)的配置被视为最终状态；skip被理解为执行过程微不足道的语句。通过检查这些规则，我们可以确信一个配置是最终的当且仅当其第一个分量为skip。</p>

<p>两条规则涉及顺序组合<span class="math">\(S ; T\)</span>。第一条规则适用于当<span class="math">\(S\)</span>可继续执行的情况。但若<span class="math">\(S\)</span>为skip语句，则无法继续执行，此时适用第二条规则。</p>

<p>关于if语句的规则会检查条件<span class="math">\(b\)</span>，并根据其真值将then分支或else分支作为待执行的剩余计算。</p>


<p>对于while循环，存在一条无条件规则，该规则会展开循环的一次迭代，并引入一个if语句。随后由IF-TRUE和IF-FALSE规则来处理这个if语句。在IF-TRUE情况下，我们最终会再次回到while循环。对于无限循环，这个过程可以永远持续下去。</p>

<pre><code>inductive SmallStep : Stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> Stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> Prop
    where
    | assign (x a s) :
        SmallStep (Stmt.assign x a, s) (Stmt.skip, s[x <span class="math">\(\mapsto\)</span> a s])
    | seq_step (S S' T s s') (hS : SmallStep (S, s) (S', s')) :
        SmallStep (S; T, s) (S'; T, s')
    | seq_skip (T s) :
        SmallStep (Stmt.skip; T, s) (T, s)
    | if_true (B S T s) (hcond : B s) :
        SmallStep (Stmt.ifThenElse B S T, s) (S, s)
    | if_false (B S T s) (hcond : <span class="math">\(\neg\)</span> B s) :
        SmallStep (Stmt.ifThenElse B S T, s) (T, s)
    | whileDo (B S s) :
</code></pre>

<p>在Lean中，小步语义的规范定义如下：</p>

<div class="math">$$
(S, s) \Longrightarrow t \text { if and only if }(S, s) \Rightarrow *(s k i p, t)
$$</div>

<p>小步语义将(Stmt.whileDo B S, s)推导为(Stmt.ifThenElse B (S; Stmt.whileDo B S) Stmt.skip, s)。基于小步语义，我们可以如下定义大步语义：</p>


<p>其中<span class="math">\(p *\)</span>表示二元谓词<span class="math">\(p\)</span>的自反传递闭包（RTC）。或者，如果我们已定义了大步语义，可以通过证明上述等价定理来验证我们的定义。</p>

<div class="math">$$
\text { RTC. head : ?R ?a ?b } \rightarrow \text { RTC ?R ?b ?c } \rightarrow \text { RTC ?R ?a ?c }
$$</div>
<p>小步语义的主要缺点在于我们现在需要处理两个谓词<span class="math">\(\Rightarrow\)</span>和<span class="math">\(\Rightarrow *\)</span>，其推导规则和证明往往比大步语义更复杂。这一点在以下示例中表现得尤为明显，我们需要对每个小步都应用该定理</p>
<pre><code>theorem sillyLoop_from_1_SmallStep :
    (sillyLoop, (fun _ }-&gt;\mathrm{ @)["x" }-&gt;\mathrm{ :]) \ \ }
    (Stmt.skip, (fun _ }-&gt;\mathrm{ @)) :=
    by
        rw [sillyLoop]
        apply RTC.head
        { apply SmallStep.whileDo }
        { apply RTC.head
            { apply SmallStep.if_true
                aesop }
            { apply RTC.head
                { apply SmallStep.seq_step
                    apply SmallStep.seq_skip }
                { apply RTC.head
                    { apply SmallStep.seq_step
                        apply SmallStep.assign }
                        { apply RTC.head
                        { apply SmallStep.seq_skip }
                        { apply RTC.head
                        { apply SmallStep.whileDo }
                        { apply RTC.head
                        { apply SmallStep.if_false
                        simp }
                        { simp
                        apply RTC.refl } } } } } } }
</code></pre>
<p>对每个小步都需应用该定理一次：</p>

<h3>9.6 小步语义的性质</h3>
<p>我们可以证明配置<span class="math">\(S, s\)</span>是终止的当且仅当<span class="math">\(S=s k i p\)</span>。这一证明确保我们没有遗漏任何推导规则，从而保证小步语义不会陷入停滞状态。该定理表述如下：</p>

<div class="math">$$
(\neg \exists T t,(S, s) \Rightarrow(T, t)) \leftrightarrow S=\text { Stmt. skip }
$$</div>

<p>定理 SmallStep_final (S s) :</p>

<pre><code>theorem SmallStep_deterministic {Ss Ll Rr}
    (hl : Ss \Rightarrow Ll) (hr : Ss \Rightarrow Rr) :
Ll = Rr
</code></pre>
<p>该证明基于对<span class="math">\(S\)</span>的结构归纳法。与大步语义类似，小步语义具有确定性：</p>
<div class="math">$$
\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{0}, s_{0}\right) \Rightarrow \cdots
$$</div>

<p>该证明通过对hl或hr的规则归纳进行。对于小步语义而言，若从配置<span class="math">\(\left(S_{0}, s_{0}\right)\)</span>出发的所有执行序列都是有限的，即形如<span class="math">\(\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{1}, s_{1}\right) \Rightarrow \cdots \Rightarrow\left(S_{n}, s_{n}\right)\)</span>，则称该配置终止；若存在无限链<span class="math">\(\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{1}, s_{1}\right) \Rightarrow \cdots\)</span>，则称其不终止。当且仅当所有配置都终止时，该编程语言整体具有终止性。通过令<span class="math">\(S_{0}:=\)</span> Stmt. whileDo (fun_ <span class="math">\(\mapsto\)</span> True) Stmt. skip，可以轻易证明WHILE语言不具备终止性：对于任意<span class="math">\(s_{0}\)</span>，都存在无限执行序列。</p>

<pre><code>theorem SmallStep_skip {S s t} :
    \ ((Stmt.skip, s) \Rightarrow (S, t))
@[simp] theorem SmallStep_seq_Iff {S T s Ut} :
    (S; T, s) <span class="math">\(\Rightarrow\)</span> Ut <span class="math">\(\leftrightarrow\)</span>
    <span class="math">\((\exists S^{\prime} t,(S, s) \Rightarrow\left(S^{\prime}, t\right) \wedge U t=\left(S^{\prime} ; T, t\right))\)</span>
    <span class="math">\(\vee(S=\)</span> Stmt.skip <span class="math">\(\wedge \mathrm{Ut}=(T, s))\)</span>
@[simp] theorem SmallStep_if_Iff \{B S T s Us\} :
    (Stmt.ifThenElse B S T, s) <span class="math">\(\Rightarrow\)</span> Us <span class="math">\(\leftrightarrow\)</span>
    <span class="math">\((B \mathrm{~s} \wedge \mathrm{Us}=(S, s)) \vee(\neg B \mathrm{~B} \wedge \mathrm{Us}=(T, s))\)</span>
</code></pre>

<p>我们可以定义关于小步语义的反演规则，例如：</p>

<pre><code>theorem BigStep_Iff_RTC_SmallStep {Ss t} :
    Ss <span class="math">\(\Longrightarrow t \leftrightarrow S s \Rightarrow *\)</span> (Stmt.skip, t)
</code></pre>

<p>更基础性的结论是大步语义与小步语义之间的等价性：</p>


<p>需注意<span class="math">\(\Rightarrow *\)</span>表示小步语义谓词<span class="math">\(\Rightarrow\)</span>的自反传递闭包。该定理的证明超出本课程范围，建议参阅《Concrete Semantics: With Isabelle/HOL》第七章或本章配套演示文件。</p>

<h2>第十章：霍尔逻辑</h2>
<p>若操作语义对应于理想化的解释器，霍尔逻辑则对应于理想化的验证器。霍尔逻辑可用于规定编程语言的语义，但尤其适用于对具体程序进行推理并证明其正确性。该逻辑以其发明者查尔斯·安东尼·理查德（托尼）·霍尔命名，亦称为公理语义。</p>
<p>本章内容深受《Concrete Semantics: With Isabelle/HOL》第12章的启发。</p>

<h3>10.1 霍尔三元组</h3>
<p>霍尔逻辑是一种通过使用一组推导规则以机械化方式推导有效正确性公式的框架。它允许我们直接对程序语法进行推理，而无需关注其操作语义。这种方法的机械化体现在推导规则的适用性可以轻松验证。</p>


<p>我们首先抽象地引入霍尔逻辑，暂不涉及与Lean的关联。第二步将探讨如何将霍尔逻辑判断嵌入Lean中。霍尔逻辑的基本判断称为霍尔三元组，其形式为<span class="math">\(\{P\} S\{Q\}\)</span>，其中<span class="math">\(S\)</span>是WHILE语句，<span class="math">\(P\)</span>和<span class="math">\(Q\)</span>是关于程序变量的逻辑公式。目前我们可将这些公式视为通过常见连接词和量词构建的语法对象。霍尔三元组的预期含义如下：</p>


<p>若在<span class="math">\(S\)</span>执行前前提条件<span class="math">\(P\)</span>为真且执行正常终止，则终止时后置条件Q为真。</p>


<p>这是一个部分正确性声明：若程序正常终止，则程序是正确的；否则程序可能产生任意行为。对于WHILE程序而言，非正常终止的唯一方式是进入无限循环。对于其他编程语言，无限递归和运行时错误（如除零错误）也可能导致发散或异常终止。</p>

<div class="math">$$
\begin{gathered}
\{\text { True }\} b:=4\{b=4\} \\
\{a=2\} b:=2 * a\{a=2 \wedge b=4\} \\
\{b \geq 5\} b:=b * 1\{b \geq 6\}
\end{gathered}
$$</div>
<div class="math">$$
\begin{gathered}
\{\text { False }\} \text { skip }\{b=10\} \\
\{\text { True }\} \text { while } i \neq 10 \text { do } i:=i+1\{i=10\}
\end{gathered}
$$</div>
<p>直观而言，以下所有霍尔三元组都应该是有效的：</p>

<p>前三个霍尔三元组应相当自然。第四个三元组是空洞成立的，因为前置条件False永远无法满足。霍尔三元组定义中"若前置条件<span class="math">\(P\)</span>为真"这部分始终为假，因此该三元组成立。该三元组等价于命题False<span class="math">\(\rightarrow b=10\)</span>，这对于任意<span class="math">\(b\)</span>值都成立。至于第五个三元组，虽然无法保证控制流会退出循环，但若确实退出，则循环条件在退出时必为假，因此我们得到后置条件<span class="math">\(i=10\)</span>。</p>

<div class="math">$$
\begin{aligned}
&amp; \text { \{False }\} S\{\text { True }\} \\
&amp; \text { \{False }\} S\{\text { False }\} \\
&amp; \text { \{True }\} S\{\text { True }\} \\
&amp; \text { \{True }\} S\{\text { False }\}
\end{aligned}
$$</div>

<p>以下三元组虽然怪异但很有趣：</p>


<p>前两个三元组对任何语句<span class="math">\(S\)</span>都成立（因此毫无意义）：由于前提条件永不被满足，任何后置条件都空洞地成立。第三个三元组同样总是为真，与<span class="math">\(S\)</span>无关。第四个三元组当<span class="math">\(S\)</span>永不终止时为真（例如<span class="math">\(S:=\)</span> while True do skip）；否则为假。</p>


<h3>10.2 霍尔规则</h3>
<p>以下我们给出用于推理WHILE程序的完整推导规则集：</p>


<p><img src="img-8.jpeg" alt="img-8.jpeg"></p>

<div class="math">$$
\{Q[a]\} \times:=a\{Q[x]\}
$$</div>

<p>在ASSIGN规则中，表达式<span class="math">\(Q[a / x]\)</span>表示将条件<span class="math">\(Q\)</span>中所有<span class="math">\(x\)</span>的出现替换为a后的结果。该规则有时被表述为</p>

<div class="math">$$
\{Q[a]\} \times:=a\{Q[x]\}
$$</div>
<div class="math">$$
\text { ASSIGN }
$$</div>

<p>在ASSIGN规则中，表达式<span class="math">\(Q[a / x]\)</span>表示将条件<span class="math">\(Q\)</span>中所有<span class="math">\(x\)</span>的出现替换为a后的结果。该规则有时被表述为</p>


<p>其中<span class="math">\([x]\)</span>表示将<span class="math">\(Q\)</span>中所有<span class="math">\(x\)</span>的出现提取出来。</p>

<div class="math">$$
\begin{gathered}
\{0=0\} x:=0\{x=0\} \\
\{0=0 \wedge y=5\} x:=0\{x=0 \wedge y=5\} \\
\{x+1 \geq 5\} x:=x+1\{x \geq 5\}
\end{gathered}
$$</div>

<p>ASSIGN规则看似违反直觉，因为它是逆向工作的：从后条件出发计算出前条件。然而它准确地捕捉了赋值语句的语义，如下所示：</p>


<p>通过基础算术运算，我们可以简化计算得到的前置条件；例如，<span class="math">\(0=0\)</span>等价于真，而<span class="math">\(x+1 \geq 5\)</span>等价于<span class="math">\(x \geq 4\)</span>。</p>

<table>
<thead>
<tr>
  <th style="text-align:center"><span class="math">\(\{a=2\}\)</span></th>
  <th style="text-align:center"><span class="math">\(b:=a\{b=2\}\)</span></th>
  <th style="text-align:center">ASSIGN</th>
  <th style="text-align:center"><span class="math">\(\{b=2\}\)</span></th>
  <th style="text-align:center"><span class="math">\(c:=b\{c=2\}\)</span></th>
  <th style="text-align:center">ASSIGN</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"></td>
  <td style="text-align:center"><span class="math">\(\{a=2\}\)</span></td>
  <td style="text-align:center"><span class="math">\(b:=a ; c:=b\{c=2\}\)</span></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
</tr>
</tbody>
</table>

<p>Seq规则要求我们提出一个中间条件<span class="math">\(R\)</span>，该条件在执行<span class="math">\(S\)</span>之后且在执行<span class="math">\(T\)</span>之前成立。以下是Seq规则的实际应用示例：</p>


<p>While规则最为复杂。条件<span class="math">\(P\)</span>被称为循环不变量，它既是循环本身的前后条件，也是循环体的前后条件。循环体的前置条件通过<span class="math">\(B\)</span>在执行前必须为真这一认知得到加强；同理，循环的后置条件也通过<span class="math">\(B\)</span>在退出时必须为假这一认知得到强化。</p>

<div class="math">$$
\text { P } s_{0} \quad \text { P } s_{1} \wedge B s_{1} \quad \cdots \quad P s_{n-1} \wedge B s_{n-1} \quad P s_{n} \wedge \neg B s_{n}
$$</div>
<p>考虑一个执行<span class="math">\(n\)</span>次循环迭代的过程。假设初始状态为<span class="math">\(s_{0}\)</span>，且第<span class="math">\(i\)</span>次循环迭代后的状态为<span class="math">\(s_{i}\)</span>，则以下条件成立：</p>
<div class="math">$$
x&gt;8 \rightarrow x&gt;4 \quad \frac{\{x&gt;4\} y:=x\{y&gt;4\}}{\{x&gt;8\} y:=x\{y&gt;0\}} \text { AsGIGN }
$$</div>

<p>若<span class="math">\(n=0\)</span>，则可立即得出<span class="math">\(\mathrm{P} s_{0} \wedge \neg \mathrm{~B} s_{0}\)</span>且不会进入循环。CONSEQ是唯一在其前提中包含逻辑公式（而非霍尔三元组）的规则。这些条件必须被消解，无论是通过纸笔演算还是证明辅助工具。CONSEQ可用于强化前置条件（即增加限制性）、弱化后置条件（即减少限制性）或同时进行二者。示例如下：</p>


<p>从树状结构自上而下阅读时，我们将三元组的前置条件从<span class="math">\(x&gt;4\)</span>强化为<span class="math">\(x&gt;8\)</span>，并将后置条件从<span class="math">\(y&gt;4\)</span>弱化为<span class="math">\(y&gt;0\)</span>。同样可以自下而上解读：要证明三元组<span class="math">\(\{x&gt;8\} y:=x\)</span> <span class="math">\(\{y&gt;0\}\)</span>，只需证明<span class="math">\(\{x&gt;4\} y:=x\{y&gt;4\}\)</span>，其中前置条件被弱化而后置条件被强化。</p>


<p>除CONSEQ规则外，其余规则均为语法驱动型：我们只需检查当前语句即可确定应应用哪条规则。对于赋值语句应用ASSIGN规则，对于while循环应用While规则，以此类推。</p>

<div class="math">$$
\begin{aligned}
&amp; \frac{P \rightarrow Q}{\{P\} \text { skip }\{Q\}} \text { Skip' } \\
&amp; \frac{P \rightarrow Q[a / x]}{\{P\} \times:=a\{Q\}} \text { ASSIGN' } \\
&amp; \frac{\{P \wedge B\} S\{P\} \quad P \wedge \neg B \rightarrow Q}{\{P\} \text { while } B \text { do } S\{Q\}} \text { WHILE' }
\end{aligned}
$$</div>

<p>规则Seq、IF和CONSEQ是双向的：它们的结论形式为<span class="math">\(\{P\} \ldots\{Q\}\)</span>，其中<span class="math">\(P, Q\)</span>是不同的数学变量。这使得这些规则便于应用。通过将其他规则与CONSEQ结合，我们可以推导出双向变体：</p>

<p>作为练习，你可以尝试从SKIP、ASSIGN或WHILE规则出发，结合CONSEQ规则推导出这些规则中的每一个。</p>

<h3>10.3 霍尔逻辑的语义学方法</h3>
<p>在Lean中编码霍尔逻辑的自然方式是延续我们处理大步和小步语义时的做法：定义霍尔三元组的语法概念和一个归纳谓词，每个核心霍尔规则对应一条引入规则；用状态谓词（State <span class="math">\(\rightarrow\)</span> Prop）表示前置条件和后置条件。随后我们可以证明其相对于大步语义的可靠性，即：当<span class="math">\(\{P\} S\{Q\}\)</span>可推导时，若<span class="math">\(P s\)</span>且<span class="math">\((S, s) \Longrightarrow t\)</span>成立，则<span class="math">\(Q t\)</span>成立。这只是对霍尔三元组直观含义的逻辑重述：</p>

<p>若前置条件<span class="math">\(P\)</span>在<span class="math">\(S\)</span>执行前为真（即<span class="math">\(P\)</span> s）且程序正常终止（即<span class="math">\((S, s) \Longrightarrow t\)</span>），则后置条件<span class="math">\(Q\)</span>在终止时成立（即<span class="math">\(Q t\)</span>）。</p>

<p>我们并未采用上述方法，而是选择在Lean中基于大步语义来定义霍尔三元组，从而使其在定义层面即具备正确性。随后我们将霍尔规则作为定理进行推导，而非以引入规则的形式陈述。结合使用谓词来表示公式，这一方法从根本上遵循了语义导向的原则。</p>

<pre><code>def PartialHoare (P : State <span class="math">\(\rightarrow\)</span> Prop) (S : Stmt)
    (Q : State <span class="math">\(\rightarrow\)</span> Prop) : Prop :=
    <span class="math">\(\forall \mathrm{s} \mathrm{t}, \mathrm{P} \mathrm{s} \rightarrow(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \rightarrow \mathrm{Q} \mathrm{t}\)</span>
</code></pre>
<p>霍尔三元组（针对部分正确性）的定义如下：</p>

<p>我们不再书写PartialHoare P S Q，而是引入一些语法糖来允许<span class="math">\(\{* P *\}(S)\{* Q *\}\)</span>这种更接近非正式语法<span class="math">\(\{P\} S\{Q\}\)</span>的表示形式。</p>

<pre><code>theorem skip_intro {P} :
    {* P *} (Stmt.skip) {* P *}
theorem assign_intro (P) {x a} :
    {* fun s }-&gt;\mathrm{P}(\mathrm{s}[\mathrm{x} \mapsto \mathrm{a} \mathrm{s}]) *}\mathrm{ (Stmt.assign x a) {* P *}
theorem seq_intro {P Q R S T} (hS : {* P *} (S) {* Q *})
    (hT : {* Q *} (T) {* R *}) :
    {* P *} (S; T) {* R *}

theorem if_intro {B P Q S T}
    (hS : {* fun s }-&gt;\mathrm{ P s ^ { \Lambda } B s *} (S) {* Q *})
    (hT : {* fun s }-&gt;\mathrm{ P s ^ { \neg } \neg \mathrm { B } \mathrm { s } *} (T) {* Q *}) :
{* P *} (Stmt.ifThenElse B S T) {* Q *}
theorem while_intro (P) {B S}
    (h : {* fun s }-&gt;\mathrm{ P s ^ { \Lambda } B s *} (S) {* P *}) :
{* P *} (Stmt.whileDo B S) {* fun s }-&gt;\mathrm{ P s ^ { \neg } \neg \mathrm { B } \mathrm { s } *}
theorem consequence {P P' Q Q' S}
    (h : {* P *} (S) {* Q *}) (hp : Vs, P' s -&gt; P s)
    (hq : Vs, Q s -&gt; Q' s) :
{* P' *} (S) {* Q' *}
</code></pre>

<p>核心霍尔规则表述如下：</p>


<p>上述所有定理的证明均基于大步语义。部分三元组——例如assign_intro中的前置条件——需要引用状态，此时我们使用匿名函数进行访问。需注意<span class="math">\(P\)</span>与函数<span class="math">\(s \mapsto P s\)</span>是等价的（通过<span class="math">\(\eta\)</span>-转换）。此外，对于非正式写作<span class="math">\(P \rightarrow Q\)</span>的前提条件，在Lean中我们必须写成<span class="math">\(\forall s, P s \rightarrow Q s\)</span>。如第9章所述，赋值规则中的语法<span class="math">\(s[x \mapsto n]\)</span>表示与<span class="math">\(s\)</span>完全相同的状态，只是将<span class="math">\(x\)</span>映射到<span class="math">\(n\)</span>。</p>

<pre><code>theorem consequence_left (P') {P Q S}
    (h : {* P *} (S) {* Q *}) (hp : Vs, P' s -&gt; P s) :
{* P' *} (S) {* Q *}
theorem consequence_right (Q) {Q' P S}
    (h : {* P *} (S) {* Q *}) (hq : Vs, Q s -&gt; Q' s) :
{* P *} (S) {* Q' *}
theorem skip_intro' {P Q} (h : Vs, P s -&gt; Q s) :
{* P *} (Stmt.skip) {* Q *}
theorem assign_intro' {P Q x a}
    (h : Vs, P s -&gt; Q (s[x }-&gt;\mathrm{ a s}])):
{* P *} (Stmt.assign x a) {* Q *}
theorem seq_intro' {P Q R S T} (hT : {* Q *} (T) {* R *})
    (hS : {* P *} (S) {* Q *}) :
{* P *} (S; T) {* R *}
theorem while_intro' {B P Q S} (I)
    (hS : {* fun s }-&gt;\mathrm{ I s ^ { \Lambda } B s *} (S) {* I *})
    (hP : Vs, P s -&gt; I s)
    (hQ : Vs, ~ B s -&gt; I s -&gt; Q s) :
{* P *} (Stmt.whileDo B S) {* Q *}
</code></pre>
<p>以下便利规则可从核心规则中推导得出：</p>
<pre><code>theorem assign_intro_forward (P) {x a} :
    {* P *}
    (Stmt.assign x a)
    {* fun s }-&gt;\mp@subsup{\exists}{n}{o},\mathrm{ P }\left(s[x\leftrightarrow n_{0}\right])
        \wedge s x = a (s[x }\mp@subsup{n}{}{\rightarrow}\mathrm{ n
    by
    apply assign_intro'
    intro s hP
    apply Exists.intro (s x)
    simp [*]
</code></pre>

<p>利用双向规则assign_intro'，我们可以推导出赋值规则的前向版本：</p>

<p>变量<span class="math">\(n_{0}\)</span>表示赋值前<span class="math">\(x\)</span>的值。因此，在后置条件中，<span class="math">\(s\left[x \mapsto n_{0}\right]\)</span>表示赋值前的状态。由于<span class="math">\(P\)</span>是前置条件，我们有<span class="math">\(P\left(s\left[x \mapsto n_{0}\right]\right)\)</span>。此外，<span class="math">\(x\)</span>的新值由<span class="math">\(s x\)</span>给出，必须等于表达式a在旧状态<span class="math">\(s\left[x \mapsto n_{0}\right]\)</span>下的求值结果。</p>
<pre><code>theorem assign_intro_backward (Q) {x a} :
    {* fun s }-&gt;\exists\mathrm{n}^{\prime}, \mathrm{Q}\left(\mathrm{ s[x \mapsto n^{\prime}]}\right) \wedge n^{\prime}=\mathrm{a} \mathrm{ s *}\}
    (Stmt.assign x a)
    {* Q *}
</code></pre>

<p>前向规则不如后向规则方便，因为后置条件中包含存在量词。可以用类似风格表述后向规则，从而揭示隐藏的对称性：</p>

<p>注意这个存在量词可以通过单点规则（第4.3节）消除。随后我们得到熟悉的后向规则assign_intro，其中函数s <span class="math">\(\mapsto\)</span> <span class="math">\(P(s[x \mapsto a s])\)</span>作为前置条件。</p>
<pre><code>def SWAP : Stmt :=
    Stmt.assign "t" (fun s }-&gt;\mathrm{ s "a");
    Stmt.assign "a" (fun s }-&gt;\mathrm{ s "b");
    Stmt.assign "b" (fun s }-&gt;\mathrm{ s "t")
</code></pre>

<h3>10.4 第一个程序：交换两个变量</h3>
<p>让我们运用霍尔逻辑来验证第一个程序：一个三行程序，它使用临时存储变量<span class="math">\(t\)</span>来交换变量<span class="math">\(a\)</span>和<span class="math">\(b\)</span>的值。该程序定义如下：</p>

<pre><code>theorem SWAP_correct (a b b o : N) :
    {* fun s }-&gt;\mathrm{ s "a" = a b \wedge s "b" = b b *}
    (SWAP)
    {* fun s }-&gt;\mathrm{ s "a" = b b \wedge s "b" = a b *}
</code></pre>

<p>正确性声明如下：</p>


<p>逻辑变量<span class="math">\(a_{0}\)</span>和<span class="math">\(b_{0}\)</span>用于"冻结"程序变量<span class="math">\(a\)</span>和<span class="math">\(b\)</span>的初始值，以便我们可以在后置条件中引用它们。毕竟，使用函数<span class="math">\(s \mapsto s\)</span> "a" <span class="math">\(=s\)</span> "b" <span class="math">\(\wedge s\)</span> "b" <span class="math">\(=s\)</span> "a"作为后置条件是毫无意义的。</p>

<pre><code>apply PartialHoare.seq_intro'
apply PartialHoare.seq_intro'
apply PartialHoare.assign_intro
apply PartialHoare.assign_intro
apply PartialHoare.assign_intro'
aesop
</code></pre>
<p>正确性证明如下：</p>
<pre><code>\foralls : State,
    <span class="math">\(s " a "=a_{0} \wedge s " b "=b_{0} \rightarrow\)</span>
    <span class="math">\(s[" t " \mapsto s " a " \left[" a " \mapsto s[" t " \mapsto s " a " \left[" b "\right]\right.\)</span>
        ["b" <span class="math">\(\mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left.\left.[" a " \mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left[" b "\right]\right] \mathrm{t} " \mathrm{t} " \mathrm{a} "=\mathrm{b}_{0} \wedge\right.\)</span>
    <span class="math">\(s[" t " \mapsto s " a " \left[" a " \mapsto s[" t " \mapsto s " a " \left[" b "\right]\right.\)</span>
        ["b" <span class="math">\(\mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left.\left.[" a " \mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left[" b "\right]\right] \mathrm{t} " \mathrm{t} " \mathrm{b} "=\mathrm{a}_{0}\)</span>
</code></pre>

<p>顺序组合规则和赋值规则的应用由程序语法引导。该程序中有两个顺序组合和三个赋值，因此需要相应次数的规则调用。最终我们得到一个极不美观的子目标：</p>


<p>幸运的是，simp [*] at * 可以大幅简化该子目标，甚至aesop能完全自动地证明它。</p>

<pre><code>def ADD : Stmt :=
    Stmt.whileDo (fun s }\mapsto\mathrm{ s "n" \neq \emptyset)
        (Stmt.assign "n" (fun s }\mapsto\mathrm{ s "n" - 1);
        Stmt.assign "m" (fun s }\mapsto\mathrm{ s "m" + 1))
</code></pre>

<h3>10.5 第二个程序：两数相加</h3>
<p>我们的第二个示例通过仅使用以下基本操作：<span class="math">\(k+1, k-1\)</span>和<span class="math">\(k \neq \emptyset\)</span>（对于任意<span class="math">\(k\)</span>），计算<span class="math">\(m+n\)</span>并将结果保留在<span class="math">\(m\)</span>中：</p>

<pre><code>theorem ADD_correct ( }\mathrm{n}_{0}\mathrm{ m}_{0}: \mathbb{N}\mathrm{ ):
    {* fun s }\mapsto\mathrm{ s "n" = n
    (ADD)
    {* fun s }\mapsto\mathrm{ s "n" = 0 \wedge s "m" = n
    PartialHoare.while_intro' (fun s }\mapsto\mathrm{ s "n" + s "m" = n
    (by
        apply PartialHoare.seq_intro'
        { apply PartialHoare.assign_intro }
        { apply PartialHoare.assign_intro'
            aesop })
    (by aesop)
    (by aesop)
</code></pre>
<p>由于存在while循环，该证明过程更为复杂：</p>

<p>第一步是应用带有循环不变式的派生while规则。我们的不变式要求程序变量<span class="math">\(n\)</span>和<span class="math">\(m\)</span>之和必须等于期望的数学结果<span class="math">\(n_{0}+m_{0}\)</span>，其中<span class="math">\(n_{0}\)</span>和<span class="math">\(m_{0}\)</span>对应<span class="math">\(n\)</span>和<span class="math">\(m\)</span>的初始值，正如前置条件所要求的。</p>

<p>我们是如何得出这个不变式的？即便对于简单循环，找到合适的不变式也可能颇具挑战性。难点在于不变式必须：1. 在进入循环时为真；2. 若迭代前为真，则在每次迭代后保持为真；3. 足够强以蕴含所需的循环后条件。</p>

<p>诸如True这样的不变量满足要求1和2，但通常不满足3。类似地，False满足要求2和3但不满足1。实践中，不变量往往采用"已完成工作 + 剩余工作 = 期望结果"的形式，其中+代表某种适当的运算符（不一定是加法）。进入循环时，已完成工作通常为o（或其他适当的"零"值），此时不变量变为"剩余工作 = 期望结果"。该等式必须在循环开始时可被证明——要么来自前一条语句的后置条件，若无前驱语句则来自整个程序的期望前置条件。退出循环时，剩余工作应为o（或其变体），此时不变量变为"已完成工作 = 期望结果"。通常，已完成工作表现为存储结果的累加变量，而剩余工作类似于期望结果但取决于循环内变化的程序变量，并需考虑已完成工作的部分。</p>


<p>对于ADD程序的循环而言，已完成的工作量为<span class="math">\(m\)</span>，剩余工作量为<span class="math">\(n\)</span>，期望结果为<span class="math">\(n_{0}+m_{0}\)</span>。进入循环时，不变量<span class="math">\(m=n=n_{0}+m_{0}\)</span>成立，因为此时<span class="math">\(m=m_{0}\)</span>且<span class="math">\(n=n_{0}\)</span>。（此例特殊之处在于已完成工作量不为o，因为我们复用输入值<span class="math">\(m\)</span>作为累加器以优化性能。）退出循环时满足<span class="math">\(n=0\)</span>，此时不变量变为<span class="math">\(m=n_{0}+m_{0}\)</span>，最终结果可从<span class="math">\(m\)</span>中提取。</p>


<p>while_intro'定理被直接用作证明项。它会产生三个子目标。证明不变式由期望前置条件蕴含以及它蕴含期望后置条件的部分都是平凡的：仅需调用aesop即可。唯一非平凡的子目标是执行循环体时保持不变式的条件。</p>


<p>在这个例子中，霍尔逻辑确实大有裨益。直接基于操作语义进行推理会很不方便，因为我们需要用归纳法来处理while循环。而通过霍尔逻辑，这种归纳只需在while_intro规则的证明中一次性完成。</p>

<h3>10.6 验证条件生成器</h3>
<p>验证条件生成器（VCG）是应用霍尔逻辑规则的程序，它会生成需要手动证明的验证条件。我们可以将其视为处理霍尔逻辑文书工作的机械公务员。作为用户，我们必须在程序中提供足够强大的循环不变式作为注解。数以百计的程序验证工具都基于这些原理构建。</p>
<p>验证条件生成器通常从后置条件开始逆向工作，运用那些将任意Q作为其后置条件的逆向规则。这种方式行之有效，因为霍尔逻辑的核心规则——赋值规则——本身就是逆向的。</p>
<pre><code>def Stmt.invWhileDo (I B : State <span class="math">\(\rightarrow\)</span> Prop) (S : Stmt) : Stmt :=
    Stmt.whileDo B S
</code></pre>
<p>我们可以利用Lean的元编程框架来定义一个简单的验证条件生成器(VCG)。首先，我们引入一个名为Stmt.invWhileDo的常量，该常量除了循环条件B和循环体S外，还携带用户提供的循环不变式I：</p>
<pre><code>theorem invWhile_intro <span class="math">\(\{B\)</span> I Q S\}
    <span class="math">\((h S:\{ *\)</span> fun <span class="math">\(s \mapsto I s \wedge B s *\}(S)\{ * I *\})\)</span>
    <span class="math">\((h Q: \forall s, \neg B s \rightarrow I s \rightarrow Q s)\)</span> :
    <span class="math">\(\{* I *\}(\)</span> Stmt.invWhileDo I B S) \{* Q *\} :=
    while_intro' I hS (by aesop) hQ
theorem invWhile_intro' \{B I P Q S\}
    <span class="math">\((h S:\{ *\)</span> fun <span class="math">\(s \mapsto I s \wedge B s *\}(S)\{ * I *\})\)</span>
    <span class="math">\((h P: \forall s, P s \rightarrow I s)(\mathrm{hQ}: \forall s, \neg B s \rightarrow I s \rightarrow Q s)\)</span> :
    <span class="math">\(\{* P *\}(\)</span> Stmt.invWhileDo I B S) \{* Q *\} :=
    while_intro' I hS hP hQ
</code></pre>

<p>我们为该结构提供了两条霍尔规则：一条反向规则和一条双向规则。这两条规则都基于双向的while_intro'规则进行验证：</p>


<p>上述规则直接将不变式注解作为其循环不变式使用。在使用该框架时，我们必须注意为所有while循环添加合适的不变式注解。若指定了错误的不变式，将会遇到无法证明的子目标，这表明我们需要修正该不变式。</p>

<pre><code>def matchPartialHoare : Expr <span class="math">\(\rightarrow\)</span> Option (Expr <span class="math">\(\times\)</span> Expr <span class="math">\(\times\)</span> Expr)
    | (Expr.app (Expr.app (Expr.app
        (Expr.const ''PartialHoare _) P) S) Q) =&gt;
        Option.some (P, S, Q)
    | _ =&gt;
        Option.none
partial def vcg : TacticM Unit :=
    do
        let goals <span class="math">\(\leftarrow\)</span> getUnsolvedGoals
        if goals.length != 0 then
            let target <span class="math">\(\leftarrow\)</span> getMainTarget
            match matchPartialHoare target with
            | Option.none =&gt; return
            | Option.some (P, S, Q) =&gt;
            if Expr.isAppOfArity S ''Stmt.skip 0 then
                if Expr.isMVar P then
                applyConstant ''PartialHoare.skip_intro
                else
                applyConstant ''PartialHoare.skip_intro'
            else if Expr.isAppOfArity S ''Stmt.assign 2 then
                if Expr.isMVar P then
                applyConstant ''PartialHoare.assign_intro
                else

    applyConstant ''PartialHoare.assign_intro'
else if Expr.isAppOfArity S ''Stmt.seq 2 then
    andThenOnSubgoals
        (applyConstant ''PartialHoare.seq_intro') vcg
else if Expr.isAppOfArity S ''Stmt.ifThenElse 3 then
        andThenOnSubgoals
            (applyConstant ''PartialHoare.if_intro) vcg
else if Expr.isAppOfArity S ''Stmt.invWhileDo 3 then
        if Expr.isMVar P then
            andThenOnSubgoals
                (applyConstant ''PartialHoare.invWhile_intro) vcg
            else
                andThenOnSubgoals
                (applyConstant ''PartialHoare.invWhile_intro')
                vcg
            else
                failure
elab "vcg" : tactic =&gt;
vcg
</code></pre>

<p>验证条件生成器(VCG)的代码相当简洁：</p>

<p>VCG会提取第一个目标的目标并检查它。如果它是一个霍尔三元组，VCG会检查其前置条件<span class="math">\(P\)</span>和语句<span class="math">\(S\)</span>。如果前置条件是一个元变量（例如?P），VCG会应用反向规则（通过我们在8.7节定义的apply Constant函数），前提是该规则存在，因为这将实例化该元变量。否则，会使用双向规则，以一个任意变量作为其前置条件，该变量可以与目标的前置条件进行匹配。对于while循环，我们只考虑使用Stmt.invWhileDo的程序，因为通常我们无法通过编程方式猜测不变式。</p>

<p>验证条件生成器（VCG）会递归调用自身处理复合语句中新产生的所有子目标（通过我们在8.7节定义的andThenOnSubgoals函数实现）。</p>

<pre><code>theorem ADD_correct_vcg ( }\mp@subsup{n}{0}{}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\)
    (ADD)
    {* fun s \mapsto s "n" = 0 ^ { \pm } \mp@subsup { \pm } { \pm } \mp@subsup { \pm } { \pm } \mathrm { m } " = \mp@subsup { n } { \pm } { \pm } }
    (Stmt.invWhileDo (fun s \mapsto s "n" + s "m" = n }\mp@subsup{n}{0}{}\mathrm{ + m}\mp@subsup{}{0}\)
        (fun s \mapsto s "n" \neq 0)
        (Stmt.assign "n" (fun s \mapsto s "n" - 1);
        Stmt.assign "m" (fun s \mapsto s "m" + 1)))
    {* fun s \mapsto s "n" = 0 ^ { \pm } \mp@subsup { \pm } { \pm } \mp@subsup { \pm } { \pm } " \mathrm { m } " = \mp@subsup { n } { \pm } { \pm } \mp@subsup { \pm } { \pm } } " \mathrm { m } " = \mp@subsup { n } { \pm } { \pm } \mp@subsup { \pm } { \pm } \mathrm { m } " }
    by
    vcg &lt;;&gt;
        aesop
</code></pre>

<h3>10.7 重访第二个程序：两数相加</h3>
<p>借助验证条件生成器，我们可以重新审视前述ADD程序的正确性证明：</p>


<p>首先，我们使用show命令为while循环添加不变式注解。需要强调的是，show命令会以计算等价的方式重新表述目标。此处我们利用这一功能，将Stmt.whileDo替换为Stmt.invWhileDo——根据定义二者等价。程序及其前置/后置条件均与定理陈述中的原始形式保持一致。</p>


<p>我们首先调用vcg作为证明的第一步。这将应用所有必要的霍尔规则，并留下一些子目标，这些目标对aesop来说不成问题。</p>

<h3>10.8 完全正确性的霍尔三元组</h3>
<p>本章至此主要关注的是部分正确性。当我们表述霍尔三元组<span class="math">\(\{P\} S\{Q\}\)</span>时，我们声称若程序<span class="math">\(S\)</span>终止，则最终状态将满足<span class="math">\(Q\)</span>，但对于<span class="math">\(S\)</span>不终止的情况未作任何断言。特别地，我们可以为发散程序while True do skip证明任何后置条件。这显然过于宽松：如果在考试中被要求编写排序算法，你当然不应该用while True do skip作为答案。</p>

<p>完全正确性是比部分正确性更强的概念，它在部分正确性的基础上额外断言程序会正常终止。我们最初聚焦于部分正确性，是因为它更简单，且无论如何都是完全正确性的必要组成部分。</p>


<p>完全正确性的霍尔三元组具有形式<span class="math">\([P] S[Q]\)</span>，其预期含义如下：</p>


<p>若在<span class="math">\(S\)</span>执行前满足前置条件<span class="math">\(P\)</span>，则程序将正常终止，且最终状态满足后置条件<span class="math">\(Q\)</span>。</p>


<p>对于确定性程序，这可以等价表述为：若在<span class="math">\(S\)</span>执行前满足前置条件<span class="math">\(P\)</span>，则存在一个状态使得执行正常终止，且在该状态下满足后置条件<span class="math">\(Q\)</span>。</p>

<div class="math">$$
[i \leq 10] \text { while } i&lt;10 \text { do } i:=i+1[i=10]
$$</div>
<p>以下是一个有效的霍尔三元组示例：</p>
<div class="math">$$
\frac{\left[P \wedge B \wedge v=v_{0}\right] S\left[P \wedge v&lt;v_{0}\right]}{\left[P\right] \text { while } B \text { do } S[P \wedge \neg B]} \text { WHILE-VAR }
$$</div>
<p>对于WHILE语言而言，部分正确性与完全正确性的区别仅涉及while循环（以及包含它们的程序）。此时while循环的霍尔规则必须通过变体v进行标注——这是一个自然数，每次迭代会减少一个或多个单位：</p>

<p>此处，<span class="math">\(v_{0}\)</span>是一个逻辑变量，用于冻结v的初始值，其作用域覆盖整个前提；而<span class="math">\(v\)</span>是数学变量（如<span class="math">\(P, B\)</span>和<span class="math">\(S\)</span>）。对于前例，我们可以采用<span class="math">\(10-1\)</span>作为变体（或<span class="math">\(50-1\)</span>，亦或<span class="math">\(1024-1 * i\)</span>）。</p>

<table>
<thead>
<tr>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{0}\)</span></th>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{1} \wedge \mathrm{BS}_{1}\)</span></th>
  <th style="text-align:center"><span class="math">\(\cdots\)</span></th>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{n-1} \wedge \mathrm{BS}_{n-1}\)</span></th>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{n} \wedge \neg \mathrm{BS}_{n}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{0}\)</span></td>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{1}\)</span></td>
  <td style="text-align:center"><span class="math">\(\cdots\)</span></td>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{n-1}\)</span></td>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{n}\)</span></td>
</tr>
</tbody>
</table>

<p>考虑一个对应于<span class="math">\(n\)</span>次循环迭代的执行序列<span class="math">\(s_{0}, s_{1}, \ldots, s_{n-1}, s_{n}\)</span>，如第10.2节所述。以下条件将成立：</p>

<p>关于完全正确性的霍尔三元组理论将在本章练习中展开讨论。</p>

<h2>第11章：指称语义</h2>
<p>我们现在回顾第三种编程语言语义的规范方法：指称语义。指称语义直接将程序的含义指定为数学对象。如果说操作语义对应于理想化的解释器，霍尔逻辑对应于理想化的验证器，那么指称语义就对应于理想化的编译器：这种编译器不是将源程序翻译成汇编语言，而是直接翻译成数学对象。</p>


<p>本章核心内容紧密参照了《Concrete Semantics: With Isabelle/HOL》第11章的模型。</p>

<div class="math">$$
\llbracket \rrbracket: \text { syntax } \rightarrow \text { semantics }
$$</div>

<h3>11.1 组合性</h3>
<p>指称语义将每个程序的含义定义为数学对象。抽象地说，它可以被视为一个函数</p>

<div class="math">$$
\llbracket S \rrbracket=\{(s, t) \mid(S, s) \Longrightarrow t\}
$$</div>
<p>指称语义学的关键特性是组合性：复合语句的含义应依据其组成部分的含义来定义。考虑以下基于大步语义（<span class="math">\(\Longrightarrow\)</span>）的直观定义</p>
<div class="math">$$
\llbracket S \rrbracket=\{s t \mid(S, \text { Prod.fst st }) \Longrightarrow \text { Prod.snd st }\}
$$</div>

<p>基于大步语义（<span class="math">\(\Longrightarrow\)</span>）的表述。实际上，由于Lean仅支持竖线左侧使用变量，我们必须写成</p>


<p>该定义明确了期望的语义，但由于缺乏组合性，它不能被视为指称语义：复合语句（顺序组合、条件分支和循环）的含义是直接给出的，而没有使用其组成部分的指称。</p>

<div class="math">$$
\begin{aligned}
&amp; \llbracket S ; T \rrbracket=\ldots \llbracket S \rrbracket \ldots \llbracket T \rrbracket \ldots \\
&amp; \llbracket \text { if } B \text { then } S \text { else } T \rrbracket=\ldots \llbracket S \rrbracket \ldots \llbracket T \rrbracket \ldots \\
&amp; \llbracket \text { while } B \text { do } S \rrbracket=\ldots \llbracket S \rrbracket \ldots
\end{aligned}
$$</div>

<p>完全组合式的定义允许我们对程序进行等式推理，这通常比使用<span class="math">\(\Longrightarrow\)</span>的引入、消去和反转原则更为方便。本质上，我们需要形如以下的结构递归方程：</p>

<div class="math">$$
\text { eval }: \underbrace{\operatorname{AExp}}_{\text {syntax }} \rightarrow \underbrace{(\operatorname{String} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Z}}_{\text {semantics }}
$$</div>

<p>在右侧不出现<span class="math">\(S\)</span>和<span class="math">\(T\)</span>的情况下，除非它们作为<span class="math">\(\llbracket \rrbracket\)</span>的参数。一个用于算术表达式的求值函数</p>

<div class="math">$$
\text { eval (AExp.add } e_{1} e_{2} \text { ) env = eval } e_{1} \text { env + eval } e_{2} \text { env }
$$</div>

<p>满足如下等式</p>


<p>这是一种指称语义，因为AExp.add <span class="math">\(e_{1} e_{2}\)</span> 的语义是根据<span class="math">\(e_{1}\)</span>和<span class="math">\(e_{2}\)</span>的语义来定义的。</p>

<p>指称语义天然适用于算术表达式和函数式程序。现在我们希望为命令式程序建立一种便捷的指称语义。由于while循环可能不终止的特性，我们需要发展额外的数学概念，才能构建出所需的语义框架。</p>

<h3>11.2 关系指称语义</h3>
<p>确定性语言的指称语义通常被定义为从前状态到后状态的函数，但关系更为通用且更便于操作。我们在此提出一种关系指称语义方法。</p>

<p>程序的指称语义将是一个类型为Set (State <span class="math">\(\times\)</span> State)的数学对象。这种关系方法同样被用于大步语义，后者采用类型为State <span class="math">\(\rightarrow\)</span> State <span class="math">\(\rightarrow\)</span> Prop的谓词形式。这两种类型是同构的，但定义为<span class="math">\(\alpha \rightarrow\)</span> Prop的Set <span class="math">\(\alpha\)</span>支持许多有用操作和符号表示，例如<span class="math">\(\emptyset, \cup, \cap, \in\)</span>以及<span class="math">\(\{\ldots \mid \ldots\}\)</span>（第7.7节）。</p>
<pre><code>def denote : Stmt <span class="math">\(\rightarrow\)</span> Set (State <span class="math">\(\times\)</span> State)
    | Stmt.skip <span class="math">\(\quad=&gt;\)</span> Id
    | Stmt.assign x a <span class="math">\(\quad=&gt;\)</span>
        <span class="math">\(\{\)</span> st | Prod.snd st <span class="math">\(=\left(\right.\)</span> Prod.fst st) <span class="math">\([x \mapsto\)</span> a (Prod.fst st) <span class="math">\()\}\)</span>
    | Stmt.seq S T <span class="math">\(\quad=&gt;\)</span> denote <span class="math">\(S \bigcirc\)</span> denote T
    | Stmt.ifThenElse B S T =&gt;
        (denote S ; B) <span class="math">\(\cup\)</span> (denote <span class="math">\(\mathrm{T} ;\)</span> (fun <span class="math">\(\mathrm{s} \mapsto \neg \mathrm{B} \mathrm{s}\)</span> ))
</code></pre>

<p>我们的语义命名为denote，其中<span class="math">\(\llbracket \rrbracket\)</span>作为语法糖。我们先给出定义的前四个等式，而将while语句留待后续处理：</p>


<p>skip语句被解释为状态上的恒等关系——即所有形如( <span class="math">\(s, s\)</span> )的元组集合。这捕捉了skip语句的预期语义：后状态始终与前状态完全相同。</p>


<p>赋值语句的语义是满足第二个分量反映赋值结果的所有元组集合。</p>

<div class="math">$$
r_{1} \bigcirc r_{2}=\{\mathrm{ac} \mid \exists b,(\text { Prod.fst ac, b }) \in r_{1} \wedge(b, \text { Prod.snd ac }) \in r_{2}\}
$$</div>

<p>顺序组合的语义可优雅地表示为关系组合<span class="math">\(\bigcirc\)</span>，其由以下方程定义</p>

<div class="math">$$
r_{1} \bigcirc r_{2}=\left\{(a, c) \mid \exists b,(a, b) \in r_{1} \wedge(b, c) \in r_{2}\right\}
$$</div>
<p>若将其表示为以下形式，或许更易于理解：</p>
<p>遗憾的是，Lean无法处理这种形式；推导式左侧必须是一个单一变量。</p>
<div class="math">$$
r: P=\{a b \mid a b \in r \wedge P(\text { Prod.fst } a b)\}
$$</div>

<p>if-then-else语句的语义被定义为两个分支语义的并集，并限制仅包含那些第一个分量使布尔条件为真或假的元组（具体取决于分支）。限制运算符的定义如下：</p>

<div class="math">$$
r: P=\{(a, b) \mid(a, b) \in r \wedge P a\}
$$</div>

<p>更直观的定义应该是</p>

<p>但Lean同样不支持这种定义。注意两个退化情况：若<span class="math">\(P:=\)</span> (fun <span class="math">\(\rightarrow \mapsto\)</span> True)，则<span class="math">\(r: P=r\)</span>；若<span class="math">\(P:=\)</span> (fun_ <span class="math">\(\mapsto\)</span> False)，则<span class="math">\(r: P=\emptyset\)</span>。</p>
<pre><code>| Stmt.whileDo B S =&gt;
    ((denote S ○ denote (Stmt.whileDo B S)) : B)
    \cup (Id ; (fun s \mapsto \neg B s))
</code></pre>

<p>当我们尝试定义while循环的语义时，困难就出现了。我们希望能写成</p>

<div class="math">$$
X=((\text { denote } S \bigcirc X) ; B) \cup(\text { Id } ;(\text { fun } s \mapsto \neg B s))
$$</div>
<p>但这种方法由于对Stmt. whileDo B S的递归调用而缺乏良好基础。我们需要其他解决方案。在等式右侧，我们寻找的是满足方程<span class="math">\(X\)</span>的某个项</p>
<pre><code>| Stmt.whileDo B S =&gt;
    lfp (fun X \mapsto((denote S \bigcirc X) ; B)
        \cup (Id ; (fun s \mapsto \neg B s)))
</code></pre>

<p>我们正在寻找数学家所称的不动点。接下来四个章节将专注于构建一个名为lfp的算子，用于计算给定方程的不动点。通过lfp，我们将能够用以下方式定义while循环的语义：</p>

<div class="math">$$
X=f X
$$</div>

<h3>11.3 不动点</h3>
<p>函数<span class="math">\(f\)</span>的不动点是指方程<span class="math">\(X\)</span>的解满足</p>


<p>一般而言，某些函数<span class="math">\(f\)</span>可能根本不存在不动点；例如，若<span class="math">\(f:=\)</span> Nat.succ（自然数后继函数），则不存在满足<span class="math">\(X=\)</span> Nat.succ <span class="math">\(X\)</span>的值<span class="math">\(X\)</span>。也可能存在多个不动点；例如当<span class="math">\(f:=(f u n x \mapsto x)\)</span>时，任何<span class="math">\(X\)</span>都是方程<span class="math">\(X=(f u n\)</span> <span class="math">\(x \mapsto x) X=X\)</span>的解。在<span class="math">\(f\)</span>满足特定条件的情况下，可以保证存在唯一最小不动点和唯一最大不动点。</p>

<div class="math">$$
X=(\text { fun } n: \mathbb{N} \mapsto n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge X m))
$$</div>

<p>考虑以下不动点方程，其中<span class="math">\(X: \mathbb{N} \rightarrow\)</span> Prop：</p>

<div class="math">$$
X=\overbrace{(\text { fun }(P: \mathbb{N} \rightarrow \text { Prop })(n: \mathbb{N}) \mapsto n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge P m))}^{\mathrm{f}}
$$</div>
<p>该方程是符合右侧格式的<span class="math">\(\beta\)</span>规约变体：</p>
<div class="math">$$
\text { Even } n \leftrightarrow n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge \text { Even } m)
$$</div>

<p>一个解是<span class="math">\(X:=\)</span> Even，即表征偶数自然数的谓词。回想我们在6.5节中已证明的反演规则</p>

<div class="math">$$
X=(\text { fun } P \mapsto P) X
$$</div>

<p>在6.5节中已证明，事实上偶数是唯一的不动点。通常情况下，最小不动点和最大不动点可能不同。考虑方程</p>


<p>对于<span class="math">\(X: \mathbb{N} \rightarrow\)</span> Prop而言，其最小不动点为<span class="math">\(fun \_\mapsto False\)</span>，最大不动点为<span class="math">fun \(\_\) \(\mapsto\) True</span>。根据约定，我们有False &lt; True，因此(fun _ <span class="math">\(\mapsto\)</span> False) &lt; (fun_ <span class="math">\(\mapsto\)</span> True)。类似地，对于任何非空类型<span class="math">\(\alpha\)</span>，都有<span class="math">\(\emptyset&lt;\varnothing\)</span> Set.univ <span class="math">\(\alpha\)</span>。</p>


<p>对于while循环的语义，<span class="math">\(X\)</span>将具有类型Set (State <span class="math">\(\times\)</span> State)即状态间的关系，而<span class="math">\(f\)</span>对应于要么执行循环的额外一次迭代（若条件B为真），要么保持恒等关系（若B为假）。</p>


<p>对于while循环的语义，我们应选用何种不动点？最大不动点虽允许循环及发散式执行，但最小不动点仅支持有限（尽管可能无界）的执行过程。因此我们选择最小不动点。</p>


<h3>11.4 单调函数</h3>
<p>前文我们声称在<span class="math">\(f\)</span>满足某些条件时，最小与最大不动点的存在性是有保证的。现在需要更精确地表述这一点。设<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>为任意类型，各自配备偏序关系<span class="math">\(\leq\)</span>。若函数<span class="math">\(f: \alpha \rightarrow \beta\)</span>满足对所有<span class="math">\(a, b\)</span>都有<span class="math">\(a \leq b \rightarrow f a \leq f b\)</span>，则称该函数是单调的。当<span class="math">\(f: \operatorname{Set} \alpha \rightarrow \operatorname{Set} \alpha\)</span>是单调函数时，它必然存在最小和最大不动点。</p>

<div class="math">$$
f A=(\text { if } A=\emptyset \text { then Set.univ else } \emptyset)
$$</div>
<p>集合上的许多操作（例如并集<span class="math">\(\cup\)</span>）、关系（例如复合运算<span class="math">\(\bigcirc\)</span>）以及函数（例如恒等函数fun <span class="math">\(x \mapsto x\)</span>、常函数fun <span class="math">\(\_\)</span> <span class="math">\(\mapsto k\)</span>、复合运算<span class="math">\(\circ\)</span>）都具有单调性或保持单调性。当然，并非所有函数都是单调的。这里给出一个在Set <span class="math">\(\alpha\)</span>上关于偏序<span class="math">\(\subseteq\)</span>的非单调函数<span class="math">\(f\)</span>示例：</p>
<p>若 <span class="math">\(\alpha\)</span> 非空，则有 <span class="math">\(\emptyset \subseteq\)</span> Set.univ 但 <span class="math">\(f \emptyset=\)</span> Set.univ <span class="math">\(\nsubseteq \emptyset=f\)</span> Set.univ。</p>
<div class="math">$$
\bigcap X=\{a \mid \forall A, A \in X \rightarrow a \in A\}
$$</div>

<h3>11.5 完全格</h3>
<p>为定义集合（包括关系）的最小不动点，我们需要两种运算：子集关系<span class="math">\(\subseteq\)</span> : Set <span class="math">\(\alpha \rightarrow\)</span> Set <span class="math">\(\alpha \rightarrow\)</span> Prop 和大交集运算<span class="math">\(\cap\)</span> : Set (Set <span class="math">\(\alpha\)</span> ) <span class="math">\(\rightarrow\)</span> Set <span class="math">\(\alpha\)</span>，其定义如下：</p>


<p>若<span class="math">\(X\)</span>是有限集<span class="math">\(\left\{A_{1}, \ldots, A_{n}\right\}\)</span>，则<span class="math">\(\bigcap X=A_{1} \cap \cdots \cap A_{n}\)</span>。</p>


<p>我们可以更广义地定义lfp（最小不动点），使其不仅适用于集合，还能作用于称为完全格的任何代数结构实例。一个完全格由以下要素构成：</p>
<ol>
<li>一个类型<span class="math">\(\alpha\)</span>；</li>
<li>一个偏序关系<span class="math">\(\leq: \alpha \rightarrow \alpha \rightarrow\)</span> Prop（即自反、反对称且传递的二元谓词）；</li>
<li>一个称为下确界的运算符<span class="math">\(\Pi\)</span> : Set <span class="math">\(\alpha \rightarrow \alpha\)</span>。</li>
</ol>


<p>算子<span class="math">\(\Pi\)</span>满足以下两个条件：</p>
<ol>
<li>
<span class="math">\(\Pi\)</span> A是A的下界：对所有<span class="math">\(b \in A\)</span>，有<span class="math">\(\Pi A \leq b\)</span>；</li>
<li>
<span class="math">\(\Pi\)</span> A是最大下界：对所有满足<span class="math">\(\forall a, a \in A \rightarrow b \leq a\)</span>的<span class="math">\(b\)</span>，有<span class="math">\(b \leq \Pi\)</span> A。</li>
</ol>


<p>条件1和2共同确保了<span class="math">\(\Pi\)</span> A是唯一的最大下界。格算子<span class="math">\(\leq\)</span>和<span class="math">\(\square\)</span>推广了<span class="math">\(\subseteq\)</span>：集合<span class="math">\(\alpha \rightarrow\)</span> 集合<span class="math">\(\alpha \rightarrow\)</span> 命题，而<span class="math">\(\square\)</span>：集合（集合<span class="math">\(\alpha\)</span>）<span class="math">\(\rightarrow\)</span> 集合<span class="math">\(\alpha\)</span>。需注意<span class="math">\(\square\)</span> A不一定属于A。例如，实数集上的开区间<span class="math">\(] a, b[\)</span>的下确界<span class="math">\(\left.a \notin\right] a, b[\)</span>。集合的下确界是最小元概念的推广。</p>


<p>以下是几个完全格的示例：</p>
<ul>
<li>对于所有类型<span class="math">\(\alpha\)</span>，集合Set <span class="math">\(\alpha\)</span>关于<span class="math">\(\subseteq\)</span>和<span class="math">\(\cap\)</span>构成完全格；</li>
<li>命题Prop关于<span class="math">\(\rightarrow\)</span>及函数<span class="math">\(A \mapsto \forall a \in A, a\)</span>构成完全格；</li>
<li>扩展自然数ENat <span class="math">\(:=\mathbb{N} \cup\{\infty\}\)</span>关于<span class="math">\(\leq\)</span>及适当的下确界算子构成完全格；</li>
<li>扩展实数EReal <span class="math">\(:=\mathbb{R} \cup\{-\infty, \infty\}\)</span>关于<span class="math">\(\leq\)</span>及适当的下确界算子构成完全格。</li>
</ul>


<p>若<span class="math">\(\alpha\)</span>是完备格，则<span class="math">\(\beta \rightarrow \alpha\)</span>亦为完备格。若<span class="math">\(\alpha\)</span>与<span class="math">\(\beta\)</span>均为完备格，则<span class="math">\(\alpha \times \beta\)</span>亦为完备格。两种情形下，<span class="math">\(\leq\)</span>与<span class="math">\(\square\)</span>均按分量定义。</p>


<p>以下是一些非完备格的例子：关于<span class="math">\(\leq\)</span>的<span class="math">\(\mathbb{N}, \mathbb{Z}, \mathbb{Q}\)</span>以及<span class="math">\(\mathbb{R}\)</span>。问题在于无法为<span class="math">\(\Pi \emptyset\)</span>指定最大元素。另一个非完备格例子是ERat<span class="math">\(:=\mathbb{Q} \cup\{-\infty, \infty\}\)</span>，因为<span class="math">\(\Pi\{q \mid 2&lt;q * q\}=\)</span> sqrt 2不属于ERat。</p>

<pre><code>class CompleteLattice ( }\alpha\mathrm{ : Type)
    extends PartialOrder }\alpha\mathrm{ : Type where
    Inf : Set }\alpha\mathrm{ \rightarrow }\alpha
    Inf_le : VA b, b \in A -&gt; Inf A \leq b
    le_Inf : VA b, ( }\forall\mathrm{ a, a \in A -&gt; b \leq a) -&gt; b \leq Inf A
</code></pre>
<p>在Lean中，使用类型类来表示完全格是自然而然的：</p>
<pre><code>instance Set.CompleteLattice { }\alpha\mathrm{ : Type} :
    CompleteLattice (Set }\alpha\mathrm{ ) :=
    { @Set.PartialOrder }\alpha\mathrm{ with
        Inf := fun X \mapsto {a | \forallA, A \in X -&gt; a \in A}
        Inf_le := by aesop
        le_Inf := by aesop }
</code></pre>

<p>类型Set <span class="math">\(\alpha\)</span>是此类型类的一个实例：</p>

<div class="math">$$
\lg f=\Pi\{x \mid f x \leq x\}
$$</div>

<h3>11.6 最小不动点</h3>
<p>利用完全格，我们可以定义最小不动点算子：</p>

<pre><code>def lfp { }\alpha\mathrm{ : Type} [CompleteLattice }\alpha\mathrm{ ] (f : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ ) : }\alpha\mathrm{ :=
    CompleteLattice.Inf {a | f a \leq a}
</code></pre>

<p>在Lean中：</p>

<p>克纳斯特-塔斯基定理<span class="math">\({ }^{1}\)</span>（我们在6.1节简要提及过）为任意完全格上的单调函数<span class="math">\(f\)</span>提供了以下性质：</p>
<ul>
<li>lfp <span class="math">\(f\)</span> 是不动点：<span class="math">\(\lg f=f(\lg f)\)</span>；</li>
<li>
<span class="math">\(\lg f\)</span> 小于任何其他不动点：<span class="math">\(X=f X \rightarrow \lg f \leq X\)</span>。</li>
</ul>
<pre><code>| Stmt.whileDo B S <span class="math">\(\quad \Rightarrow&gt;\)</span>
    lfp (fun <span class="math">\(X \mapsto\)</span> ((denote <span class="math">\(S \bigcirc X) ; B\)</span> )
        <span class="math">\(\cup(\)</span> Id <span class="math">\(;(\)</span> fun <span class="math">\(\mathrm{s} \mapsto \neg \mathrm{B} \mathrm{s} \mathrm{)))}\)</span>
</code></pre>

<h3>11.7 关系指称语义续</h3>
<p>借助lfp，我们可以兑现承诺，完成WHILE程序指称语义的定义：</p>

<pre><code>theorem denote_Iff_BigStep (S : Stmt) (s t : State) :
    <span class="math">\((s, t) \in \llbracket S \rrbracket \leftrightarrow(s, s) \Longrightarrow t\)</span>
</code></pre>
<p>为验证我们的定义，可以证明指称语义与大步语义之间存在以下关联：</p>
<p>关于证明部分，请参阅《Concrete Semantics: With Isabelle/HOL》第11章或本章附带的演示文件。</p>
<pre><code>def DenoteEquiv <span class="math">\(\left(\mathrm{S}_{1} \mathrm{~S}_{2}: \mathrm{Stmt}\right)\)</span> : Prop :=
    <span class="math">\(\llbracket \mathrm{S}_{1} \rrbracket=\llbracket \mathrm{S}_{2} \rrbracket\)</span>
</code></pre>
<h3>11.8 程序等价性应用</h3>
<p>基于指称语义学，我们引入程序等价性的概念。若两个程序具有相同的语义，则它们等价：</p>

<p>我们用<span class="math">\(S_{1} \sim S_{2}\)</span>作为DenoteEquiv <span class="math">\(S_{1} S_{2}\)</span>的简写。容易看出这是一个等价关系。</p>

<pre><code>theorem DenoteEquiv.seq_congr <span class="math">\(\left\{S_{1} S_{2} T_{1} T_{2}: \mathrm{Stmt}\right\}\)</span>
    <span class="math">\(\left(h S: S_{1} \sim S_{2}\right)\left(h T: T_{1} \sim T_{2}\right):\)</span>
    <span class="math">\(\mathrm{S}_{1} ; \mathrm{T}_{1} \sim \mathrm{~S}_{2} ; \mathrm{T}_{2}:=\)</span>
    by

    simp [DenoteEquiv, denote] at *
    simp [*]
theorem DenoteEquiv.if_congr {B} {S
    (hS : S
    Stmt.ifThenElse B S, T
    simp [DenoteEquiv, denote] at *
    simp [*]
theorem DenoteEquiv.while_congr {B} {S, S
    (hS : S
    simp [DenoteEquiv, denote] at *
    simp [*]
</code></pre>

<p>程序等价性可用于在大型程序中替换子程序，前提是这些子程序具有相同的语义。这一特性通过以下同余规则实现：</p>

<p>同余规则是一种定理，它将等价关系提升到某种上下文环境中（此处指顺序组合、条件语句和循环语句的上下文）。</p>
<p>注意指称语义如何通过重写实现简洁的证明。考虑到其设计初衷就是等式化和组合性，这并不令人惊讶。如果我们采用大步语义作为程序等价性的基础，这些证明将会复杂得多。</p>
<pre><code>theorem DenoteEquiv.skip_assign_id {x} :
    Stmt.assign x (fun s }-&gt;\mathrm{ s x) Stmt.skip :=
    by simp [DenoteEquiv, denote, Id]
theorem DenoteEquiv.seq_skip_left {S} :
    Stmt.skip; S S :=
    by simp [DenoteEquiv, denote, Id, comp]
theorem DenoteEquiv.seq_skip_right {S} :
    S; Stmt.skip S :=
    by simp [DenoteEquiv, denote, Id, comp]
</code></pre>
<p>现在我们可以通过等式推理来证明简单程序的等价性：</p>
<pre><code>theorem DenoteEquiv.if_seq_while {B S} :
    Stmt.ifThenElse B (S; Stmt.whileDo B S) Stmt.skip
    Stmt.whileDo B S :=
    by
    simp [DenoteEquiv, denote]
    apply Eq.symm
    apply lfp_eq
    apply Monotone_while_lfp_arg
</code></pre>
<p>我们使用lfp运算符定义了while循环的语义，但如何确保单调性——它保证了最小不动点的存在——确实成立？为消除此类疑虑，我们证明以下定理：</p>
<pre><code>theorem Monotone_while_lfp_arg (S B) :
    Monotone (fun X \longleftarrow [S] \bigcirc X ; B \cup I d ; (fun s \longleftarrow \neg B s)) :=
    by
        apply Monotone_union
        { apply SorryTheorems.Monotone_restrict
            apply SorryTheorems.Monotone_comp
            { exact Monotone_const _ }
            { exact Monotone_id } }
    { apply SorryTheorems.Monotone_restrict
        exact Monotone_const _ }
</code></pre>
<p>该定理为我们提供了一种便捷的方式来展开或收缩循环的一次迭代。第二次应用引用了定理lfp_eq：lfp f = f (lfp f)，表明lfp是一个不动点。最后一步应用定理来说服Lean相信lfp的参数是单调的。该定理的证明过程相当单调：</p>

<h3>11.9 基于归纳谓词的更简单方法</h3>
<p>Lean的归纳谓词对应于最小不动点，但它们直接内建于Lean的逻辑系统（归纳构造演算）中，无需使用类似lfp的不动点运算符。本节大部分内容都致力于构建lfp运算符。我们是否可以使用归纳谓词来替代，从而省去这部分工作？</p>

<pre><code>inductive Awhile (B : State <span class="math">\(\rightarrow\)</span> Prop)
    (r : Set (State <span class="math">\(\times\)</span> State)) :
    State <span class="math">\(\rightarrow\)</span> State <span class="math">\(\rightarrow\)</span> Prop
    | true <span class="math">\(\{s \mathrm{t} u\)</span> \} (hcond : B s) (hbody : (s, t) <span class="math">\(\in r\)</span> )
        (hrest : Awhile B r t u) :
        Awhile B r s u
    | false <span class="math">\(\{s\}\)</span> (hcond : <span class="math">\(\neg\)</span> B s) :
        Awhile B r s s
</code></pre>
<p>答案是肯定的。首先需要明确，在Lean中，类型Set (State <span class="math">\(\times\)</span> State)和State <span class="math">\(\rightarrow\)</span> State <span class="math">\(\rightarrow\)</span> Prop是二元关系的等价表示形式。因此我们可以构建如下Awhile谓词，它类似于自反传递闭包，但当给定条件B为假时停止：</p>
<pre><code>def denoteAwhile : Stmt -&gt; Set (State \times State)
    \vdots
    | Stmt.whileDo B S =&gt;
    {st | Awhile B (denoteAwhile S) (Prod.fst st)
        (Prod.snd st)}
</code></pre>

<p>借助该运算符，定义语义的定义变为</p>

<p>Awhile谓词的引入规则与大步操作语义中的while规则高度相似。尽管表象不同，操作语义与指称语义终究并非截然相异。</p>

<h1>第四部分：数学基础</h1>
<h2>第12章 数学的逻辑基础</h2>
<p>本章我们将深入探讨Lean的逻辑基础。这里描述的大多数特性尤其适用于定义数学对象及证明相关定理。如需更详尽的阐述，可参考Carneiro的硕士论文。</p>

<div class="math">$$
\text { @And.intro : } \forall \mathrm{a} b, \mathrm{a} \rightarrow \mathrm{~b} \rightarrow \mathrm{a} \wedge \mathrm{~b}
$$</div>

<h3>12.1 宇宙层级</h3>
<p>在依赖类型理论中，不仅所有项都有类型，所有类型本身也拥有类型。我们已见过此类现象的若干实例。PAT原则告诉我们应将证明视为项、命题视为类型。例如，定理</p>

<div class="math">$$
\forall a b, a \rightarrow b \rightarrow a \wedge b: \text { Prop }
$$</div>

<p>实际上是一个类型为<span class="math">\(\forall \mathrm{a} b, \mathrm{a} \rightarrow \mathrm{b} \rightarrow \mathrm{a} \wedge \mathrm{b}\)</span>的项@And.intro，而该类型本身又具有另一个类型：</p>

<div class="math">$$
\text { Prop : Type }
$$</div>

<p>那么Prop的类型是什么？Prop与我们迄今构建的几乎所有其他类型具有相同的类型：</p>

<pre><code>Type : Type 1
Type 1 : Type 2
Type 2 : Type 3
</code></pre>

<p>那么Type的类型是什么？最简单的解决方案是让Type : Type，但这种选择会导致吉拉尔悖论，即罗素悖论在类型理论中的对应物。为了避免不一致性，我们需要一个全新的、更大的类型来容纳Type，我们称之为Type 1。而Type 1本身的类型是Type 2，以此类推：</p>

<div class="math">$$
\text { C } \vdash \text { Sort } u: \text { Sort }(u+1)
$$</div>

<p>实际上，不带参数的Type是Type 0的缩写。若要将Prop纳入这一层级体系，我们可以使用Sort u语法，其中Sort 0是Prop的别名，而Sort (<span class="math">\(u+1\)</span>) 则是Type u的别名。该层级体系通过以下类型判断式体现：</p>

<p>所有这些包含其他类型的类型都被称为宇宙，而表达式Sort <span class="math">\(u\)</span>中的<span class="math">\(u\)</span>是一个宇宙层级。尽管宇宙层级看起来像是类型为<span class="math">\(\mathbb{N}\)</span>的项，但实际上它们甚至不是项。</p>

<p>无需处处使用Type，您可以通过书写Type <span class="math">\(\_\)</span>来使定理略微更通用，而无需考虑宇宙层级。Lean随后会创建一个新的宇宙变量。这有助于维持我们工作在一个便利逻辑中的假象，即Type : Type成立，但不会引入任何悖论。实际上，Type <span class="math">\(\omega\)</span>对大多数计算机科学和数学领域而言已经足够大。</p>


<h3>12.2 Prop类型的特殊性</h3>
<p>尽管Prop看似完美契合宇宙层级结构，它在多个方面与其他宇宙存在差异。</p>

<div class="math">$$
\begin{aligned}
&amp; \text { C } \vdash \sigma: \text { Type } u \quad C, x: \sigma \vdash \tau[x]: \text { Type } v \\
&amp; C \vdash(x: \sigma) \rightarrow \tau[x]: \text { Type }(\max u v)
\end{aligned}
$$</div>

<h3>12.2.1 非直谓性</h3>
<p>当从其他类型构造新类型时（例如由<span class="math">\(\alpha\)</span> : Type <span class="math">\(u\)</span> 和 <span class="math">\(\beta\)</span> : Type v 构造 <span class="math">\(\alpha \rightarrow \beta\)</span>），新构造的类型比其每个组成部分都更复杂，将其置于所涉及的最大宇宙中是自然的（例如<span class="math">\(\alpha \rightarrow\)</span> <span class="math">\(\beta\)</span> : Type (max u v)）。这正是Lean采取的做法。以下类型规则为依赖类型普遍表达了这一思想：</p>


<p>Type宇宙的这种行为被称为谓词性。一般而言，谓词性意味着一个对象不能通过量化该对象本身的量词来定义。</p>

<div class="math">$$
(\mathrm{a}: \text { Type } \mathrm{u}) \rightarrow \mathrm{a} \rightarrow \mathrm{a}: \text { Type }(\mathrm{u}+1)
$$</div>
<p>然而，让Prop表现出不同的行为更为便利。我们希望表达式<span class="math">\(\forall \mathrm{a}: \operatorname{Prop}, \mathrm{a} \rightarrow \mathrm{a}\)</span>具有Prop类型——毕竟它是一个命题。展开<span class="math">\(\forall\)</span>的语法糖后，该表达式等同于(a : Prop) <span class="math">\(\rightarrow\)</span> a <span class="math">\(\rightarrow\)</span> a。若用Type <span class="math">\(u\)</span>替代Prop，上述类型规则将推导出</p>
<div class="math">$$
\frac{\mathrm{C} \vdash \sigma: \text { Sort u } \quad \mathrm{C}, \mathrm{x}: \sigma \vdash \tau[\mathrm{x}]: \text { Prop }}{\mathrm{C} \vdash(\forall \mathrm{x}: \sigma, \tau[\mathrm{x}]): \text { Prop }} \text { ARROW-PROP }
$$</div>

<p>由于Type <span class="math">\(u\)</span> : Type <span class="math">\((u+1)\)</span>且<span class="math">\(\max (u+1)(\max u u)=u+1\)</span>，因此在键入此表达式时宇宙层级会增加一。为了强制使诸如<span class="math">\(\forall a\)</span> : Prop, <span class="math">\(a \rightarrow a\)</span>的表达式仍具有Prop类型，我们需要为带有Prop主体的<span class="math">\(\forall\)</span>表达式制定特殊类型规则：</p>

<div class="math">$$
\forall \mathrm{a}: \text { Prop, } \mathrm{a} \rightarrow \mathrm{a}: \text { Prop }
$$</div>

<p>该规则得出</p>

<div class="math">$$
\begin{aligned}
&amp; \text { C } \vdash \sigma: \text { Sort } u \quad C, x: \sigma \vdash \tau[x]: \text { Sort } v \\
&amp; C \vdash(x: \sigma) \rightarrow \tau[x]: \text { Sort }(i m a x u v)
\end{aligned}
$$</div>

<p>如预期所示。上述两条类型规则可归纳为单一规则</p>


<p>其中imax <span class="math">\(u \theta=\theta\)</span> 且imax <span class="math">\(u(v+1)=\max u(v+1)\)</span>。这种行为被称为Prop的非直谓性。一般而言，非直谓性意味着对象可以通过作用于自身的量词来定义。</p>

<pre><code>theorem proof_irrel {a : Prop} (h
    h
    by rfl
</code></pre>

<h4>12.2.2 证明无关性</h4>
<p>Prop与Type的第二个区别在于证明无关性。这意味着同一命题a的任意两个证明都是相等的：</p>

<p>在Lean中，这种相等性是通过计算可达的语法等价，允许我们使用rfl策略。当将命题视为类型、证明视为该类型的元素时，证明无关性意味着命题要么是空类型，要么恰好有一个实例。若命题是空类型，则它为假；若命题恰好有一个实例，则它为真。证明无关性在处理依赖类型时非常有用，我们将在本章后续内容中看到这一点。</p>

<p>在6.3节中，我们曾看到并排展示Bool与Prop解释的示意图。该图未考虑证明无关性，显示了同一命题的多个证明。现在我们知道这是不准确的。以下是修正后的示意图：</p>

<p><img src="img-9.jpeg" alt="img-9.jpeg"></p>
<p>若在思维中将布尔代数的两个元素（假与真）与命题类型的两种类型（False与True）对应起来，我们可以发现Prop几乎等同于Bool，唯一的区别在于根据PAT原理，Prop类型的命题能够存储证明。下表总结了这一对应关系：</p>

<p>False : 命题类型  
True.intro : True : 命题类型  
false : 布尔类型 : 类型  
true : 布尔类型 : 类型  
为使证明无关性成立，Lean必须放弃归纳谓词的"无混淆"特性。事实上，同一命题的不同证明理应被"混淆"。这仅涉及归纳谓词（如Even），而不影响一般归纳类型（例如列表<span class="math">\(\alpha\)</span>）。</p>

<p>其他系统和逻辑体系做出了不同的选择。例如，Coq默认采用证明相关机制，但兼容证明无关性。同伦类型论及其他构造性或直觉主义类型理论基于等式证明中的数据构建，因此与证明无关性不兼容。</p>
<h4>12.2.3 禁止大规模析取</h4>
<p>Prop与Type的另一关键区别在于Prop不允许大规模析取：通常无法从命题证明中提取信息并在程序（即属于Type的类型值）中使用。毕竟，由于证明无关性，给定命题的所有证明都是等价的，因此它们无法携带可区分的特定信息。</p>
<pre><code>-- fails
def unsquare (i : Z) (hsq : ヨj, i = j * j) : Z :=
    match hsq with
    | Exists.intro j _ =&gt; j
</code></pre>
<p>假设我们能够从程序内部的证明中提取信息。例如，我们可以在函数定义中使用match构造，如下所示：</p>
<pre><code>tactic 'induction' failed, recursor 'Exists.casesOn' can
only eliminate into Prop
</code></pre>

<p>unsquare函数接收一个平方数<span class="math">\(i\)</span>以及证明hsq（表明<span class="math">\(i\)</span>确实是一个平方数），然后返回平方前的数字<span class="math">\(j\)</span>，该数字是从证明中提取的。Lean会抛出错误</p>

<pre><code>hsq <span class="math">\(_{1}:=\)</span> Exists.intro 3 (by linarith)
hsq <span class="math">\(_{2}:=\)</span> Exists.intro (-3) (by linarith)
</code></pre>

<p>若该定义被接受，我们可按如下方式推导出False。设</p>

<p>作为<span class="math">\(\exists j,(9: \mathbb{Z})=j * j\)</span>的两个证明。注意它们对<span class="math">\(j\)</span>使用了不同的见证值（3与-3）。于是我们得到unsquare <span class="math">\(9 \mathrm{hsq}_{1}=3\)</span>和unsquare <span class="math">\(9 \mathrm{hsq}_{2}=-3\)</span>。然而根据证明无关性，<span class="math">\(h s q_{1}=h s q_{2}\)</span>。因此unsquare <span class="math">\(9 \mathrm{hsq}_{2}\)</span>应等于3。但我们已确定其值为-3，这意味着<span class="math">\(3=-3\)</span>，产生矛盾。</p>

<p>缺乏大范围消去的一个不幸后果是，我们无法通过模式匹配和递归进行规则归纳（第4.8节）。这类归纳依赖于一个“度量”——即一个到<span class="math">\(\mathbb{N}\)</span>的函数，该函数为参数分配大小。没有大范围消去，度量就无法被有意义地定义。这解释了为何我们总是使用归纳策略进行规则归纳。</p>


<p>作为一种折中方案，Lean允许小规模消去（small elimination），即仅能消去至Prop类型，而大规模消去（large elimination）则可消去至任意大的宇宙Type u。这意味着只要匹配表达式本身处于证明中，我们就能使用match来分析证明结构、提取存在性见证等。我们已在5.7节和6.5节中见过此类示例。</p>


<p>作为进一步的折衷方案，Lean允许对语法单例（syntactic subsingletons）进行大消除：即那些在Prop中至多有一种证明方式的类型。例如，False没有证明，而所有<span class="math">\(\wedge\)</span> b的证明都具有And.intro _ _的形式（递归地看，可能存在多种证明a和b的方式）。更准确地说，语法单例是指一个归纳定义，其最多包含一个构造函数，且该构造函数的参数要么属于Prop，要么作为结果类型的直接参数出现。当我们匹配<span class="math">\(h: a \wedge b\)</span>与And.intro ha hb时，不会泄露关于<span class="math">\(h\)</span>的任何信息。</p>

<pre><code>inductive Nonempty ( }\alpha\mathrm{ : Sort u) : Prop
    | intro (val : }\alpha\mathrm{ ) : Nonempty }\alpha
</code></pre>
<h3>12.3 选择公理</h3>
<p>Lean的逻辑系统包含选择公理，这使得从任意非空类型中获取元素成为可能。考虑以下预定义谓词：</p>
<pre><code>theorem Nat.Nonempty :
    Nonempty N :=
    Nonempty.intro 0
</code></pre>
<p>该谓词声明<span class="math">\(\alpha\)</span>至少包含一个元素。要证明Nonempty <span class="math">\(\alpha\)</span>，我们必须向Nonempty.intro提供一个<span class="math">\(\alpha\)</span>类型的值：</p>

<p>由于Nonempty存在于Prop中，无法进行大规模消除，因此我们无法提取在证明Nonempty <span class="math">\(\alpha\)</span>时所使用的元素。</p>

<div class="math">$$
\text { Classical. choice }\{\alpha: \text { Sort u }\}: \text { Nonempty } \alpha \rightarrow \alpha
$$</div>
<p>在Lean中，选择公理表现为一个函数，该函数在给定Nonempty <span class="math">\(\alpha\)</span>证明时返回一个任意的<span class="math">\(\alpha\)</span>值：</p>
<p>我们无法得知返回的元素是否与用于证明非空<span class="math">\(\alpha\)</span>的元素相同。它仅仅是<span class="math">\(\alpha\)</span>中的一个任意元素。</p>

<p>常量 Classical.choice 是不可计算的。如果我们要求 Lean 通过 #reduce 或 #eval 提供其值，系统将拒绝计算。换言之，证明可以是项，但它们不一定是程序。这是一些逻辑学家倾向于不使用选择公理的原因之一。相比之下，绝大多数数学家对选择公理并无异议。</p>


<p>与证明无关性及大小消除规则不同，选择公理并未内置于Lean内核中；它仅是核心库中的一个公理，我们可以自由选择不使用它。若定义中使用了Classical.choice来定义Type中的常量，Lean要求我们必须用noncomputable关键字标记这些定义。</p>


<p>以下工具依赖于 Classical.choice：</p>
<ul>
<li>函数 Classical.choose（称为希尔伯特选择算子）帮助我们找到<span class="math">\(\exists a: \alpha, p\)</span>的见证元，当我们不关心具体是哪一个时。其伴随函数 Classical.choose_spec 则提供该见证元确实满足条件的证明。</li>
</ul>

<div class="math">$$
\begin{aligned}
&amp; \text { Classical.choose : }(\exists \mathrm{a}: \alpha, \mathrm{pa}) \rightarrow \alpha \\
&amp; \text { Classical.choose_spec: } \forall \mathrm{h}:(\exists \mathrm{a}: \alpha, \mathrm{pa}), \mathrm{p}(\text { Classical.choose } \mathrm{h})
\end{aligned}
$$</div>

<p>直观而言，选择算子告诉我们："只要能让我确信存在满足<span class="math">\(p\)</span>的元素，我就能给你这样一个元素。"</p>
<ul>
<li>我们还可以推导出传统的选择公理：</li>
</ul>

<div class="math">$$
\begin{aligned}
&amp; \text { Classical.axiomOfChoice }(\alpha \beta: \text { Type })\{\mathrm{R}: \alpha \rightarrow \beta \rightarrow \text { Prop }\}: \\
&amp; (\forall \mathrm{x}: \alpha, \exists \mathrm{y}: \beta, \mathrm{R} \times \mathrm{y}) \rightarrow(\exists \mathrm{f}: \alpha \rightarrow \beta, \forall \mathrm{x}: \alpha, \mathrm{R} \times(\mathrm{f} \times)) \\
&amp; \text { - From the axiom of choice and propositional and functional extensionality } \\
&amp; \text { (propext, funext), we can derive the law of excluded middle: }
\end{aligned}
$$</div>
<p>根据排中律，每个命题都是可判定的。这意味着我们可以基于某个命题是否为真的情况区分来构造证明。</p>

<h3>12.4 子类型</h3>
<p>归纳类型在适用时是非常方便的定义机制，但许多数学构造并不符合这种模式。Lean提供了两种替代方案来满足这些需求：子类型和商类型。</p>

<p>子类型化是一种从现有类型创建新类型的机制。给定基类型元素上的谓词，子类型仅包含满足该谓词的基类型元素。更准确地说，子类型包含元素-证明对，这些对组合了基类型的元素以及该元素满足谓词的证明。</p>

<p>下图展示了通过保留基类型五个元素中的两个所创建的子类型：</p>

<p><img src="img-10.jpeg" alt="img-10.jpeg"></p>
<pre><code>inductive Finset ( <span class="math">\(\alpha\)</span> : Type) : Type
    | empty : Finset <span class="math">\(\alpha\)</span>
    | insert : <span class="math">\(\alpha \rightarrow\)</span> Finset <span class="math">\(\alpha \rightarrow\)</span> Finset <span class="math">\(\alpha\)</span>
</code></pre>

<p>子类型化对于无法被定义为归纳类型的那些类型非常有用。例如，任何尝试按照以下方式定义有限集类型的做法</p>

<pre><code>Finset.insert 1 (Finset.insert 2 Finset.empty)
Finset.insert 2 (Finset.insert 1 Finset.empty)
Finset.insert 1 (Finset.insert 1 (Finset.insert 2 Finset.empty))
</code></pre>

<p>这种定义注定失败，因为给定的集合可能存在多种表示方式。例如，<span class="math">\(\{1,2\}\)</span>可以通过以下任意方式（以及更多方式）来表示：</p>

<div class="math">$$
\{\text { variable : base-type // property-applied-to-variable }\}
$$</div>

<p>相反，我们可以将有限集合定义为（可能无限的）集合中属于有限的那种子类型。一般而言，子类型的语法结构为</p>


<p>我们在4.6节中见过一个例子，即<span class="math">\(\{\mathrm{i}: \mathbb{N} / / \mathrm{i} \leq n\}\)</span>，它由满足<span class="math">\(i \leq n\)</span>的自然数i构成，其中<span class="math">\(n\)</span>是上下文中的固定值。基类型为<span class="math">\(\mathbb{N}\)</span>，属性是函数<span class="math">\(i \mapsto i \leq n\)</span>。该类型的另一种语法是@Subtype <span class="math">\(\mathbb{N}\)</span> (fun <span class="math">\(i \mapsto i \leq n\)</span> )，虽然暗示性较弱但可能更不易混淆。我们的动机示例——某类型<span class="math">\(\alpha\)</span>上的有限集合类型——被定义为<span class="math">\(\{\mathrm{A}:\)</span> Set <span class="math">\(\alpha / /\)</span> Set. Finite A}，其中当且仅当参数为有限集时Set.Finite为真。</p>

<pre><code>def FullTree ( }\alpha\mathrm{ : Type) : Type :=
    {t : Tree }\alpha\mathrm{ // IsFull t}
</code></pre>

<h4>12.4.1 第一个示例：满二叉树</h4>
<p>为了说明子类型，我们将基于第5.8节的Tree类型定义一个满二叉树类型。在第6.6.3节中，我们引入了一个谓词IsFull，当树的每个节点有零个或两个子节点时为真。基于此类型和谓词，我们可以构造一个仅包含满二叉树的子类型FullTree，如下所示：</p>

<pre><code>def FullTree ( }\alpha\mathrm{ : Type) : Type :=
    @Subtype (Tree }\alpha\mathrm{ ) IsFull
</code></pre>
<p>这是以下语法的语法糖：</p>
<pre><code>inductive Subtype { }\alpha\mathrm{ : Type} (p : }\alpha\mathrm{ \rightarrow Prop) : Type
    | mk : (x : }\alpha\mathrm{ ) \rightarrow p x \rightarrow Subtype p
</code></pre>
<p>其中子类型定义如下：</p>
<pre><code>def nilFullTree : FullTree N :=
    Subtype.mk Tree.nil IsFull.nil
def fullTree6 : FullTree N :=
    Subtype.mk (Tree.node 6 Tree.nil Tree.nil)
    (by
        apply IsFull.node
        apply IsFull.nil
        apply IsFull.nil
        rfl)
</code></pre>
<p>FullTree的元素本质上是依赖类型的配对，其中第一个分量是树<span class="math">\(t\)</span>，第二个分量是证明<span class="math">\(t\)</span>为满二叉树的证据。例如，以下是空满二叉树和仅含标记为6的单一内部节点的满二叉树的定义：</p>
<pre><code>\#reduce Subtype.val fullTree6
\#check Subtype.property fullTree6
</code></pre>
<p>给定一个FullTree类型的值，我们可以通过Subtype.val和Subtype.property来获取其两个组成部分：</p>
<p>子类型最吸引人的特性在于：只要操作能保持子类型属性，我们就可以将基础类型的操作提升到子类型，而无需从头构建库。我们只需为基础类型的常量定义"包装器"。通常，为基础类型上的操作<span class="math">\(f\)</span>定义此类包装器需要三个步骤：</p>
<ol>
<li>从包装器参数中提取基础类型的值；</li>
<li>对这些基础类型值调用<span class="math">\(f\)</span>；</li>
<li>使用Subtype.mk封装结果，并证明所得基础类型值满足子类型属性。
通过此流程，若Tree函数能保持IsFull属性，我们就可以将其提升为FullTree函数。例如，要将mirror操作从Tree<span class="math">\(\rightarrow\)</span>Tree类型提升到FullTree<span class="math">\(\rightarrow\)</span>FullTree类型，我们必须：1. 从包装器参数中提取Tree；</li>
<li>对该Tree调用mirror；</li>
<li>使用Subtype.mk封装结果，并证明所得Tree满足IsFull。
在步骤3中，我们必须从参数中提取IsFull的证明，并使用6.6.3节的IsFull_mirror定理。将所有内容整合后，我们得到</li>
</ol>
<pre><code>def FullTree.mirror { }\alpha\mathrm{ : Type} (t : FullTree }\alpha\mathrm{ ) :
    FullTree }\alpha\mathrm{ :=
    Subtype.mk (LoVe.mirror (Subtype.val t))
    (by
        apply IsFull_mirror
        apply Subtype.property t)
</code></pre>
<p>输入是子类型FullTree的一个元素<span class="math">\(t\)</span>。我们将<span class="math">\(t\)</span>分解为Subtype.val t : Tree和Subtype.property t : IsFull t。使用先前的mirror函数反转<span class="math">\(t\)</span>的树结构组件，并利用定理IsFull_mirror与<span class="math">\(t\)</span>的属性组件，证明条件IsFull (mirror (Subtype.val t))成立。</p>

<p>最后，我们使用Subtype.mk构建一个包含结果树及其满足全树性质的证明的对。Subtype.mk构造器既可视为类对构造器，也可视为从Tree到FullTree的类型转换，其第二个参数确保了该转换的安全性。</p>

<pre><code>Subtype.eq : Subtype.val ?a = Subtype.val ?b -&gt; ?a = ?b
</code></pre>
<p>关于子类型的证明，以下定理非常有用：</p>
<pre><code>theorem FullTree.mirror_mirror { }\alpha\mathrm{ : Type}
    (t : FullTree }\alpha\mathrm{ ) :
    (FullTree.mirror (FullTree.mirror t)) = t :=
    by
    apply Subtype.eq
    simp [FullTree.mirror, LoVe.mirror_mirror]
</code></pre>
<p>该定理指出，若两个子类型值的Subtype.val分量相等，则这两个子类型值相等。关键在于Lean中证明的无关性，因为我们不希望子类型中存在仅因证明不同而产生的虚假重复值。以下展示如何利用Subtype.eq证明FullTree的镜像的镜像就是FullTree本身：</p>
<div class="math">$$
\text { mirror (mirror (Subtype.val t)) = Subtype.val t }
$$</div>
<p>应用定理Subtype.eq并展开full_Tree.mirror的定义后，得到子目标</p>

<p>这与第5.8节中定理mirror_mirror的陈述相符。</p>

<pre><code>def Vector ( }\alpha\mathrm{ : Type) (n : N) : Type :=
    {xs : List }\alpha\mathrm{ // List.length xs = n}
</code></pre>

<h4>12.4.2 第二个示例：向量</h4>
<p>作为第二个示例，考虑以下向量的定义：</p>


<p>向量被定义为一个给定长度的列表。对于列表而言，所有长度的列表都共享同一种类型。而向量则为每种长度都设定了专门的类型。这种方案的优势在于，诸如向量加法和标量积等运算要求参与运算的两个向量必须具有相同长度。我们在5.10节中曾见过一个实用性较低的向量定义。</p>

<pre><code>def vector123 : Vector \mathbb{Z} 3 :=
    Subtype.mk [1, 2, 3] (by rfl)
</code></pre>
<p>可以通过Subtype.mk从列表构建向量：</p>
<pre><code>def Vector.neg {n : N} (v : Vector \mathbb{Z} n) : Vector \mathbb{Z n :=
    Subtype.mk (List.map Int.neg (Subtype.val v))
    (by
        rw [List.length_map]
        exact Subtype.property v)
</code></pre>

<p>向量的基本操作可通过Subtype.val和Subtype.property解构向量、操作底层列表后，再用Subtype.mk重新组合来定义。例如，我们可以如下定义整数向量的逐分量取反操作：</p>

<p>我们使用函数List.map对底层列表的每个元素取反，并通过定理List.length_map证明这不会改变列表的长度。</p>
<pre><code>theorem Vector.neg_neg (n : N) (v : Vector \mathbb{Z} n) :
    Vector.neg (Vector.neg v) = v :=
    by
        apply Subtype.eq
        simp [Vector.neg]
</code></pre>
<p>通过使用Subtype.eq，我们可以证明以下关于Vector.neg的定理：</p>
<p>应用Subtype.eq将目标简化为证明底层列表的相应性质，随后可使用simp策略完成证明。</p>

<h3>12.5 商类型</h3>
<p>商构造是数学中用于定义<span class="math">\(\mathbb{Z}, \mathbb{R}\)</span>等集合的强大工具。Lean支持商类型——这是类型论中的对应概念。与子类型化类似，商类型也是基于现有类型构造新类型。不同的是，商类型会保留基类型的所有元素，但允许基类型中不同的元素在商类型中被视为等同。用数学术语来说，商类型与基类型的划分同构。下图展示了通过三分划构建的商类型：</p>

<p><img src="img-11.jpeg" alt="img-11.jpeg"></p>

<p>基类型</p>

<p><img src="img-12.jpeg" alt="img-12.jpeg"></p>

<p>子类型</p>

<p><img src="img-13.jpeg" alt="img-13.jpeg"></p>
<p>商类型</p>
<p>图示的商类型仅有三个元素，用灰色椭圆表示。每个元素对应一个或多个基类型元素。</p>
<pre><code>instance \tau.Setoid : Setoid <span class="math">\(\tau:=\)</span>
    <span class="math">\(\{\mathrm{r} \quad:=R\)</span>
        iseqv : <span class="math">\(=\)</span>
            \{ refl := ...
            symm <span class="math">\(:=\)</span>...
            trans <span class="math">\(:=\ldots\}\)</span>
</code></pre>
<p>构造商类型的前提条件是存在一个基类型<span class="math">\(\tau\)</span>和一个等价关系<span class="math">\(R: \tau \rightarrow \tau \rightarrow\)</span> Prop，该关系规定了基类型中哪些元素在商类型中被视为相等。要构造商类型，我们首先需要证明<span class="math">\(R\)</span>是<span class="math">\(\tau\)</span>上的等价关系。配备等价关系的类型<span class="math">\(\tau\)</span>称为集合体。在Lean中，Setoid是一个类型类，我们可以通过以下命令声明其实例</p>

<p>其中省略号代表各自属性的缺失证明。此外，该实例声明引入了表示<span class="math">\(R\)</span> a b的符号<span class="math">\(a \approx b\)</span>。更重要的是，我们现在可以使用商类型Quotient <span class="math">\(\tau\)</span>.Setoid。</p>

<div class="math">$$
\text { Quotient.mk }\{\alpha: \text { Type }\} \rightarrow(\mathrm{s}: \text { Setoid } \alpha) \rightarrow \alpha \rightarrow \text { Quotient } \mathrm{s}
$$</div>

<p>每个元素 a : <span class="math">\(\tau\)</span> 都属于商集 Quotient <span class="math">\(\tau\)</span>.Setoid 中的某个元素，该元素由 Quotient.mk <span class="math">\(\tau\)</span>.Setoid a 给出，其中</p>


<p>表达式Quotient.mk <span class="math">\(\tau\)</span>.Setoid a显得冗长。幸运的是，Lean允许我们将其简记为<span class="math">\(\llbracket a \rrbracket\)</span>。</p>

<div class="math">$$
\text { Quotient. sound }\{\mathrm{a} b: \tau\}: \mathrm{a} \approx \mathrm{~b} \rightarrow \llbracket \mathrm{a} \rrbracket=\llbracket \mathrm{b} \rrbracket
$$</div>

<p>以下公理保证了满足关系<span class="math">\(R\)</span>的元素对在商类型中确实是相等的：</p>

<div class="math">$$
\text { Quotient. exact }\{\mathrm{a} b: \tau\}: \llbracket \mathrm{a} \rrbracket=\llbracket \mathrm{b} \rrbracket \rightarrow \mathrm{a} \approx \mathrm{~b}
$$</div>
<p>一个定理陈述了其逆命题：</p>
<div class="math">$$
\text { Quotient.lift } f h \llbracket a \rrbracket=f a
$$</div>
<p>最后，我们可以将类型为<span class="math">\(\tau \rightarrow v\)</span>的函数提升到商集<span class="math">\(\tau\)</span>.Setoid<span class="math">\(\rightarrow v\)</span>，其中<span class="math">\(v\)</span>是任意类型，这通过Quotient.lift实现，该操作在计算层面满足以下语法等价性。给定某个<span class="math">\(f: \tau \rightarrow v\)</span>且满足<span class="math">\(h: \forall a b, a \approx\)</span><span class="math">\(b \rightarrow f a=f b\)</span>，我们有</p>

<p>对于所有a : <span class="math">\(\tau\)</span>。参数<span class="math">\(h\)</span>是证明<span class="math">\(f\)</span>与<span class="math">\(\approx\)</span>兼容的；换言之，它不会区分<span class="math">\(\approx\)</span>-等价参数。</p>


<h4>12.5.1 第一个示例：整数</h4>
<p>作为商类型的第一个示例，我们将构造整数。一种便捷的方法是在自然数对上构造商类型。其核心思想是：自然数对<span class="math">\((p, n)\)</span>表示整数<span class="math">\(p-n\)</span>。通过这种方式，所有非负整数<span class="math">\(p\)</span>可用<span class="math">\((p, \theta)\)</span>表示，所有负整数-<span class="math">\(n\)</span>可用<span class="math">\((\theta, n)\)</span>表示。同时我们还能得到同一整数的多种表示，例如<span class="math">\((7, \theta),(8,1),(9,2)\)</span>和<span class="math">\((10,3)\)</span>都表示整数7。</p>

<p>首先，我们需要注册要使用的等价关系。我们希望当<span class="math">\(p_{1}-n_{1}\)</span>和<span class="math">\(p_{2}-n_{2}\)</span>得到相同整数时，两个数对<span class="math">\(\left(p_{1}, n_{1}\right)\)</span>和<span class="math">\(\left(p_{2}, n_{2}\right)\)</span>相等。然而，条件<span class="math">\(p_{1}-n_{1}=p_{2}-n_{2}\)</span>不可行，因为<span class="math">\(\mathbb{N}\)</span>上的减法行为异常（例如<span class="math">\(\varphi-1=\theta\)</span>）。因此我们改用基于加法的条件<span class="math">\(p_{1}+n_{2}=p_{2}+n_{1}\)</span>。</p>
<pre><code>instance Int.Setoid : Setoid ( }\mp@subsup{\mathbb{N}}{\times}{
    {r :=
        fun pn
            Prod.fst pn
                Prod.fst pn
            1
        1
    1
    1
    }
}
    intro pn
        rfl
        symm :=
            by
                intro pn
                rw [h]
            trans :=
            by
                intro pn
                linarith } }
</code></pre>

<p>我们给出等价关系的定义，并证明其满足自反性、对称性和传递性：</p>

<pre><code>theorem Int.Setoid_Iff (pn
    pn
    Prod.fst pn
    Prod.fst pn
    by rfl
</code></pre>
<p>现在我们可以用<span class="math">\(\approx\)</span>表示该等价关系：</p>
<pre><code>def Int : Type :=
    Quotient Int.Setoid
</code></pre>

<p>随后我们可以将整数定义为</p>

<pre><code>def Int.zero : Int :=
    \llbracket(\theta, \theta)\rrbracket
</code></pre>

<p>我们可以将整数零定义为</p>

<pre><code>theorem Int.zero_Eq (m : N) :
    Int.zero = \llbracket(m, m)\rrbracket :=
    by
    rw [Int.zero]
    apply Quotient.sound
    rw [Int. Setoid_Iff]
    simp
</code></pre>

<p>事实上，任何形式为<span class="math">\(\llbracket(\mathrm{m}, \mathrm{m}) \rrbracket\)</span>的项都表示零：</p>


<p>接下来，我们在新定义的整数上定义加法运算。对于商类型上的函数定义，不能像归纳类型那样简单地通过模式匹配来实现。相反，我们需要先在基础类型上定义函数，然后将该定义提升到商类型。为此，必须证明函数<span class="math">\(f\)</span>的定义不依赖于等价类代表元的选择（即<span class="math">\(a \approx b \rightarrow f a=f b\)</span>）。函数Quotient.lift（用于一元函数）和Quotient.lift<span class="math">\(_{3}\)</span>（用于二元函数）可以用于以这种方式提升函数。</p>

<div class="math">$$
\begin{aligned}
&amp; \llbracket\left(\text { prod.fst } \mathrm{pn}_{1}+\text { prod.fst } \mathrm{pn}_{2} \text {, prod.snd } \mathrm{pn}_{1}+\text { prod.snd } \mathrm{pn}_{2}\right) \rrbracket \\
= &amp; \llbracket\left(\text { prod.fst } \mathrm{pn}_{1}{ }^{\prime}+\text { prod.fst } \mathrm{pn}_{2}{ }^{\prime}, \text { prod.snd } \mathrm{pn}_{1}{ }^{\prime}+\text { prod.snd } \mathrm{pn}_{2}{ }^{\prime}\right) \rrbracket
\end{aligned}
$$</div>

<p>加法可以通过逐分量相加自然数对来定义。随后我们需要证明该定义可被提升到商集上的函数，即证明当<span class="math">\(\mathrm{pn}_{1} \approx \mathrm{pn}_{1}{ }^{\prime}\)</span>且<span class="math">\(\mathrm{pn}_{2} \approx \mathrm{pn}_{2}{ }^{\prime}\)</span>时满足</p>

<pre><code>def Int.add : Int <span class="math">\(\rightarrow\)</span> Int <span class="math">\(\rightarrow\)</span> Int <span class="math">\(:==\)</span>
    Quotient.lift <span class="math">\(_{3}\)</span>
    (fun <span class="math">\(\mathrm{pn}_{1} \mathrm{pn}_{2}: \mathbb{N} \times \mathbb{N} \mapsto\)</span>
        \llbracket(Prod.fst <span class="math">\(\mathrm{pn}_{1}+\)</span> Prod.fst <span class="math">\(\mathrm{pn}_{2}\)</span>,
            Prod.snd <span class="math">\(\mathrm{pn}_{1}+\)</span> Prod.snd <span class="math">\(\mathrm{pn}_{2} \rrbracket\)</span> )
    (by
        intro <span class="math">\(\mathrm{pn}_{1} \mathrm{pn}_{2} \mathrm{pn}_{1}{ }^{\prime} \mathrm{pn}_{2}{ }^{\prime} \mathrm{h}_{1} \mathrm{~h}_{2}\)</span>
        apply Quotient.sound
        rw [Int.Setoid_Iff] at *
        linarith)
</code></pre>

<p>形式化表述：</p>

<pre><code>theorem Int.add_Eq <span class="math">\(\left(\mathrm{p}_{1} \mathrm{n}_{1} \mathrm{p}_{2} \mathrm{n}_{2}: \mathbb{N}\right)\)</span>;
    Int.add <span class="math">\(\llbracket\left(\mathrm{p}_{1}, \mathrm{n}_{1}\right) \rrbracket \llbracket\left(\mathrm{p}_{2}, \mathrm{n}_{2}\right) \rrbracket=\)</span>
    <span class="math">\(\llbracket\left(\mathrm{p}_{1}+\mathrm{p}_{2}, \mathrm{n}_{1}+\mathrm{n}_{2}\right) \rrbracket:=\)</span>
    by rfl
</code></pre>
<p>最终得到的函数Int.add具有预期行为：</p>
<pre><code>-- fails
def Int.add : Int <span class="math">\(\rightarrow\)</span> Int <span class="math">\(\rightarrow\)</span> Int
    | <span class="math">\(\llbracket\left(p_{1}, n_{1}\right) \rrbracket, \llbracket\left(p_{2}, n_{2}\right) \rrbracket=&gt;\llbracket\left(p_{1}+p_{2}, n_{1}+n_{2}\right) \rrbracket\)</span>
</code></pre>

<p>如果Lean能让我们直接用以下语法将这个定理作为Int. add的定义输入，那将会非常方便：</p>

<pre><code>-- fails
def Int.fst : Int <span class="math">\(\rightarrow \mathbb{N}\)</span>
    | <span class="math">\(\llbracket(p, n) \rrbracket=&gt;p\)</span>
</code></pre>
<p>这将是一种优雅直观的语法，但若缺乏证明该定义与<span class="math">\(\approx\)</span>的兼容性，我们可能会定义出无意义的函数并利用它们推导出False。例如，我们可以定义</p>

<p>注意到 Int.fst <span class="math">\(\llbracket(\theta, \theta) \rrbracket=\theta\)</span> 且 Int.fst <span class="math">\(\llbracket(1,1) \rrbracket=1\)</span>。然而由于 <span class="math">\(\llbracket(\theta\)</span>, <span class="math">\(\theta) \rrbracket=\llbracket(1,1) \rrbracket\)</span>，我们得出 <span class="math">\(\theta=1\)</span>，这构成矛盾。</p>

<pre><code>theorem Int.add_zero (i : Int) :
    Int.add Int. zero i = i :=

by
    induction i using Quotient.inductionOn with
    | h pn =&gt;
        cases pn with
        | mk p n =&gt; simp [Int.zero, Int.add]
</code></pre>
<p>我们可以利用特征定理Int.add_Eq来证明关于Int.add的其他定理，例如</p>

<p>我们调用归纳策略，以Quotient.inductionOn作为归纳原理对<span class="math">\(i\)</span>进行情形划分，将<span class="math">\(i\)</span>替换为<span class="math">\(\llbracket p n \rrbracket\)</span>，其中<span class="math">\(p n\)</span>是基类型<span class="math">\(\mathbb{N} \times \mathbb{N}\)</span>的任意值。接着对pn进行情形划分，得到一个数对( <span class="math">\(p, n\)</span> )。最后利用Int.zero的定义和Int.add的特征方程简化目标。</p>

<pre><code>instance UPair.Setoid ( }\alpha\mathrm{ : Type) : Setoid ( }\alpha\times\alpha\mathrm{ :=
{ r :=
    fun ab ab ab : }\alpha\times\alpha\mapsto
        ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ =
        ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ )
    iseqv :=
    { refl := by simp
        symm := by aesop
        trans := by aesop } }
theorem UPair.Setoid_Iff { }\alpha\mathrm{ : Type} (ab ab ab : }\alpha\times\alpha\mathrm{ ):
        ab ab b }
    ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ ) =
    ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ :=
    by rfl
def UPair ( }\alpha\mathrm{ : Type) : Type :=
    Quotient (UPair.Setoid }\alpha\mathrm{ )
</code></pre>

<h4>12.5.2 第二个示例：无序对</h4>
<p>无序对是指不区分第一和第二分量的有序对，通常记作<span class="math">\(\{a, b\}\)</span>。我们将基于类型<span class="math">\(\alpha\)</span>上的无序对类型UPair定义为有序对<span class="math">\((a, b)\)</span>关于"包含相同元素"关系的商集：</p>

<pre><code>theorem UPair.mk_symm { }\alpha\mathrm{ : Type} (a b : }\alpha\mathrm{ ):
    ( \llbracket(a, b)\rrbracket: UPair }\alpha\mathrm{ ) = \llbracket(b, a)\rrbracket :=
    by
        apply Quotient.sound
        rw [UPair.Setoid_Iff]
        aesop
</code></pre>

<p>很容易证明我们的数对确实是无序的：</p>

<pre><code>def Set_of_UPair { }\alpha\mathrm{ : Type} : UPair }\alpha\mathrm{ \rightarrow Set }\alpha\mathrm{ :=
    Quotient.lift (fun ab : }\alpha\times\alpha\mapsto\mathrm{ {Prod.fst ab, Prod.snd ab})
        (by

intro ab <span class="math">\(_{1}\)</span> ab <span class="math">\(_{2}\)</span> h
rw [UPair.Setoid_Iff] at *
exact <span class="math">\(h)\)</span>
</code></pre>

<p>无序对的另一种表示方式是基数为1或2的集合。以下操作将UPair <span class="math">\(\alpha\)</span>值转换为该表示形式：</p>


<h4>12.5.3 通过规范化与子类型化的替代定义</h4>
<p>商类型的每个元素对应于基类型中<span class="math">\(\approx\)</span>等价类的一个元素。若存在系统化方法为每个<span class="math">\(\approx\)</span>等价类获取规范代表元，则可用子类型替代商类型，仅保留规范代表元并过滤其他元素。</p>

<pre><code>inductive Int.IsCanonical : <span class="math">\(\mathbb{N} \times \mathbb{N} \rightarrow\)</span> Prop
    | nonpos <span class="math">\(\{n: \mathbb{N}\} \operatorname{:Int.IsCanonical}(0, n)\)</span>
    | nonneg <span class="math">\(\{p: \mathbb{N}\} \operatorname{:Int.IsCanonical}(p, \circ)\)</span>
</code></pre>
<p>考虑上文构造的整数商类型Int。我们观察到<span class="math">\((7, \circ),(8,1),(9,2)\)</span>和<span class="math">\((10,3)\)</span>都表示整数7，但直观上<span class="math">\((7, \circ)\)</span>比其他表示更可取。我们将称一个数对<span class="math">\((p, n)\)</span>为规范形式——当且仅当p或n为o时：</p>
<pre><code>def Int : Type :=
    {pn : N × N // Int.IsCanonical pn}
</code></pre>

<p>整数因此由自然数的规范对组成：</p>

<pre><code>def Int.normalize : N × N -&gt; N × N
    | (p, n) =&gt; if p \geq n then (p - n, o) else (o, n - p)
theorem Int.IsCanonical_normalize (pn : N × N) :
    Int.IsCanonical (Int.normalize pn)
</code></pre>

<p>显然，每个整数都有且仅有一种表示方式。对于整数的运算（如+和*）必须产生规范结果。幸运的是，自然数对的规范化处理非常简单：</p>

<pre><code>def UPair.IsCanonical { }\alpha\mathrm{ : Type} [LinearOrder }\alpha\mathrm{ ] :
    \alpha \times \alpha \rightarrow \text { Prop}
    | (a, b) =&gt; a \leq b
def UPair ( }\alpha\mathrm{ : Type) [LinearOrder }\alpha\mathrm{ ] : Type :=
    {ab : }\alpha\times\alpha\mathrm{ // UPair.IsCanonical ab}
</code></pre>

<p>对于无序对，除了始终将较小元素置于首位（或末位）外，不存在明显的规范形式。这需要在<span class="math">\(\alpha\)</span>上定义一个线性序<span class="math">\(\leq\)</span>：</p>

<p>回到Int.IsCanonical，我们注意到存在两个证明(<span class="math">\(\circ, \circ\)</span>)是规范的，分别使用Int.IsCanonical.nonpos或Int.IsCanonical.nonneg。这并非问题，因为根据证明无关性，这些证明必定相等。</p>

<h3>12.6 新引入的Lean构造总结</h3>
<h4>声明不可计算前缀 非计算性声明</h4>
<h4>常量</h4>
<p>Classical.choice
Classical.choose
Quotient
Quotient.lift
Quotient.lift <span class="math">\({ }_{2}\)</span>
Setoid
Sort <span class="math">\(u\)</span>
Subtype.mk
Subtype.property
Subtype.val
返回非空类型任意元素的函数
给定存在性证明返回见证值的函数
根据给定等价关系实例创建商类型的函数
将一元函数提升至商类型的函数
将二元函数提升至商类型的函数
带有等价关系的类型类
u层级的宇宙
构造子类型值的函数
从子类型值提取属性的函数
从子类型值提取基础值的函数</p>

<table>
<thead>
<tr>
  <th style="text-align:left"><span class="math">\(\{x: \alpha / / P[x]\}\)</span></th>
  <th style="text-align:left">subtype of all <span class="math">\(x\)</span> in <span class="math">\(\alpha\)</span> fulfilling <span class="math">\(P[x]\)</span>
</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left"><span class="math">\(\approx\)</span></td>
  <td style="text-align:left">equivalence relation on a setoid (used for quotienting)</td>
</tr>
<tr>
  <td style="text-align:left">Prop</td>
  <td style="text-align:left">abbreviation for Sort <span class="math">\(\theta\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">Type u</td>
  <td style="text-align:left">abbreviation for Sort <span class="math">\((u+1)\)</span>
</td>
</tr>
</tbody>
</table>

<h4>记号</h4>
<h4>定理</h4>
<p>Classical.axiomOfChoice
传统选择公理
Classical.choose_spec
Quotient.exact 商类型上的等式蕴含基类型上的<span class="math">\(\approx\)</span>关系 Quotient.inductionOn 商类型值的归纳原理
Quotient.sound <span class="math">\(\quad \approx\)</span>基类型上的关系蕴含商类型上的等式
Subtype.eq 基类型上的等式蕴含子类型上的等式</p>


<h2>第十三章：基础数学结构</h2>
<p>本章将介绍关于群、域和线性序等基础数学结构的定义与证明。</p>


<h3>13.1 基于单一二元运算的类型类</h3>
<p>在数学中，群是指一个集合<span class="math">\(G\)</span>及其上的二元运算<span class="math">\(\cdot: G \times G \rightarrow G\)</span>，该运算满足以下性质（称为群公理）：</p>
<ul>
<li>结合律：对所有<span class="math">\(a, b, c \in G\)</span>，有<span class="math">\((a \cdot b) \cdot c=a \cdot(b \cdot c)\)</span>；</li>
<li>单位元：存在元素<span class="math">\(e \in G\)</span>使得对所有<span class="math">\(a \in G\)</span>，有<span class="math">\(e \cdot a=a\)</span>；</li>
<li>逆元：对每个<span class="math">\(a \in G\)</span>，存在逆元记作<span class="math">\(a^{-1}\)</span>，满足<span class="math">\(a^{-1} \cdot a=e\)</span>。在Lean中，群的类型类可定义如下：</li>
</ul>

<pre><code>class Group ( }\alpha\mathrm{ : Type) where
    mul : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha
    one : }\alpha
    inv : }\alpha\mathrm{ \rightarrow }\alpha
    mul_assoc : }\forall\mathrm{ a b c, mul (mul a b) c = mul a (mul b c)
    one_mul : }\forall\mathrm{a, mul one a = a
    mul_left_inv : }\forall\mathrm{a, mul (inv a) a = one
</code></pre>

<p>然而，这并非官方定义。群实际上是更大代数结构层次体系中的一部分。</p>


<p>群运算可以写成乘法形式（使用运算符<span class="math">\(*\)</span>、单位元1和逆元<span class="math">\(a^{-1}\)</span>），也可以写成加法形式（使用运算符+、单位元0和逆元<span class="math">\(-a\)</span>）。因此Lean提供了两种群类型类：乘法群Group和加法群AddGroup。它们在本质上是相同的，只是为常量和属性使用了不同的命名。</p>

<pre><code>inductive Int2 : Type
    | zero
</code></pre>
<p>任何满足群公理的类型都可以注册为Group或AddGroup。为说明这一点，我们将定义模2整数类型Int2（也称为<span class="math">\(\mathbb{Z} / 2 \mathbb{Z}\)</span>或<span class="math">\(\mathbb{Z}_{2}\)</span>），并将其注册为AddGroup。该类型Int2包含两个元素：</p>
<pre><code>def Int2.add : Int2 -&gt; Int2 -&gt; Int2
    | Int2.zero, a =&gt; a
    | Int2.one, Int2.zero =&gt; Int2.one
    | Int2.one, Int2.one =&gt; Int2.zero
</code></pre>

<p>| 一
加法运算定义如下：</p>

<pre><code>                add : <span class="math">\(\alpha \rightarrow \alpha \rightarrow \alpha\)</span>
                zero : <span class="math">\(\alpha\)</span>
                neg : <span class="math">\(\alpha \rightarrow \alpha\)</span>
            add_assoc : \Va b c, add (add a b) c = add a (add b c)
                zero_add : \Va, add zero a = a
                add_zero: \Va, add a zero = a
    neg_add_cancel : \Va, add (neg a) a = zero
        nsmul : <span class="math">\(\mathbb{N} \rightarrow \alpha \rightarrow \alpha\)</span>
        zsmul : <span class="math">\(\mathbb{Z} \rightarrow \alpha \rightarrow \alpha\)</span>
</code></pre>

<p>要实例化AddGroup，我们需要提供以下常量和属性：</p>


<p>常量AddGroup.add、AddGroup.zero和AddGroup.neg分别对应二元运算符、单位元和逆元。属性AddGroup.add_assoc、AddGroup.zero_add和AddGroup.neg_add_cancel对应群公理的三条要求。由于技术原因，我们还必须证明冗余属性AddGroup.add_zero，并提供<span class="math">\(n\)</span>重加法的定义AddGroup.nsmul和AddGroup.zsmul。</p>

<pre><code>instance Int2.AddGroup : AddGroup Int2 :=
    { add := Int2.add
        zero := Int2.zero
        neg := fun a }\mapsto\mathrm{ a
        add_assoc :=
            by
                intro a b c
                cases a &lt;;&gt;
                    cases b &lt;;&gt;
                    cases c &lt;;&gt;
                rfl
    zero_add :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    add_zero :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    neg_add_cancel :=

    by
        intro a
        cases a &lt;;&gt;
            rfl
nsmul :=
    @nsmulRec Int2 (Zero.mk Int2.zero) (Add.mk Int2.add)
zsmul :=
    @zsmulRec Int2 (Zero.mk Int2.zero) (Add.mk Int2.add)
        (Neg.mk (fun a \hookrightarrow a))
        (@nsmulRec Int2 (Zero.mk Int2.zero) (Add.mk Int2.add)) }
</code></pre>

<p>可按如下方式将 Int2 类型注册为群：</p>

<p>对于AddGroup.nsmul和AddGroup.zsmul，我们使用mathlib提供的默认定义。</p>
<pre><code>\#reduce Int2.one + $\theta-\theta-$ Int2.one
</code></pre>

<p>得益于上述类型类实例，我们现在可以书写<span class="math">\(\theta,+,-,\)</span>等符号：</p>

<table>
<thead>
<tr>
  <th style="text-align:left">Type class</th>
  <th style="text-align:left">Properties</th>
  <th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">Semigroup</td>
  <td style="text-align:left">associativity of +</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">Monoid</td>
  <td style="text-align:left">Semigroup with unit 1</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">LeftCancelSemigroup</td>
  <td style="text-align:left">Semigroup with c <span class="math">\(*\)</span> a <span class="math">\(=\mathrm{c} * \mathrm{~b} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">RightCancelSemigroup</td>
  <td style="text-align:left">Semigroup with a <span class="math">\(*\)</span> c <span class="math">\(=\mathrm{b} * \mathrm{c} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">Group</td>
  <td style="text-align:left">Monoid with inverse -1</td>
  <td style="text-align:left"></td>
</tr>
</tbody>
</table>

<p>代数层次结构还包含具有单一二元运算符的更多类型类，其主要类别列举如下：</p>

<table>
<thead>
<tr>
  <th style="text-align:left">Type class</th>
  <th style="text-align:left">Properties</th>
  <th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">AddSemigroup</td>
  <td style="text-align:left">associativity of +</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">AddMonoid</td>
  <td style="text-align:left">AddSemigroup with unit <span class="math">\(\theta\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">AddLeftCancelSemigroup</td>
  <td style="text-align:left">AddSemigroup with</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left"></td>
  <td style="text-align:left">c <span class="math">\(*\)</span> a <span class="math">\(=\mathrm{c}+\mathrm{b} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">AddRightCancelSemigroup</td>
  <td style="text-align:left">AddSemigroup with</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left"></td>
  <td style="text-align:left">a <span class="math">\(*\)</span> c <span class="math">\(=\mathrm{b}+\mathrm{c} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">AddGroup</td>
  <td style="text-align:left">AddMonoid with inverse -</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}\)</span></td>
</tr>
</tbody>
</table>

<p>对于大多数此类结构，都存在交换律版本（其中对所有元素<span class="math">\(a \cdot b=b \cdot a\)</span>）：CommSemigroup（交换半群）、CommMonoid（交换幺半群）、CommGroup（交换群）。这些结构也都具有以Add为前缀的加法对应版本：</p>

<p>虽然加法类型类只是其乘法对应物的副本，但在构建具有多个二元运算符（如环和域）的代数结构时，它们至关重要。为了避免基于乘法类型类的所有定理和定义重复，复制过程通过元程序自动完成。</p>
<pre><code>instance List.AddMonoid {\alpha: Type} : AddMonoid (List \alpha) :=
    { zero := []

add := fun xs ys }-&gt;\mathrm{ xs ++ ys
add_assoc := List.append_assoc
zero_add := List.nil_append
add_zero := List.append_nil
nsmul :=
    @nsmulRec (List }\alpha\mathrm{ ) (Zero.mk [])
    (Add.mk (fun xs ys }-&gt;\mathrm{ xs ++ ys))}
</code></pre>

<p>AddMonoid 的一个示例实例是类型 List <span class="math">\(\alpha\)</span>，其中空列表 [] 作为零元，追加运算符 ++ 作为加法：</p>


<p>我们可以继续将列表类型<span class="math">\(\alpha\)</span>与[]和++注册为左消去半群(AddLeftCancelSemigroup)和右消去半群(AddRightCancelSemigroup)。</p>


<p>下图展示了这些类型类之间的部分关系。在本图及后续图示中，从<span class="math">\(X\)</span>指向<span class="math">\(Y\)</span>的箭头表示"<span class="math">\(X\)</span>继承<span class="math">\(Y\)</span>的所有常量和属性"。</p>

<p><img src="img-14.jpeg" alt="img-14.jpeg"></p>

<h3>13.2 基于双二元运算符的类型类</h3>
<p>加法结构与乘法结构被融合，形成基于两个二元运算符的更复杂结构。域（field）就是其中之一。域<span class="math">\(F\)</span>由以下性质定义：</p>
<ul>
<li>
<span class="math">\(F\)</span>在称为加法的运算符+下构成交换群，其单位元为0。</li>
<li>
<span class="math">\(F \backslash\{0\}\)</span>在称为乘法的运算符<span class="math">\(=\)</span>下构成交换群。</li>
<li>乘法对加法满足分配律——即对所有<span class="math">\(a, b, c \in F\)</span>，有<span class="math">\(a=(b+c)=a \circ b+a \circ c\)</span>。
通过执行#print Field，我们可以显示Field类型类要求的所有常量和属性。同样，由于构造方式的原因，该类型类包含了一些冗余属性和定义。</li>
</ul>

<pre><code>def Int2.mul : Int2 -&gt; Int2 -&gt; Int2
    | Int2.one, a =&gt; a
    | Int2.zero, _ =&gt; Int2.zero
</code></pre>

<p>现在我们将通过将Int2实例化为Field类型类来证明它是一个域。首先，我们需要在Int2上定义乘法运算：</p>

<pre><code>theorem Int2.mul_assoc (a b c : Int2) :
    Int2.mul (Int2.mul a b) c = Int2.mul a (Int2.mul b c) :=
    by
    cases a &lt;;&gt;
        cases b &lt;;&gt;
        cases c &lt;;&gt;
        rfl
instance Int2.Field : Field Int2 :=
    { Int2.AddGroup with
        one := Int2.one
        mul := Int2.mul
        inv := fun a -&gt; a
    add_comm :=
        by
            intro a b
            cases a &lt;;&gt;
            cases b &lt;;&gt;
            rfl
    exists_pair_ne :=
        by
            apply Exists.intro Int2.zero
            apply Exists.intro Int2.one
            simp
    zero_mul :=
        by
            intro a
            rfl
    mul_zero :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    one_mul :=
        by
            intro a
            rfl
    mul_one :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    mul_inv_cancel :=
        by
            intro a h
            cases a
            { apply False.elim
                apply h
                rfl }

        { rfl }
inv_zero := by rfl
mul_assoc := Int2.mul_assoc
mul_comm :=
    by
        intro a b
        cases a &lt;;&gt;
            cases b &lt;;&gt;
            rfl
left_distrib :=
    by
        intro a b c
        cases a &lt;;&gt;
            cases b &lt;;&gt;
            rfl
right_distrib :=
    by
        intro a b c
        cases a &lt;;&gt;
            cases b &lt;;&gt;
            cases c &lt;;&gt;
            rfl
nnqsmul := _
nnqsmul_def :=
    by
        intro a b
        rfl
qsmul := _
qsmul_def :=
    by
        intro a b
        rfl
nnratCast_def :=
    by
        intro q
        rfl }
</code></pre>
<p>要将Int2声明为域，我们可以复用之前通过Int2.AddGroup with语法定义的Int2.AddGroup实例。剩余属性的证明如下：</p>

<p>(由于Lean的限制，Field.mul_assoc字段被单独证明为一个独立定理。)</p>

<pre><code>\#reduce (1 : Int2) * 0 / (0 - 1)
</code></pre>

<p>完成这个类型类实例化后，我们现在可以使用1、*、/等符号表示法：</p>

<pre><code>\#reduce (3 : Int2)
</code></pre>

<p>该命令会输出 Int2. zero。此处的类型标注 : Int2 是必要的，用于告知 Lean 我们希望在 Int2 而非默认的 <span class="math">\(\mathbb{N}\)</span> 中进行计算。我们甚至可以在 Int2 中使用任意数字。例如，数字 3 会被解释为 <span class="math">\(1+1+1\)</span>，这在 Int2 中等同于 1：</p>

<table>
<thead>
<tr>
  <th style="text-align:left">Type class</th>
  <th style="text-align:left">Properties</th>
  <th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">Semiring</td>
  <td style="text-align:left">Monoid and AddCommMonoid with distributivity</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">CommSemiring</td>
  <td style="text-align:left">Semiring with commutativity of <span class="math">\(*\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">Ring</td>
  <td style="text-align:left">Monoid and AddCommGroup with distributivity</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">CommRing</td>
  <td style="text-align:left">Ring with commutativity of <span class="math">\(*\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">DivisionRing</td>
  <td style="text-align:left">Ring with multiplicative inverse</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">Field</td>
  <td style="text-align:left">DivisionRing with commutativity of <span class="math">\(*\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}\)</span></td>
</tr>
</tbody>
</table>

<p>该命令输出Int2.one。除了Field之外，还有更多针对具有两个二元运算符结构的类型类，以下是主要的几种：</p>


<p>下图展示了这些类型类之间的关系。</p>


<p><img src="img-15.jpeg" alt="img-15.jpeg"></p>


<p>Field类型类要求满足性质<span class="math">\(\forall a, a / \theta=\theta\)</span>。这只是为了使除法成为全函数的一种约定。数学家通常将除法视为偏函数。以这种方式将偏函数全函数化并无害处。</p>

<pre><code>theorem ring_example (a b : Int2) :
    <span class="math">\((a \cdot b) \wedge 3=a \wedge 3+3 * a \wedge 2 * b+3 * a * b \wedge 2 * b \wedge 3\)</span>
    <span class="math">\(:=\)</span>
    by ring
</code></pre>

<p>当我们用特定类型实例化类型类后，就可以使用ring策略来规范化包含该类型运算符的项。例如：</p>


<p>该策略适用于任何被声明为域或更广义上的交换半环的类型。</p>

<pre><code>theorem neg_mul_neg_Nat <span class="math">\((n: \mathbb{N})(z: \mathbb{Z}):\)</span>
    <span class="math">\((-z) *(-\mathrm{n})=z * n:=\)</span>
    by simp
</code></pre>
<h3>13.3 强制类型转换</h3>
<p>当在同一个定理中组合来自<span class="math">\(\mathbb{N}, \mathbb{Z}, \mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>的数值时，我们可能需要将一种类型强制转换为另一种类型。例如给定一个自然数时，可能需要将其转换为整数。考虑以下定理并注意乘法参数的类型：</p>

<p>令人惊讶的是，这个陈述并未引发错误，尽管取反操作 - n 在<span class="math">\(n: \mathbb{N}\)</span>上无定义，且<span class="math">\(z: \mathbb{Z}\)</span>与<span class="math">\(n: \mathbb{N}\)</span>的乘法运算也未定义。</p>

<pre><code>neg_mul_neg_Nat : V (n : N)(z : Z), -z * -\n = z * \n
</code></pre>

<p>诊断命令#check neg_mul_neg_Nat向我们揭示了实际发生的情况：</p>

<p>Lean 提供了一种强制转换机制，在需要时通过<span class="math">\(\div\)</span>或coe表示。该强制转换运算符可设置为任意类型之间提供隐式转换。系统已预设许多强制转换，包括：</p>
<ul>
<li>coe : <span class="math">\(\mathbb{N} \rightarrow \alpha\)</span> 将<span class="math">\(\mathbb{N}\)</span>转换为其他半环<span class="math">\(\alpha\)</span>；</li>
<li>coe : <span class="math">\(\mathbb{Z} \rightarrow \alpha\)</span> 将<span class="math">\(\mathbb{Z}\)</span>转换为其他环<span class="math">\(\alpha\)</span>；</li>
<li>coe : <span class="math">\(\mathbb{Q} \rightarrow \alpha\)</span> 将<span class="math">\(\mathbb{Q}\)</span>转换为其他除环<span class="math">\(\alpha\)</span>。</li>
</ul>
<pre><code>theorem neg_Nat_mul_neg (n : N) (z : Z) :
    (- n : Z) * (- z) = n * z :=
    by simp
</code></pre>
<p>我们可以通过提供类型标注来记录意图，或帮助Lean确定强制转换的位置，如下例所示：</p>
<pre><code>theorem Eq_coe_int_imp_Eq_Nat (m n : N)
    (h : (m : Z) = (n : Z)) :
    m}=\textrm{n}:=\mathrm{o
    by norm_cast at h
</code></pre>
<p>在涉及强制类型转换的证明中，norm_cast策略会非常实用。它能协助处理诸如<span class="math">\(\vdash \mathrm{m} \mathrm{n}: \mathbb{N}, \mathrm{h}: \leq \mathrm{m}=\leq \mathrm{n} \vdash \mathrm{m}=\mathrm{n}\)</span>这类目标。</p>
<pre><code>theorem Nat_coe_Int_add_eq_add_Nat_coe_Int (m n : N) :
    (m : Z) + (n : Z) = ((m + n : N) : Z) :=
    by norm_cast
</code></pre>

<p>类似地，它也有助于处理目标<span class="math">\(\vdash \mathrm{m} \mathrm{n}: \mathbb{N} \vdash \leq \mathrm{m}+\leq \mathrm{n}=\leq(\mathrm{m}+\mathrm{n})\)</span>中的情况</p>

<div class="math">$$
\begin{aligned}
&amp; \text { Nat.cast_add : Va b : } \mathbb{N}, \leq(\mathrm{a}+\mathrm{b})=\leq \mathrm{a}+\leq \mathrm{b} \\
&amp; \text { Int.cast_add : Va b : } \mathbb{Z}, \leq(\mathrm{a}+\mathrm{b})=\leq \mathrm{a}+\leq \mathrm{b} \\
&amp; \text { Rat.cast_add : Va b : } \mathbb{Q}, \leq(\mathrm{a}+\mathrm{b})=\leq \mathrm{a}+\leq \mathrm{b}
\end{aligned}
$$</div>

<p>norm_cast策略依赖于以下这类定理：</p>


<h3>13.4 标准化策略</h3>
<p>代数策略ring和强制转换策略norm_cast通过标准化方式工作：它们重写表达式以期达成语法层面的等价，此时等式的证明将变得微不足道。与rw和simp类似，当这些策略取得部分进展但未能完全证明目标时，会产生一个子目标。</p>


<p>可选的位置参数与重写策略相同（参见第3.5节）。</p>


<h4>ring</h4>
<p>ring [在指定位置]
该ring策略通过规范化表达式并语法比较结果，来证明交换环和半环（如<span class="math">\(\mathbb{N}, \mathbb{Z}, \mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>）上的等式。</p>


<h4>norm_cast</h4>
<p>norm_cast [位置标记]
norm_cast策略通过将强制类型转换推向表达式外部来实现简化。</p>


<h3>13.5 列表、多重集与有限集</h3>
<p>在前述章节中，我们已经看到许多使用列表的示例。但在进行新定义或陈述新定理时，我们也应考虑多重集和有限集等替代方案。</p>

<pre><code>def List.elems : Tree N -&gt; List N
    | Tree.nil =&gt; []
    | Tree.node a l r =&gt; a :: List.elems l ++ List.elems r
</code></pre>
<p>考虑以下基于我们在5.8节介绍的二叉树所给出的定义：</p>
<p>该函数返回树中所有元素的列表，采用深度优先、从左至右的遍历方式。但对于某些应用场景，元素的顺序可能无关紧要。</p>
<pre><code>def Multiset.elems : Tree N -&gt; Multiset N
    | Tree.nil =&gt; 0
    | Tree.node a l r =&gt;
        {a} \ Multiset.elems l \ Multiset.elems r
</code></pre>

<p>这正是多重集发挥作用之处。对于多重集而言，我们有<span class="math">\(\{3,2,1,2\}=\)</span> <span class="math">\(\{1,2,2,3\}\)</span>，而两个列表<span class="math">\([3,2,1,2]\)</span>和<span class="math">\([1,2,2,3]\)</span>则是不同的。多重集被定义为列表在重排序下的商类型。我们可以用多重集重写上述定义如下：</p>


<p>根据此定义，我们可以证明 Multiset.elems <span class="math">\(t=\)</span> Multiset.elems (mirror t)，而 List.elems <span class="math">\(t=\)</span> List.elems (mirror <span class="math">\(t\)</span> ) 在一般情况下并不成立。</p>

<pre><code>def Finset.elems : Tree N -&gt; Finset N
    | Tree.nil =&gt; 0
    | Tree.node a l r =&gt; {a} \ Finset.elems l \ Finset.elems r
</code></pre>
<p>在某些应用中，我们可能需要更进一步，不仅忽略元素的顺序，还忽略每个元素在树中出现的次数，仅区分存在与不存在。这正是有限集合（或称finset）的用武之地。在finset中，我们有<span class="math">\(\{3,2,1,2\}=\{1,2,3\}\)</span>。finset被定义为不包含任何重复元素的多重集合子类型（另一种可能的定义方式是作为有限集合的子类型）。我们可以用finset重写上述定义如下：</p>
<pre><code>Reval List.sum [2, 3, 4]
Reval Multiset.sum ({2, 3, 4} : Multiset N)
Reval List.prod [2, 3, 4]
Reval Multiset.prod ({2, 3, 4} : Multiset N)
</code></pre>
<p>对于列表和多重集合，Lean提供了求和与乘积运算符来累加或连乘所有元素。以下前两条命令输出9，后两条输出24：</p>
<p>这些运算符要求元素的类型必须声明为AddMonoid实例（用于求和）或Monoid实例（用于求积）。多重集版本还需要声明AddCommMonoid或CommMonoid实例，因为其结果不能依赖于元素相加或相乘的顺序。</p>
<pre><code>inductive Nat.le : <span class="math">\(\mathbb{N} \rightarrow \mathbb{N} \rightarrow\)</span> Prop
    | refl : Va : N, Nat.le a a
    | step : Va b : N, Nat.le a b <span class="math">\(\rightarrow\)</span> Nat.le a (b + 1 )
</code></pre>

<h3>13.6 序类型类</h3>
<p>前文介绍的许多结构都可以被排序。例如，自然数上常见的序关系可定义为</p>


<p>这是一个线性序的例子。线性序（或称全序）是一种二元关系<span class="math">\(\leq\)</span>，对于所有<span class="math">\(a, b\)</span>和<span class="math">\(c\)</span>满足以下性质：</p>
<ul>
<li>自反性：<span class="math">\(a \leq a\)</span>；</li>
<li>传递性：若<span class="math">\(a \leq b\)</span>且<span class="math">\(b \leq c\)</span>，则<span class="math">\(a \leq c\)</span>；</li>
<li>反对称性：若<span class="math">\(a \leq b\)</span>且<span class="math">\(b \leq a\)</span>，则<span class="math">\(a=b\)</span>；</li>
<li>完全性：<span class="math">\(a \leq b\)</span>或<span class="math">\(b \leq a\)</span>。</li>
</ul>

<p>若一个关系具备前三个性质，则称为偏序。例如集合、有限集或多重集上的子集关系<span class="math">\(\subseteq\)</span>。若一个关系仅具备前两个性质，则称为预序。例如通过列表长度比较的序关系。</p>
<div class="math">$$
\begin{gathered}
\text { le : } \alpha \rightarrow \alpha \rightarrow \text { Prop } \\
\text { le_refl : } \forall \mathrm{a}: \alpha, \text { le a a } \\
\text { le_trans: } \forall \mathrm{a} b \mathrm{c}: \alpha, \text { le a b } \rightarrow \text { le b c } \rightarrow \text { le a c }
\end{gathered}
$$</div>

<p>在Lean中，针对不同类型的序关系设有类型类：LinearOrder（线性序）、PartialOrder（偏序）和Preorder（预序）。其中Preorder类包含一个常量与两个属性：</p>

<div class="math">$$
\text { le_antisymm : } \forall \mathrm{a} b: \alpha, \text { le a b } \rightarrow \text { le b a } \rightarrow \mathrm{a}=\mathrm{b}
$$</div>

<p>PartialOrder类具有额外的属性</p>

<div class="math">$$
\text { le_total : } \forall \mathrm{a} b: \alpha, \text { le a b } \vee \text { le b a }
$$</div>
<p>而LinearOrder则具有附加属性</p>
<pre><code>instance List.length.Preorder {\alpha: Type} : Preorder (List \alpha):=
    { le :=
        fun xs ys }-&gt;\mathrm{ List.length xs \leq List.length ys
    lt :=
        fun xs ys }-&gt;\mathrm{ List.length xs &lt; List.length ys
    le_refl :=
        by
            intro xs
            apply Nat.le_refl
    le_trans :=
        by
            intro xs ys zs
            exact Nat.le_trans
    lt_iff_le_not_le :=
        by

intro a b
exact Nat.lt_iff_le_not_le }
</code></pre>
<p>我们可以声明List <span class="math">\(\alpha\)</span>上的预序关系，该关系通过列表长度进行比较，如下所示：</p>
<pre><code>theorem list.length.Preorder_example :&gt;[] :=
    by decide
</code></pre>

<p>该类型类实例提供了中缀语法<span class="math">\(\leq\)</span>及对应关系<span class="math">\(\geq,&lt;\)</span>和<span class="math">\(&gt;\)</span>的访问权限：</p>


<p>该证明采用了一种新策略decide，它依赖类型类推断来证明可判定的简单目标。</p>

<p>我们在第11章讨论的完全格被形式化为另一个类型类CompleteLattice，它继承自PartialOrder。</p>
<p><img src="img-16.jpeg" alt="img-16.jpeg"></p>

<p>最后，Lean提供了结合序结构与代数结构的类型类：有序可交换消去幺半群(OrderedCancelCommMonoid)、有序交换群(OrderedCommGroup)、有序半环(OrderedSemiring)、线性有序半环(LinearOrderedSemiring)、线性有序交换环(LinearOrderedCommRing)、线性有序域(LinearOrderedEvent)。所有这些数学结构通过单调性规则（例如<span class="math">\(a \leq b \rightarrow c \leq d \rightarrow a \star c \leq b \star d\)</span>）和消去规则（例如<span class="math">\(c \star\)</span><span class="math">\(a \leq c \star b \rightarrow a \leq b)\)</span>）将<span class="math">\(\leq\)</span>和<span class="math">\(&lt;\)</span>与常量<span class="math">\(\circ, 1, \star\)</span>以及<span class="math">\(\star\)</span>关联起来。</p>


<h3>13.7 决策策略</h3>
<h4>decide</h4>
<p>decide策略可用于证明可判定为真的目标。通过检查是否属于Decidable类型类来确定可判定性。与rfl不同，decide不仅限于证明等式。</p>


<h3>13.8 新引入的Lean结构摘要</h3>
<h4>符号表示</h4>
<p><span class="math">\(\uparrow \quad\)</span> 强制转换操作符coe</p>


<h4>策略</h4>
<p>decide
norm_cast
ring
证明可判定真值（例如，一个可执行的真表达式）
规范化强制转换
规范化环表达式</p>


<h2>第十四章：有理数与实数</h2>
<p>在前几章中，我们已经看到自然数<span class="math">\(\mathbb{N}\)</span>如何被定义为归纳类型，以及整数<span class="math">\(\mathbb{Z}\)</span>如何被定义为<span class="math">\(\mathbb{N} \times \mathbb{N}\)</span>上的商集。本章我们将回顾有理数<span class="math">\(\mathbb{Q}\)</span>和实数<span class="math">\(\mathbb{R}\)</span>的构造过程。这些构造所使用的工具包括归纳类型、子类型和商集。</p>


<p>以下步骤可用于构造具有特定性质的类型：</p>
<ol>
<li>创建一个足够大的新类型来表示所有元素，但不一定以唯一方式表示。</li>
<li>对该表示进行商处理，根据需要将元素等同化。</li>
<li>通过从基类型提升函数来定义商类型上的运算符，并证明它们与商关系兼容。我们在12.5.1节中采用此方法构造了类型<span class="math">\(\mathbb{Z}\)</span>。该方法同样适用于<span class="math">\(\mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>。</li>
</ol>

<pre><code>structure Fraction where
    num : <span class="math">\(\mathbb{Z}\)</span>
    denom : <span class="math">\(\mathbb{Z}\)</span>
    denom_Neq_zero : denom <span class="math">\(\neq 0\)</span>
</code></pre>

<h3>14.1 有理数</h3>
<p>有理数是指可以表示为整数<span class="math">\(n\)</span>与<span class="math">\(d\)</span>的分数形式<span class="math">\(n / d\)</span>的数，其中<span class="math">\(d \neq 0\)</span>：</p>

<p>数字<span class="math">\(n\)</span>被称为分子，数字<span class="math">\(d\)</span>被称为分母。有理数作为分数的表示方式并不唯一。例如，有理数<span class="math">\(1 / 2,2 / 4\)</span>和<span class="math">\(-1 /-2\)</span>都是相等的。这种分数表示形式将作为我们取商的基础类型。</p>
<pre><code>instance Setoid : Setoid Fraction :=
    { r :=
        fun a b : Fraction }-&gt;\mathrm{ num a * denom b = num b * denom a
        iseqv :=
            { refl := by aesop
                symm := by aesop
                trans :=
                    by
                        intro a b c heq_ab heq_bc
                        apply Int.eq_of_mul_eq_mul_right (denom_Neq_zero b)
                        calc
                            num a * denom c * denom b
                            = num a * denom b * denom c :=
                            by ac_rfl
                            _ = num b * denom a * denom c :=
                            by rw [heq_ab]
                            _ = num b * denom c * denom a :=
                            by ac_rfl
                            _ = num c * denom b * denom a :=
                            by rw [heq_bc]
                            _ = num c * denom a * denom b :=
                            by ac_rfl
    } }
theorem Setoid_Iff (a b : Fraction) :
        a \approx b \leftrightarrow num a * denom b = num b * denom a :=
    by rfl
end Fraction
</code></pre>
<p>若两个分数<span class="math">\(n_{1} / d_{1}\)</span>和<span class="math">\(n_{2} / d_{2}\)</span>的分子与分母之比相同，即满足<span class="math">\(n_{1} \approx d_{2}=n_{2} \approx d_{1}\)</span>，则它们表示同一个有理数。为了在Fraction类型上构造关于该关系的商类型，我们需要证明该关系是等价关系。具体实现方式是将Fraction声明为Setoid类型类的实例：</p>
<pre><code>def Rat : Type :=
    Quotient Fraction.Setoid
</code></pre>
<p>随后我们可以将有理数类型定义为该集类上的商类型：</p>
<pre><code>instance Add : Add Fraction :=
    { add := fun a b : Fraction }-&gt;
        { num := num a * denom b + num b * denom a
            denom := denom a * denom b
            denom_Neq_zero := by simp [denom_Neq_zero] } }
</code></pre>

<p>要定义零、一、加法、乘法及其他运算，我们首先在Fraction类型上定义它们。要将两个分数相加，我们将其转换为同分母后相加分子。最简单的通用分母就是两个分母的乘积：
namespace Fraction</p>

<pre><code>@[simp] theorem add_num (a b : Fraction) :
    num (a + b) = num a * denom b + num b * denom a :=
    by rfl
@[simp] theorem add_denom (a b : Fraction) :
    denom (a * b) = denom a * denom b :=
    by rfl
theorem Setoid_add {a a' b b' : Fraction} (ha : a \approx a')
        (hb : b \approx b') :
    a + b \approx a' + b' :=
    by
    simp [Setoid_Iff, add_denom, add_num] at *
    calc
        (num a * denom b + num b * denom a)
            * (denom a' * denom b')
        = num a * denom a' * denom b * denom b'
            + num b * denom b' * denom a * denom a' :=
            by
                simp [add_mul, mul_add]
                ac_rfl
            _ = num a' * denom a * denom b * denom b'
                + num b' * denom b * denom a * denom a' :=
            by simp [*]
            _ = (num a' * denom b' + num b' * denom a')
                * (denom a * denom b) :=
            by
                simp [add_mul, mul_add]
                ac_rfl
end Fraction
</code></pre>
<p>我们将这些运算注册为语法类型类（如Add）的实例，以便能够对Fraction使用诸如+之类的便捷符号。类似地，我们将零定义为<span class="math">\(0:=0 / 1\)</span>，将一定义为<span class="math">\(1:=1 / 1\)</span>，并将乘法定义为分子与分母的逐项相乘。为了将这些运算提升至有理数类型Rat，我们必须证明它们与<span class="math">\(\approx\)</span>的兼容性：</p>
<pre><code>namespace Rat
instance Add : Add Rat :=
    { add := Quotient.lift2 (fun a b : Fraction \mapsto mk (a + b))
        (by
            intro a b a' b' ha hb
            apply Quotient.sound
            exact Fraction.Setoid_add ha hb) }
end Rat
</code></pre>
<p>随后我们可以使用商集<span class="math">\(\operatorname{lift}\left({ }_{2}\right)\)</span>来定义Rat类型的运算，并实例化相关的语法类型类，例如</p>

<p>由此出发，我们可以继续推进并证明所有使Rat成为Field实例所需的性质。</p>

<pre><code>def Rat.IsCanonical (a : Fraction) : Prop :=
    Fraction.denom a &gt; 0
    \ Nat.Coprime (Int.natAbs (Fraction.num a))
        (Int.natAbs (Fraction.denom a))
def Rat : Type :=
    {a : Fraction // Rat.IsCanonical a}
</code></pre>

<p>有理数的替代定义 在mathlib中，采用另一种方法来定义有理数。Rat类型被定义为Fraction的子类型，要求分母为正且分子与分母互质（即除1和-1外没有其他公约数）：</p>


<p>这是12.5.3节所述通用策略的一个实例。采用此方法无需构造商类型，计算效率更高，且更多性质可通过计算转化为语法等价。缺点是函数定义会因分数正规化的需求而变得更为复杂。</p>

<div class="math">$$
\begin{aligned}
&amp; a_{0}=1 \\
&amp; a_{1}=1.4 \\
&amp; a_{2}=1.41 \\
&amp; a_{3}=1.414 \\
&amp; a_{4}=1.4142 \\
&amp; \quad \vdots
\end{aligned}
$$</div>

<h3>14.2 实数</h3>
<p>某些有理数序列看似收敛，因为序列中的数彼此越来越接近，但却不收敛于任何有理数。例如序列</p>


<p>其中<span class="math">\(a_{n}\)</span>是小数点后具有<span class="math">\(n\)</span>位数且满足<span class="math">\(a_{n}^{2}&lt;2\)</span>的最大数，该序列即属此类。它看似收敛，因为每个<span class="math">\(a_{n}\)</span>与后续数字的差距至多为<span class="math">\(10^{-n}\)</span>，但其极限<span class="math">\(\sqrt{2} \notin \mathbb{Q}\)</span>却不在有理数集内。从这个意义上说，有理数是不完备的，而实数则是其完备化。要构造实数，我们需要填补这些看似收敛却无极限的序列所揭示的间隙。</p>

<p>柯西序列捕捉了看似收敛的序列概念。一个序列<span class="math">\(a_{0}, a_{1}, \ldots\)</span>是柯西序列，如果对于任意<span class="math">\(\varepsilon&gt;0\)</span>，存在<span class="math">\(N \in \mathbb{N}\)</span>使得对于所有<span class="math">\(m \geq N\)</span>，都有<span class="math">\(\left|a_{N}-a_{m}\right|&lt;\varepsilon\)</span>。换言之，无论我们选择的<span class="math">\(\varepsilon\)</span>多小，总能找到序列中的一个点，使得其后所有数与它的偏差都小于<span class="math">\(\varepsilon\)</span>。</p>
<pre><code>def IsCauchySeq (f : N -&gt; Q) : Prop :=
    V\varepsilon &gt; 0, \existsN, \forallm \geq N, abs(f N - f m) &lt; \varepsilon
</code></pre>
<p>我们将有理数序列形式化为函数<span class="math">\(f: \mathbb{N} \rightarrow \mathbb{Q}\)</span>，并用abs表示绝对值<span class="math">\(|\mid\)</span>。由此得到柯西序列在Lean中的如下定义：</p>
<pre><code>theorem id_Not_CauchySeq :
    <span class="math">\(\neg\)</span> IsCauchySeq (fun \(n: \mathbb{N} \mapsto(n: \mathbb{Q})):=
    by
        rw [IsCauchySeq]
        intro h
        cases h 1 zero_lt_one with
        | intro i hi =&gt;
            have hi_succi :=
                hi (i + 1) (by simp)
            simp [ \--sub_sub] at hi_succi
</code></pre>

<p>并非所有序列都是柯西序列：</p>

<pre><code>def CauchySeq : Type :=
    {f : N -&gt; Q // IsCauchySeq f}
</code></pre>
<p>我们将柯西序列的一种类型定义为子类型：</p>
<pre><code>def seqOf (f : CauchySeq) : N -&gt; Q :=
    Subtype.val f
</code></pre>

<p>定义一个辅助函数来从CauchySeq中提取实际序列会很方便：</p>


<p>构造的基本思想是用柯西序列来表示实数。每个柯西序列代表其极限所对应的实数；例如，序列<span class="math">\(a_{n}=1 / n\)</span>代表实数0，而序列<span class="math">\(1,1.4,1.41, \ldots\)</span>则代表实数<span class="math">\(\sqrt{2}\)</span>。</p>

<pre><code>namespace CauchySeq
instance Setoid : Setoid CauchySeq :=
{ r :=
    fun f g : CauchySeq \mapsto
        \forall \varepsilon&gt;\emptyset, \exists N, \forall m \geq N, \text { abs (seqOf f m - seqOf g m) &lt; } \varepsilon
    iseqv :=
        { refl :=
            by
                intro f \varepsilon h
                apply Exists.intro
                aesop
            symm :=
            by
                intro f g hfg \varepsilon h
                cases hfg \varepsilon hE with
                | intro N hN =&gt;
                apply Exists.intro N
                intro m hm

            rw [abs_sub_comm]
            apply hN m hm
trans :=
    by
        intro f g h hfg hgh \varepsilon h
        cases hfg ( \varepsilon / 2) (by linarith) with
        | intro N
            cases hgh ( \varepsilon / 2) (by linarith) with
            | intro N
                apply Exists.intro (max N
                intro m hm
                calc
                    abs (seqOf f m - seqOf h m)
                    \leq abs (seqOf f m - seqOf g m)
                    + abs (seqOf g m - seqOf h m) :=
                    by apply abs_sub_le
                _ &lt; \varepsilon / 2 + \varepsilon / 2 :=
                    add_lt_add (hN
                    (hN
                    by_simp } }
theorem Setoid_iff (f g : CauchySeq) :
    f \leqq g \leftrightarrow
    \forall \varepsilon&gt;\emptyset, \exists N, \forall m \geq N, \text { abs (seqOf f m - seqOf g m) &lt; \varepsilon :=}
    by rfl
end CauchySeq
</code></pre>

<p>两个不同的柯西序列可以表示相同的实数；例如，序列<span class="math">\(a_{n}=1 / n\)</span>和常数序列<span class="math">\(b_{n}=0\)</span>都表示0。因此，我们需要对表示同一实数的序列进行商集处理。当两个序列的差收敛于零时，它们表示相同的实数：</p>

<pre><code>def Real : Type :=
  Quotient CauchySeq. Setoid
</code></pre>

<p>利用这个Setoid实例，我们现在可以定义实数：</p>

<pre><code>namespace CauchySeq
def const (q : Q) : CauchySeq :=
Subtype.mk (fun _ : $\mathbb{N} \mapsto \mathrm{q}$ )
(by
rw [IsCauchySeq]
intro $\varepsilon$ h $\varepsilon$
aesop)
end CauchySeq
</code></pre>
<p>如同有理数的情况，我们需要定义零、一、加法、乘法及其他运算符。我们首先在CauchySeq上定义这些运算，随后将其提升到Real类型。对于常量<span class="math">\(\varnothing\)</span>和1，我们可以简单地将其定义为常值序列。任何常值序列都是柯西序列：</p>
<pre><code>namespace Real
instance Zero : Zero Real :=
    { zero := [CauchySeq. const 0] }
instance One : One Real :=
    { one := [CauchySeq. const 1] }
end Real
</code></pre>

<p>我们可以为语法类型类 zero 和 One 声明 Real 实例：</p>

<pre><code>instance Add : Add CauchySeq :=
    { add := fun f g : CauchySeq }
        Subtype.mk (fun n : N}-&gt;\mathrm{ seqOf f n + seqOf g n) sorry }
</code></pre>

<p>定义实数的加法需要稍多一些步骤。我们通过在柯西序列上逐对相加元素来定义加法：
namespace CauchySeq</p>


<p>该定义需要证明当<span class="math">\(f\)</span>和<span class="math">\(g\)</span>为柯西序列时，结果仍是柯西序列。此处省略证明过程，故标记为sorry。</p>

<pre><code>theorem Setoid_add {f f' g g' : CauchySeq} (hf : f \ f')
        (hg : g \ g') :
        f + g \ f' + g' :=
    by
        intro <span class="math">\(\varepsilon_{0}\)</span> h <span class="math">\(\varepsilon_{0}\)</span>
        simp [Setoid_iff]
        cases hf ( <span class="math">\(\varepsilon_{0} / 2\)</span> ) (by linarith) with
        | intro Nf hNf =&gt;
            cases hg ( <span class="math">\(\varepsilon_{0} / 2\)</span> ) (by linarith) with
            | intro Ng hNg =&gt;
                apply Exists.intro (max Nf Ng)
                intro m hm
                calc
                    abs (seqOf (f + g) m - seqOf (f' + g') m)
                    = abs ((seqOf f m + seqOf g m)
                    - (seqOf f' m + seqOf g' m)) :=
                    by rfl
            _ = abs ((seqOf f m - seqOf f' m)
                    + (seqOf g m - seqOf g' m)) :=
                    by
                        have arg_eq :
                        seqOf f m + seqOf g m
                            - (seqOf f' m + seqOf g' m) =
                            seqOf f m - seqOf f' m
                            + (seqOf g m - seqOf g' m) :=
                            by linarith
                            rw [arg_eq]
    _ \ abs (seqOf f m - seqOf f' m)
                            + abs (seqOf g m - seqOf g' m) :=
                            by apply abs_add

    &lt; \varepsilon0 / 2 + \varepsilon0 / 2 :=
    add_lt_add (hNf m (le_of_max_le_left hm))
        (hNg m (le_of_max_le_right hm))
    _=\varepsilon0:=
    by simp
end CauchySeq
</code></pre>

<p>接下来，我们需要证明这种加法与<span class="math">\(\approx\)</span>是相容的：</p>

<div class="math">$$
\forall m, m \geq N \rightarrow \operatorname{abs}(\operatorname{seqOf}(f+g) m-\operatorname{seqOf}\left(f^{\prime}+g^{\prime}\right) m)&lt;\varepsilon_{0}
$$</div>

<p>为证明<span class="math">\(f+g \approx f^{\prime}+g^{\prime}\)</span>，给定一个<span class="math">\(\varepsilon_{0}&gt;\theta\)</span>，需证明存在一个数<span class="math">\(N\)</span>使得</p>

<div class="math">$$
\operatorname{abs}(\operatorname{seqOf}(f+g) m-\operatorname{seqOf}\left(f^{\prime}+g^{\prime}\right) m)&lt;\varepsilon_{0}
$$</div>

<p>为确定N的取值，我们利用<span class="math">\(f \approx f^{\prime}\)</span>和<span class="math">\(g \approx g^{\prime}\)</span>的性质。等价关系<span class="math">\(f \approx f^{\prime}\)</span>表明：对于任意<span class="math">\(\varepsilon&gt;\)</span> <span class="math">\(\theta\)</span>，存在Nf使得对所有<span class="math">\(m \geq N f\)</span>有abs(seqOf f m - seqOf <span class="math">\(f^{\prime} m\)</span>) &lt; 。同理，<span class="math">\(g \approx g^{\prime}\)</span>给出具有类似性质的Ng。为确保最终计算成立，我们取<span class="math">\(\varepsilon:=\varepsilon_{0} / 2\)</span>时的Nf和Ng值。选择N为Nf与Ng的最大值，从而对所有<span class="math">\(m \geq N\)</span>成立相应不等式。证明末尾的计算块确立了对所有<span class="math">\(m \geq N\)</span>的结论。</p>

<pre><code>namespace Real
instance Add : Add Real :=
{ add := Quotient.lift 2 (fun a b : CauchySeq <span class="math">\(\mapsto\llbracket a+b \rrbracket\)</span> )
    (by
        intro a b a' b' ha hb
        apply Quotient.sound
        exact CauchySeq.Setoid_add ha hb) }
end Real
</code></pre>

<p>在证明了柯西序列上的加法运算与<span class="math">\(\approx\)</span>关系相容后，我们可以在实数集上定义加法运算：</p>


<p>我们可以继续用类似方式定义乘法和其他运算符。总之，实数被定义为柯西序列的商集，而柯西序列本身又是<span class="math">\(\mathbb{N} \rightarrow \mathbb{Q}\)</span>的子类型。</p>


<p>实数定义的替代方案 在mathlib中，实数的构造基本如上所述。部分定义采用更通用的表述方式，以便构建其他代数结构，例如<span class="math">\(p\)</span>-进数。</p>


<p>另一种定义实数的方法是使用戴德金分割。此时，一个数<span class="math">\(r: \mathbb{R}\)</span>被表示为满足<span class="math">\(x&lt;r\)</span>的有理数<span class="math">\(x: \mathbb{Q}\)</span>的集合。另一种不依赖于<span class="math">\(\mathbb{Q}\)</span>的方法，是利用二进制序列<span class="math">\(\mathbb{N} \rightarrow\)</span> Bool来定义<span class="math">\(\mathbb{R}\)</span>。序列中的元素代表该数的各位数字。这种方法在我们仅需要实数区间<span class="math">\([0,1]\)</span>时尤为适用。</p>


<h3>14.3 最终建议</h3>
<p>至此我们已到达本指南的终点。您现已掌握交互式定理证明的基础理论与技术，以及若干应用领域知识。尽管我们使用Lean作为工具，但您所学的知识应能迁移至其他系统，特别是基于简单类型论或依赖类型论的证明辅助工具。此外，您应当具备阅读该领域大多数科研论文的能力。</p>

<p>即便您不选择从事定理证明相关职业，作者仍希望您能随身携带证明辅助工具，并在适当场合使用它们——无论是因其高度可信性，还是因其能便捷地追踪复杂证明目标。</p>
<p>若继续使用Lean，自然的下一步是熟悉mathlib及其文档。在课堂环境之外使用Lean时，您会经常需要查阅定义和定理。您一定会发现#find命令非常实用。<span class="math">\({ }^{1}\)</span> 大多数Lean用户都会使用Lean Zulip聊天平台。<span class="math">\({ }^{2}\)</span></p>
</div>
</body>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // 获取所有标题元素（h1-h6）
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const tocContainer = document.getElementById('toc');
    let tocHTML = '';
    let previousLevel = 0;
    // 遍历所有标题
    headings.forEach((heading, index) => {
        // 获取标题级别（h1=1, h2=2...）
        const level = parseInt(heading.tagName.substring(1));
        
        // 为标题生成唯一ID（如果没有）
        if (!heading.id) {
            heading.id = 'heading-' + index;
        }
        // 处理目录层级
        if (level > previousLevel) {
            // 进入更深层级
            tocHTML += '<ul>';
        } else if (level < previousLevel) {
            // 返回上层级
            const diff = previousLevel - level;
            for (let i = 0; i < diff; i++) {
                tocHTML += '</ul></li>';
            }
        } else {
            // 同级
            tocHTML += '</li>';
        }
        // 添加目录项
        tocHTML += `<li><a href="#${heading.id}">${heading.textContent}</a>`;
        previousLevel = level;
    });
    // 关闭所有未闭合的标签
    for (let i = 0; i < previousLevel; i++) {
        tocHTML += '</li></ul>';
    }
    // 将生成的目录HTML插入到容器中
    tocContainer.innerHTML = tocHTML;
    // 平滑滚动效果
    tocContainer.addEventListener('click', function(e) {
        if (e.target.tagName === 'A') {
            e.preventDefault();
            const targetId = e.target.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
                // 添加高亮效果
                headings.forEach(h => h.style.backgroundColor = '');
                targetElement.style.backgroundColor = '#fff8e1';
                setTimeout(() => {
                    targetElement.style.backgroundColor = '';
                }, 2000);
            }
        }
    });
});
</script>
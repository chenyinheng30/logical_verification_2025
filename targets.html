<!DOCTYPE html>
<html>
<head>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div>
<h1>前言</h1>
<p>形式化证明助手是一种旨在帮助用户执行计算机验证证明的软件。我们通常称它们为证明助手或交互式定理证明器，但一位沮丧的学生创造了“证明阻碍兽”这一说法，而语音识别软件偶尔会将“定理证明器”误解为“恐惧改善器”。请务必注意。</p>
<p>严谨与形式化证明 交互式定理证明有其自身的术语，首先从“证明”这一概念开始。形式化证明是在逻辑形式中表达的逻辑论证。在此上下文中，“形式化”意味着“逻辑的”或“基于逻辑的”。逻辑学家——逻辑的数学家——在计算机出现之前的几十年里就在纸上进行形式化证明，但如今形式化证明几乎总是使用证明助手来完成。</p>
<p>相比之下，非正式证明是数学家通常所说的证明。这些证明通常在<span class="math">\(\mathrm{ET}_{\mathrm{E}} \mathrm{X}\)</span>或黑板上进行，也被称为“纸笔证明”。其详细程度可能差异很大，诸如“显然”、“明显”和“不失一般性”等短语将部分证明负担转移给读者。严谨的证明是非常详细的非正式证明。</p>
<p>证明助手的主要优势在于，它们有助于使用精确的逻辑开发高度可信、无歧义的数学陈述证明。它们可以用来证明任意高级的结果，远远超出玩具示例和逻辑谜题的范围。形式化证明还帮助学生理解什么是有效的定义或有效的证明。引用Scott Aaronson的话：<span class="math">\({ }^{1}\)</span></p>
<p>我仍然记得不得不批改数百份试卷的经历，学生们一开始就假设了需要证明的内容，或者一页接一页地写满胡言乱语，希望在这堆混乱中，他们可能偶然说对了什么。</p>
<p>当我们开发新理论时，形式化证明可以帮助我们探索它。在我们对现有证明进行泛化、重构或其他修改时，它们非常有用，就像编译器帮助我们开发正确的程序一样。它们提供了高度的可信性，使他人更容易进行审查。此外，形式化证明可以构成已验证计算工具（例如，已验证的计算机代数系统）的基础。</p>
<p>成功案例 在数学和计算机科学领域，已有许多证明辅助工具的成功案例。数学形式化中的一些标志性成果包括Gonthier等人证明的四色定理、Gonthier等人证明的奇数阶定理、Hales等人证明的开普勒猜想，以及Buzzard等人定义的完美oid空间。该领域最早的工作由Nicolaas de Bruijn及其同事在20世纪60年代开始，他们在一个名为AUTOMATH的系统中进行。<span class="math">\({ }^{2}\)</span></p>
<p>一些公司，包括AMD和Intel，一直在使用证明助手来验证他们的设计。在学术界，一些里程碑包括操作系统内核seL4和CertiKOS的验证，以及已验证编译器CompCert、JinjaThreads和CakeML的开发。</p>
<p>证明助手 全球有数十种证明助手正在开发或使用中。以下是主要的一些，按它们的逻辑基础分组：</p>
<ul>
<li>集合论：Isabelle/ZF, Metamath, Mizar;</li>
<li>简单类型理论：HOL4, HOL Light, Isabelle/HOL;</li>
<li>依赖类型理论：Agda, Coq, Lean, Matita, PVS;</li>
<li>类Lisp的一阶逻辑：ACL2。</li>
</ul>
<p>关于证明助手和交互式定理证明的历史，我们推荐参考Harrison、Urban和Wiedijk所著的信息丰富的章节。</p>
<p>Lean Lean 是由 Leonardo de Moura（微软研究院）自 2012 年起主要开发的一款证明助手。其数学库 mathlib 最初由 Jeremy Avigad（卡内基梅隆大学）领导开发，但如今由用户社区维护并进一步扩展。<span class="math">\({ }^{3}\)</span></p>
<p>本指南使用Lean版本v4.14.0、mathlib修订版4bbdccd9c5f862bf，以及一些收集在名为LoVelib的小型库中的扩展。<span class="math">\({ }^{4}\)</span> 尽管这是一个研究项目，存在一些粗糙之处，但Lean适合用于教授交互式定理证明的原因有以下几点：</p>
<ul>
<li>它基于依赖类型理论的归纳构造演算，具有高度表达性且非常有趣的逻辑。</li>
<li>它扩展了经典公理和商类型，使其适用于验证数学。</li>
<li>它包含一个方便的元编程框架，可用于编程自定义的证明自动化。</li>
<li>它通过Visual Studio Code插件提供了一个现代化的用户界面。</li>
<li>它拥有高度可读且相当完整的文档。</li>
<li>它是开源的。</li>
</ul>
<p>Lean的核心库仅包含基本的代数定义。更多的定义可以在mathlib中找到。尽管它的名字是mathlib，但它不仅仅是一个数学库；它在Lean的核心库之上提供了大量的基础自动化功能，正如人们所期望的现代证明助手那样。</p>
<p>本指南最初是作为阿姆斯特丹自由大学硕士课程《逻辑验证》（LoVe）的配套材料设计的。其主要目标是教授交互式定理证明。Lean是手段，而非目的本身。因此，本指南并非旨在成为全面的Lean教程——为此，我们推荐《Lean 4中的定理证明》。本指南也不能替代练习和作业。定理证明不适合旁观者；它只能通过实践来学习。</p>
<p>具体来说，目标是让你</p>
<ul>
<li>学习交互式定理证明的基础理论和技术；</li>
<li>学习如何将逻辑作为一种精确的语言来建模系统并陈述其属性；</li>
<li>熟悉一些证明助手成功应用的领域，如函数式编程、命令式编程语言的语义和数学；</li>
<li>培养可以在大型项目中应用的实践技能（无论是个人项目、硕士或博士项目，还是在工业界）；</li>
<li>能够迁移到另一个证明助手并应用所学知识；</li>
<li>对该领域有足够的理解，开始阅读在国际会议上发表的相关科学论文，如Certified Programs and Proofs (CPP)和Interactive Theorem Proving (ITP)，或在期刊如Journal of Automated Reasoning (JAR)上发表的文章。掌握了Lean的良好知识后，应该很容易迁移到基于依赖类型理论的另一个证明助手，如Agda或Coq，或迁移到基于简单类型理论的系统，如HOL4或Isabelle/HOL。</li>
</ul>
<p>本指南的一个重要特点，与Knuth的TgXbook相同，在于它并不总是讲述真相。为了简化阐述，一些关于Lean的基本但错误的说法被提出。这些陈述中的大多数在后续章节中得到了纠正。正如Knuth所言，我们相信“这种故意撒谎的技巧实际上会让你更容易理解这些概念。一旦你理解了一个简单但错误的规则，补充该规则的例外情况将不会太难。”</p>
<p>本指南的配套Lean文件可以在一个公共仓库中找到。<span class="math">\({ }^{5}\)</span> 文件的命名方案遵循本指南的章节；因此，LoVe07_EffectfulProgramming_Demo.lean是与第7章（“Effectful Programming”）相关的主文件，在课堂上进行了复习，LoVe07_EffectfulProgramming_ExerciseSheet.Lean是练习册，LoVe07_EffectfulProgramming_HomeworkSheet.Lean是作业册。</p>
<p>我们非常感谢《Lean 4中的定理证明》和《使用Isabelle/HOL的具体语义》的作者们，他们教会了我们Lean和编程语言语义。本指南中出现了许多他们的思想。</p>
<p>我们感谢Robert Lewis和Assia Mahboubi对本指南的组织和重点提出的宝贵意见。我们感谢Kiran Gopinathan和Ilya Sergey分享了第2章脚注3中报道的轶事，并允许我们进一步分享。我们感谢Daniel Fabian设计了本指南的第一个平板优化版本。我们感谢Paul Chisholm撰写了相关Lean文件中的部分评论。我们感谢Pietro Monticone在Lean和mathlib发展过程中帮助保持Lean文件的更新。我们感谢Mark Summerfield提出的许多文本建议。最后，我们感谢Chris Bailey、Kevin Buzzard、Paul Chisholm、Dominique Danco、Raufs Dunamalijevs、Wan Fokkink、Lina Gerlach、Robert Lewis、Antonius Danny Reyes、Robert Schütz、Kristina Sojakova、Patrick Thomas、Balazs Toth、Huub Vromen、Floris Westerman、Wijnand van Woerkom和Yiming Xu报告了他们在本指南早期版本中发现的拼写错误和一些更严重的错误。如果您在本文中发现了一些错误，请告知我们。<span class="math">\({ }^{6}\)</span></p>
<table>
<thead>
<tr>
  <th style="text-align:center"><span class="math">\(\neg\)</span></th>
  <th style="text-align:center">\not</th>
  <th style="text-align:center"><span class="math">\(\wedge\)</span></th>
  <th style="text-align:center">\and</th>
  <th style="text-align:center"><span class="math">\(\checkmark\)</span></th>
  <th style="text-align:center">\or</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><span class="math">\(\rightarrow\)</span></td>
  <td style="text-align:center">-&gt;</td>
  <td style="text-align:center"><span class="math">\(\leftrightarrow\)</span></td>
  <td style="text-align:center">&lt;-&gt;</td>
  <td style="text-align:center"><span class="math">\(\forall\)</span></td>
  <td style="text-align:center">\fo</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\exists\)</span></td>
  <td style="text-align:center">\ex</td>
  <td style="text-align:center"><span class="math">\(\leq\)</span></td>
  <td style="text-align:center">&lt;=</td>
  <td style="text-align:center"><span class="math">\(\geq\)</span></td>
  <td style="text-align:center">&gt;=</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\neq\)</span></td>
  <td style="text-align:center">\neq</td>
  <td style="text-align:center"><span class="math">\(\approx\)</span></td>
  <td style="text-align:center">\</td>
  <td style="text-align:center"><span class="math">\(\times\)</span></td>
  <td style="text-align:center">\x</td>
</tr>
<tr>
  <td style="text-align:center">○</td>
  <td style="text-align:center">\circ</td>
  <td style="text-align:center"><span class="math">\(\emptyset\)</span></td>
  <td style="text-align:center">\empty</td>
  <td style="text-align:center"><span class="math">\(\cup\)</span></td>
  <td style="text-align:center">\union</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\cap\)</span></td>
  <td style="text-align:center">\intersect</td>
  <td style="text-align:center"><span class="math">\(\in\)</span></td>
  <td style="text-align:center">\in</td>
  <td style="text-align:center">;</td>
  <td style="text-align:center">\downleftharpoon</td>
</tr>
<tr>
  <td style="text-align:center">○</td>
  <td style="text-align:center">\bigcirc</td>
  <td style="text-align:center"><span class="math">\(\leftarrow\)</span></td>
  <td style="text-align:center">&lt;-</td>
  <td style="text-align:center"><span class="math">\(\mapsto\)</span></td>
  <td style="text-align:center">\mapsto</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\Rightarrow\)</span></td>
  <td style="text-align:center">=&gt;</td>
  <td style="text-align:center"><span class="math">\(\Longrightarrow\)</span></td>
  <td style="text-align:center">==&gt;</td>
  <td style="text-align:center"><span class="math">\(\|\)</span></td>
  <td style="text-align:center">
<span class="math">\(\backslash[\)</span> [</td>
</tr>
<tr>
  <td style="text-align:center">]</td>
  <td style="text-align:center">]]</td>
  <td style="text-align:center"><span class="math">\(\alpha\)</span></td>
  <td style="text-align:center">\a</td>
  <td style="text-align:center"><span class="math">\(\beta\)</span></td>
  <td style="text-align:center">\b</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\gamma\)</span></td>
  <td style="text-align:center">\g</td>
  <td style="text-align:center"><span class="math">\(\varepsilon\)</span></td>
  <td style="text-align:center">\e</td>
  <td style="text-align:center"><span class="math">\(\sigma\)</span></td>
  <td style="text-align:center">\s</td>
</tr>
<tr>
  <td style="text-align:center">○</td>
  <td style="text-align:center">\0</td>
  <td style="text-align:center">1</td>
  <td style="text-align:center">\1</td>
  <td style="text-align:center">2</td>
  <td style="text-align:center">\2</td>
</tr>
<tr>
  <td style="text-align:center">3</td>
  <td style="text-align:center">\3</td>
  <td style="text-align:center">4</td>
  <td style="text-align:center">\4</td>
  <td style="text-align:center">5</td>
  <td style="text-align:center">\5</td>
</tr>
<tr>
  <td style="text-align:center">6</td>
  <td style="text-align:center">\6</td>
  <td style="text-align:center">7</td>
  <td style="text-align:center">\7</td>
  <td style="text-align:center">8</td>
  <td style="text-align:center">\8</td>
</tr>
<tr>
  <td style="text-align:center">9</td>
  <td style="text-align:center">\9</td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>特殊符号 在本指南中，我们假设您将使用 Visual Studio Code 及其 "lean4" 扩展来编辑 .lean 文件。Visual Studio Code 允许您通过输入反斜杠 <span class="math">\(\backslash\)</span> 后跟一个 ASCII 标识符来输入 Unicode 符号。例如，<span class="math">\(\rightarrow, \forall\)</span> 或 <span class="math">\(\in\)</span> 可以通过输入 <span class="math">\(\backslash-&gt;\)</span>、<span class="math">\(\backslash\)</span> fo 或 <span class="math">\(\backslash\)</span> in 并按下 Tab 键或空格键来输入。我们将自由使用这些符号。为了方便参考，我们提供了本指南中使用的主要非 ASCII 符号列表，并为每个符号提供了其 ASCII 表示之一。在 Visual Studio Code 中，按住控制键或命令键并将鼠标悬停在符号上时，您将看到可以输入该符号的不同方式。</p>
<h1>第一部分：基础</h1>
<h2>第一章：类型与项</h2>
<p>我们通过研究Lean的基础知识开始我们的旅程，从项（也称为表达式）及其类型开始。</p>
<p>Lean的逻辑基础是一种称为归纳构造演算的丰富逻辑，它支持依赖类型。Lean的逻辑受到<span class="math">\(\lambda\)</span>演算的启发，并且类似于类型化的函数式编程语言，如Haskell、OCaml和Standard ML。即使你没有使用过这些语言，你也会从现代语言（如C++、Java、Python）中识别出许多概念。粗略地讲：</p>
<pre><code>fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
</code></pre>
<p>Lean <span class="math">\(=\)</span> 函数式编程 + 逻辑
如果你的背景是数学，你可能已经了解了函数式编程的大部分关键概念，尽管有时这些概念的名称不同。例如，Haskell 程序</p>
<div class="math">$$
f i b(n)= \begin{cases}0 &amp; \text { if } n=0 \\ 1 &amp; \text { if } n=1 \\ f i b(n-2)+f i b(n-1) &amp; \text { if } n \geq 2\end{cases}
$$</div>
<p>与数学定义紧密对应</p>
<p>在本章中，我们将注意力限制在Lean的一个片段上，该片段不包含依赖类型，称为简单类型理论（或高阶逻辑）。这大致对应于扩展了等式运算符（=）的简单类型<span class="math">\(\lambda\)</span>-演算。它是一个抽象的、极度简化的编程语言版本，具有函数调用机制，预示着函数式编程。</p>
<h3>1.1 类型</h3>
<p>类型可以是基本类型，如<span class="math">\(\mathbb{Z}, \mathbb{Q}\)</span>和Bool，也可以是全函数<span class="math">\(\sigma \rightarrow \tau\)</span>，其中<span class="math">\(\sigma\)</span>和<span class="math">\(\tau\)</span>本身也是类型。类型指示表达式可能计算出的值。它们引入了一种在数学中隐含遵循的规范。原则上，没有任何东西阻止数学家声明<span class="math">\(1 \in 2\)</span>，但类型规范会将其标记为可能的错误。从语义上讲，类型可以被视为集合。我们通常会定义类型<span class="math">\(\mathbb{Z}, \mathbb{Q}\)</span>和Bool，以便它们忠实地捕捉数学家的<span class="math">\(\mathbb{Z}\)</span>和<span class="math">\(\mathbb{Q}\)</span>以及计算机科学家的布尔值，函数箭头<span class="math">\((\rightarrow)\)</span>也是如此。但尽管有相似之处，Lean和数学是两种不同的语言。Lean的类型可以被解释为集合，但它们并不是集合。</p>
<p>高阶类型是包含嵌套在<span class="math">\(\rightarrow\)</span>左侧的<span class="math">\(\rightarrow\)</span>箭头的类型，例如类型<span class="math">\((\mathbb{Z} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Q}\)</span>。此类类型的值是接受其他函数作为参数的函数。因此，<span class="math">\((\mathbb{Z} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Q}\)</span>是一元函数的类型，它接受一个类型为<span class="math">\(\mathbb{Z} \rightarrow \mathbb{Z}\)</span>的函数作为参数，并返回一个类型为<span class="math">\(\mathbb{Q}\)</span>的值。</p>

<h3>1.2 项</h3>
<p>简单类型论中的项或表达式包括</p>
<ul>
<li>常量 c；</li>
<li>变量 <span class="math">\(x\)</span>；</li>
<li>应用 t u；</li>
<li>匿名函数 fun <span class="math">\(x \mapsto t\)</span>（也称为 <span class="math">\(\lambda\)</span>-表达式）。</li>
</ul>

<p>在上文中，<span class="math">\(t\)</span> 和 <span class="math">\(u\)</span> 表示任意项。我们也可以写作 <span class="math">\(t: \sigma\)</span>，以表示项 <span class="math">\(t\)</span> 具有类型 <span class="math">\(\sigma\)</span>。</p>

<p>让我们回顾每种类型的项：</p>
<ul>
<li>常量 <span class="math">\(c: \sigma\)</span> 是一个类型为 <span class="math">\(\sigma\)</span> 的符号，其含义在当前全局上下文中是固定的。例如，算术理论可能包含常量，如 <span class="math">\(\theta: \mathbb{Z}, 1: \mathbb{Z}\)</span>，abs <span class="math">\(: \mathbb{Z} \rightarrow \mathbb{N}\)</span>，square <span class="math">\(: \mathbb{N} \rightarrow \mathbb{N}\)</span>，以及 prime <span class="math">\(: \mathbb{N} \rightarrow\)</span> Bool。常量包括函数（例如，abs）和谓词（例如，prime）。</li>
<li>变量 <span class="math">\(x: \sigma\)</span> 可以是绑定的或自由的。绑定变量指回匿名函数 fun <span class="math">\(x: \sigma \mapsto t\)</span> 的输入 <span class="math">\(x\)</span>，该函数将其包围。相比之下，自由变量在局部上下文中声明——这一概念将在下面解释。</li>
<li>应用 <span class="math">\(t u\)</span>，其中 <span class="math">\(t: \sigma \rightarrow \tau\)</span> 且 <span class="math">\(u: \sigma\)</span>，是一个类型为 <span class="math">\(\tau\)</span> 的项，表示将函数 <span class="math">\(t\)</span> 应用于参数 <span class="math">\(u\)</span> 的结果。例如，如果 <span class="math">\(t\)</span> 是 abs 且 <span class="math">\(u\)</span> 是 <span class="math">\(\theta\)</span>，那么应用就是 abs <span class="math">\(\theta\)</span>。除非参数是复杂项，否则不需要在参数周围加括号——例如，prime (abs <span class="math">\(\theta\)</span> )。</li>
<li>给定一个项 <span class="math">\(t: \tau\)</span>，匿名函数 fun <span class="math">\(x: \sigma \mapsto t\)</span> 表示类型为 <span class="math">\(\sigma \rightarrow \tau\)</span> 的总函数，该函数将每个类型为 <span class="math">\(\sigma\)</span> 的输入值 <span class="math">\(x\)</span> 映射到主体 <span class="math">\(t\)</span>，其中 <span class="math">\(x\)</span> 可能出现在 <span class="math">\(t\)</span> 中。因此，fun <span class="math">\(x: \mathbb{Z} \mapsto\)</span> square (abs <span class="math">\(x\)</span> ) 表示将（由 <span class="math">\(\theta\)</span> 表示的值）映射到（由 square (abs <span class="math">\(\theta\)</span> ) 表示的值），将 1 映射到 square (abs 1 )，依此类推。变量 <span class="math">\(x\)</span> 被称为由 fun 绑定。因此，fun 被称为绑定器。对于数学家来说，更熟悉的语法可能是 <span class="math">\(x \mapsto\)</span> square (abs <span class="math">\(x\)</span> )，而不带 fun 关键字。</li>
</ul>

<p>常量与变量在语法上看起来相似，但它们被视为不同的概念。常量是在全局声明的，而变量则通过fun或其他绑定器在局部引入。</p>
<div class="math">$$
\begin{aligned}
&amp; (\text { fun } n: \mathbb{N} \mapsto n) 4 \text { yields } 4 \\
&amp; \text { (fun } n: \mathbb{N} \mapsto \text { square (square } n \text { ) }) 5 \text { yields square (square 5) } \\
&amp; \text { (fun } y: \mathbb{Z} \mapsto 1) \theta \text { yields } 1 \\
&amp; (\text { fun } x: \mathbb{Z} \mapsto(\text { fun } y: \mathbb{Z} \mapsto x)) 1 \text { yields fun } y: \mathbb{Z} \mapsto 1
\end{aligned}
$$</div>
<p>应用和匿名函数相互对应：匿名函数“构造”一个函数；应用“解构”一个函数。如果我们将两者结合起来会发生什么？如果我们将类型为<span class="math">\(\sigma\)</span>的参数<span class="math">\(u\)</span>应用于匿名函数 fun <span class="math">\(x: \sigma \mapsto t[x]\)</span>，其中<span class="math">\(t[x]\)</span>表示可能包含<span class="math">\(x\)</span>的某个项，那么我们将得到项<span class="math">\(t[u]\)</span>。（这是一个稍微简化的视图。实际上，如果<span class="math">\(t[x]\)</span>包含一些绑定器，可能需要重命名绑定变量以避免捕获u的自由变量。在Lean中，这种重命名是自动进行的。）以下是应用匿名函数的几个示例：</p>

<p>虽然我们的函数是一元的（即它们接受一个参数），但我们可以通过嵌套 fun 来构建多元函数，使用一种称为柯里化的巧妙技术。例如，fun <span class="math">\(x: \sigma \mapsto\)</span> (fun <span class="math">\(y: \tau \mapsto x\)</span> ) 表示类型为 <span class="math">\(\sigma \rightarrow(\tau \rightarrow \sigma)\)</span> 的函数，它接受两个参数并返回第一个参数。严格来说，<span class="math">\(\sigma \rightarrow(\tau \rightarrow \sigma)\)</span> 接受一个参数并返回一个函数，该函数又接受一个参数。</p>

<p>应用的工作方式相同：如果<span class="math">\(\mathrm{K}:=(\)</span> fun <span class="math">\(x: \mathbb{Z} \mapsto(\)</span> fun <span class="math">\(y: \mathbb{Z} \mapsto x))\)</span>，那么<span class="math">\(K_{1}=(\)</span> fun <span class="math">\(y: \mathbb{Z} \mapsto 1)\)</span> 且 <span class="math">\((K 1) \theta=1\)</span>。函数<span class="math">\(K\)</span>在<span class="math">\(K 1\)</span>中，应用于单个参数时，被称为部分应用，因为它可以接受额外的参数。</p>
<div class="math">$$
\begin{aligned}
\sigma \rightarrow \tau \rightarrow v \text { for } &amp; \sigma \rightarrow(\tau \rightarrow v) \\
t u v \text { for } &amp; (t u) v \\
\text { fun } x: \sigma \mapsto \text { fun } y: \tau \mapsto t \text { for } &amp; \text { fun } x: \sigma \mapsto(\text { fun } y: \tau \mapsto t)
\end{aligned}
$$</div>
<p>柯里化是一个非常有用的概念，因此我们将省略大多数括号，写作</p>
<div class="math">$$
\begin{aligned}
&amp; \text { fun }(x: \sigma)(y: \tau) \mapsto t \text { for fun } x: \sigma \mapsto \text { fun } y: \tau \mapsto t \\
&amp; \text { fun } x y: \sigma \mapsto t \text { for fun }(x: \sigma)(y: \sigma) \mapsto t
\end{aligned}
$$</div>
<p>我们也将使用这些缩写：</p>
<div class="math">$$
\text { fun } x \mapsto t \text { for fun } x: \sigma \mapsto t
$$</div>
<p>此外，在匿名函数fun <span class="math">\(x: \sigma \mapsto t\)</span>中，我们通常可以省略类型标注: <span class="math">\(\sigma\)</span>，写作</p>
<p>Lean 随后会尝试根据函数体 <span class="math">\(t\)</span> 和匿名函数周围的上下文推断类型。类型推断简化了符号并节省了一些按键操作。</p>
<p>在数学中，通常以中缀语法书写二元运算符（例如，<span class="math">\(x+y\)</span>）。这种表示法在Lean中也是可能的，作为柯里化函数应用的语法糖（例如，add <span class="math">\(x y\)</span>）。</p>
<pre><code>opaque a : \(\mathbb{Z}\)
opaque b : \(\mathbb{Z}\)
opaque \(f: \mathbb{Z} \rightarrow \mathbb{Z}\)
opaque g : \(\mathbb{Z} \rightarrow \mathbb{Z} \rightarrow \mathbb{Z}\)
#check fun \(x: \mathbb{Z} \mapsto g(f(g a x))(g x b)\)
#check fun \(x \mapsto g(f(g a x))(g x b)\)
</code></pre>
<p>使用Lean的一种方式是通过opaque命令声明我们所需的类型和常量。考虑以下声明：</p>
<p>前四行声明了四个常量（<span class="math">\(a, b, f, g\)</span>），它们可用于构成项。最后两行使用#check命令对项进行类型检查并显示其类型。使用传统的数学符号，最后一行中的项可以写为<span class="math">\(x \mapsto g(f(g(a, x)), g(x, b))\)</span>。#前缀标识了诊断命令：这些命令对调试很有用，但我们通常不会将其保留在Lean文件中。</p>
<h3>1.3 类型检查与类型推断</h3>
<p>当 Lean 解析一个项时，它会检查该项是否类型良好。在此过程中，如果省略了绑定变量的类型，它会尝试推断这些变量的类型——例如，在 fun <span class="math">\(x \mapsto\)</span> square (square <span class="math">\(x\)</span> ) 中 <span class="math">\(x\)</span> 的类型。</p>
<p>对于简单类型理论，类型检查和类型推断是可判定问题。高级特性如重载（可以为多个常量重用相同名称，例如<span class="math">\(\theta: \mathbb{N}\)</span>和<span class="math">\(\theta: \mathbb{R}\)</span>）可能导致不可判定性。Lean采取了一种务实的、面向计算机科学的方法，并假设当多种类型可能时，数字<span class="math">\(\theta, 1,2, \ldots\)</span>的类型为<span class="math">\(\mathbb{N}\)</span>。</p>
<p>Lean的类型系统可以表示为一个形式系统。一个形式系统由判断和用于生成判断的推导规则组成。一个类型判断的形式为<span class="math">\(C \vdash t: \sigma\)</span>，表示在局部上下文C中，项<span class="math">\(t\)</span>具有类型<span class="math">\(\sigma\)</span>。例如，判断<span class="math">\(\vdash\)</span> abs <span class="math">\(: \mathbb{Z} \rightarrow \mathbb{N}\)</span>表示在空的局部上下文中，常量abs具有类型<span class="math">\(\mathbb{Z} \rightarrow \mathbb{N}\)</span>。</p>

<p>局部上下文给出了<span class="math">\(t\)</span>中未被fun绑定的变量的类型。它用于跟踪<span class="math">\(t\)</span>外部的绑定器所绑定的变量。如果同一个变量<span class="math">\(x\)</span>被多次绑定，最后一次出现会遮蔽之前的绑定。例如，判断<span class="math">\(x: \mathbb{Z}, y: \mathbb{N}, y: \mathbb{Z} \vdash y: \mathbb{Z}\)</span>表示在局部上下文<span class="math">\(x: \mathbb{Z}, y: \mathbb{N}, y: \mathbb{Z}\)</span>中，变量<span class="math">\(y\)</span>的类型为<span class="math">\(\mathbb{Z}\)</span>。</p>

<p>对于简单类型理论，类型判断由四条类型规则生成，每条规则对应一种项：</p>
<p><img src="img-0.jpeg" alt="img-0.jpeg"></p>
<p>每条规则都有零个或多个前提（在水平线上方）、一个结论（在水平线下方），以及可能存在的侧边条件（在右侧）。前提是类型判断，而侧边条件则是规则中出现的数学变量的任意数学条件。为了展示前提，我们需要继续向上进行推导，稍后将会看到。至于侧边条件，我们可以使用数学的全部工具来证明它们的正确性。</p>
<p>前两条规则，标记为Cst和VAR，没有前提条件，但它们有必须满足的侧条件才能使规则适用。最后两条规则以一个或两个判断作为前提，并生成一个新的判断。FUN是唯一修改局部上下文的规则：当我们进入匿名函数的主体<span class="math">\(t\)</span>时，我们需要记录绑定变量<span class="math">\(x\)</span>的存在及其类型，以便在<span class="math">\(t\)</span>中遇到<span class="math">\(x\)</span>时做好准备。</p>
<p>我们可以使用这个规则系统，通过逆向（即向上）工作并应用这些规则，来证明给定项是良类型的，从而构建一个类型判断的形式推导。与自然树类似，推导树的根部在底部。推导出的判断出现在根部，每个分支都以无前提规则的应用结束。规则应用通过水平线和标签表示。以下类型推导确立了在任意局部上下文C中，项fun <span class="math">\(x: \mathbb{Z} \mapsto\)</span> abs <span class="math">\(x\)</span>具有类型<span class="math">\(\mathbb{Z} \rightarrow \mathbb{N}\)</span>：</p>
<p><img src="img-1.jpeg" alt="img-1.jpeg"></p>
<p>从根部向上阅读证明时，注意局部上下文是如何被贯穿的，以及它如何通过FUN规则进行扩展。该规则将fun绑定的变量移动到局部上下文中，使得在树的更高处应用VAR成为可能。如果变量<span class="math">\(x\)</span>已经在C中声明，那么在进入fun表达式后，它将被<span class="math">\(x: \mathbb{Z}\)</span>所遮蔽。</p>
<p>总之，类型系统由推导规则组成，这些规则可以（1）用其数学变量的任意值实例化，并且（2）连接起来形成推导树。</p>

<p>这是第二个示例，这次从一个空的本地上下文开始：</p>

<p><img src="img-2.jpeg" alt="img-2.jpeg"></p>
<p>到目前为止的两个例子都是类型良好的。如果我们从一个类型错误的项开始，或者在推导树根部的判断中指定了错误的类型或上下文，我们将发现无法完成推导。推导构成了一个证明，证明一个项在给定的上下文中是类型良好的，并且具有指定的类型。</p>
<p>上述类型系统仅检查项是否良类型。它不检查类型是否良构。例如，给定一元类型构造器List，List <span class="math">\(\mathbb{Z}\)</span>（整数列表的类型）是良构的，而<span class="math">\(\mathbb{Z}\)</span> List和List List则是非良构的。对于简单类型理论，良构性很容易检查：只应使用已声明的类型构造器，并且每个<span class="math">\(n\)</span>元类型构造器应恰好传递<span class="math">\(n\)</span>个类型参数。</p>
<h3>1.4 类型居住</h3>
<p>给定一个类型 <span class="math">\(\sigma\)</span>，类型居住问题在于在空的局部上下文中找到该类型的“居住者”——即类型为 <span class="math">\(\sigma\)</span> 的项。这看似是一个无意义的练习，但正如我们将在第4章中看到的，这个问题与寻找命题的证明密切相关。形式为“找到一个类型为 <span class="math">\(\sigma\)</span> 的项”的看似愚蠢的练习，是掌握定理证明的良好实践。</p>
<p>尽管这个问题在一般情况下是不可判定的，但通过正确的策略，我们可以取得很大进展。要创建一个给定类型的项，首先使用占位符 _，然后递归地应用以下两个步骤的组合：</p>
<ol>
<li>如果类型是<span class="math">\(\sigma \rightarrow \tau\)</span>的形式，一个可能的居民是一个匿名函数，形式为fun <span class="math">\(x: \sigma \mapsto-\)</span>，其中 _ 是类型为<span class="math">\(\tau\)</span>的缺失项的占位符。Lean会将 _ 标记为错误；如果你在Visual Studio Code中悬停其上，工具提示将显示缺失项的类型以及局部上下文中声明的任何变量。</li>
<li>给定一个类型<span class="math">\(\sigma\)</span>（可能是函数类型），你可以使用任何类型为<span class="math">\(\tau_{1} \rightarrow \cdots \rightarrow \tau_{n} \rightarrow \sigma\)</span>的常量c或变量<span class="math">\(x\)</span>来构建一个类型为<span class="math">\(\sigma\)</span>的项。对于每个参数，你需要放置一个占位符，生成c _ . . 或<span class="math">\(x_{-} \ldots\)</span>. . 可以使用相同的策略递归地消除占位符。</li>
</ol>
<div class="math">$$
(\alpha \rightarrow \beta \rightarrow \gamma) \rightarrow((\beta \rightarrow \alpha) \rightarrow \beta) \rightarrow \alpha \rightarrow \gamma
$$</div>
<p>作为示例，我们将应用该策略来找到一个类型为</p>
<div class="math">$$
\sigma:=\alpha \rightarrow \beta \rightarrow \gamma \text { and } \tau:=\left((\beta \rightarrow \alpha) \rightarrow \beta\right) \rightarrow \alpha \rightarrow \gamma
$$</div>
<p>最初，只有步骤1适用，且</p>
<p>（回想一下，<span class="math">\(\rightarrow\)</span> 是右结合的。）这导致了项 fun <span class="math">\(f \mapsto-\)</span>，它具有正确的类型，但留下了一个占位符。由于参数 <span class="math">\(f\)</span> 的类型是 <span class="math">\(\sigma\)</span>，即一个函数类型，使用名称 <span class="math">\(f\)</span> 来表示它是有意义的。然后我们递归地处理类型为 <span class="math">\(\tau\)</span> 的占位符。同样，只有步骤1是可能的，因此我们最终得到项 fun <span class="math">\(\mathrm{f} g \mapsto-\)</span>，其中 <span class="math">\(g\)</span> 的类型是 <span class="math">\((\beta \rightarrow \alpha) \rightarrow \beta\)</span>，而占位符的类型是 <span class="math">\(\alpha \rightarrow \gamma\)</span>。第三次应用步骤1得到 fun <span class="math">\(f g\)</span> a <span class="math">\(\mapsto-\)</span>，其中 a 的类型是 <span class="math">\(\alpha\)</span>，而占位符的类型是 <span class="math">\(\gamma\)</span>。</p>
<div class="math">$$
\mathrm{f}: \alpha \rightarrow \beta \rightarrow \gamma, \mathrm{~g}:(\beta \rightarrow \alpha) \rightarrow \beta, \mathrm{a}: \alpha
$$</div>

<p>此时，步骤1不再适用。让我们看看步骤2是否可行。占位符周围的上下文包含以下变量：</p>

<p>回想一下，我们正在尝试构建一个类型为<span class="math">\(\gamma\)</span>的项。我们可以用来实现这一目标的唯一变量是<span class="math">\(f\)</span>：它接受两个参数并返回一个类型为<span class="math">\(\gamma\)</span>的值。因此，我们将占位符替换为项<span class="math">\(f_{-}\)</span>，其中两个新的占位符代表两个缺失的参数。将所有内容放在一起，我们现在得到的项是fun <span class="math">\(\mathrm{f} g \mathrm{a} \mapsto \mathrm{f}_{\text {_ }}\)</span>。</p>
<p>根据f的类型，占位符的类型分别为<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>。第一个占位符很容易填充，再次使用步骤2，只需提供一个类型为<span class="math">\(\alpha\)</span>的a，无需参数。对于第二个占位符，我们应用步骤2并使用变量<span class="math">\(g\)</span>，它是<span class="math">\(\beta \mathrm{s}\)</span>的唯一来源。由于<span class="math">\(g\)</span>需要一个参数，我们必须提供一个占位符。这意味着我们当前的项是fun <span class="math">\(\mathrm{f} g \mathrm{a} \mapsto \mathrm{f} \mathrm{a}\left(\mathrm{g}_{-}\right)\)</span>。</p>
<p>我们几乎完成了。剩下的唯一占位符类型为<span class="math">\(\beta \rightarrow \alpha\)</span>，这是g的参数类型。应用步骤1，我们将占位符替换为fun b <span class="math">\(\mapsto-\)</span>，其中_的类型为<span class="math">\(\alpha\)</span>。在这里，我们可以简单地提供a。我们的最终项是fun <span class="math">\(\mathrm{f} g \mathrm{a} \mapsto \mathrm{f} \mathrm{a}(\mathrm{g}\)</span> (fun b <span class="math">\(\mapsto\)</span> a))。</p>
<p>上述推导过程虽然繁琐但却是确定性的：在每一步中，要么适用步骤1，要么适用步骤2，但不会同时适用。一般情况下，这并不总是如此。</p>

<p>对于其他一些类型，我们可能会遇到死胡同，需要回溯。我们也可能完全失败，没有回溯的余地。</p>

<p>关键思想是术语应始终保持语法正确。在Visual Studio Code中，我们唯一应该看到的红色下划线应出现在占位符下方。总的来说，软件开发的一个良好原则是从一个可编译的程序开始，进行尽可能小的更改以获得一个新的可编译程序，并重复此过程直到程序完成。</p>
<h3>1.5 新引入的Lean结构总结</h3>
<p>在本章及大多数其他章节的末尾，我们都会简要总结本章中引入的结构。某些语法具有多重含义，这些含义将逐步介绍。有关详细信息，请参阅《Lean 4手册》、Lean 4教程中的定理证明以及mathlib文档<span class="math">\({ }^{1}\)</span>。</p>
<h4>诊断命令</h4>
<p>#check 检查并打印项的类型</p>

<h4>声明</h4>
<p>opaque声明一个未指定的新常量或类型</p>

<h2>第二章：程序与定理</h2>
<p>我们继续学习Lean的基础知识，重点放在程序和定理上，但暂时不进行任何证明。特别是，我们回顾如何定义新类型和函数，以及如何将它们的预期性质表述为定理。</p>
<h3>2.1 类型定义</h3>
<p>Lean的归纳构造演算的一个显著特点是其对归纳类型的内置支持。归纳类型是一种通过应用称为构造函数的特殊常量来构建值的类型。归纳类型是程序中表示无环数据的一种简洁方式。你可能在其他名称下了解它们，这些名称在很大程度上是同义的，包括代数数据类型、归纳数据类型、自由生成数据类型、递归数据类型和数据类型。</p>
<pre><code>inductive Nat : Type where
    | zero : Nat
    | succ : Nat -&gt; Nat
</code></pre>
<h3>2.1.1 自然数的定义</h3>
<p>归纳类型的“Hello, World!”示例是自然数类型Nat（<span class="math">\(\mathbb{N}\)</span>）。在Lean中，它可以定义如下：</p>
<p>第一行向世界宣布我们正在引入一个名为Nat的新类型，旨在表示自然数。第二行和第三行声明了两个新的构造器，Nat.zero : Nat 和 Nat.succ : Nat <span class="math">\(\rightarrow\)</span> Nat，它们可用于构建Nat类型的值。遵循计算机科学和逻辑学中的既定惯例，计数从零开始。第二个构造器使得这个归纳定义变得有趣——它需要一个Nat类型的参数来生成一个Nat类型的值。这些项</p>
<p>Nat. zero&lt;br&gt;Nat.succ Nat. zero&lt;br&gt;Nat.succ (Nat.succ Nat. zero)&lt;br&gt;<span class="math">\(\vdots\)</span>表示类型Nat的不同值——零、它的后继、它的后继的后继，以此类推。这种表示法被称为一元表示法或皮亚诺表示法，以逻辑学家朱塞佩·皮亚诺的名字命名。关于Lean中皮亚诺数的另一种解释（以及一些令人惊叹的视频游戏图形），请参阅Kevin Buzzard的文章《计算机能证明定理吗？》1</p>
<pre><code>inductive type-name (params 1 : type 1) ... (params k : type k) : Type
    where
    | constructor-name : constructor-type
        \vdots
    | constructor-name : constructor-type
</code></pre>
<p>类型声明的一般格式为</p>
<p>对于自然数，可以让Lean使用熟悉的名称<span class="math">\(\theta\)</span>、<span class="math">\(1,2, \ldots\)</span>，事实上预定义的<span class="math">\(\mathbb{N}\)</span>类型提供了这样的语法糖。但使用更长的符号更能揭示Lean的类型定义。</p>
<p>在本章附带的Lean文件中，Nat的定义位于一个命名空间内，由namespace MyNat和end MyNat限定，以将其作用范围限制在文件的一部分。在end MyNat之后，任何出现的Nat、Nat.zero或Nat.succ都将引用Lean预定义的自然数类型。同样，整个文件被放入LoVe命名空间，以防止与现有Lean库中的名称冲突。</p>
<pre><code>inductive LoVe.MyNat.Nat : Type
number of parameters: 0
constructors:
LoVe.MyNat.Nat.zero : Nat
LoVe.MyNat.Nat.succ : Nat \(\rightarrow\) Nat
</code></pre>
<p>我们可以在Lean中的任意时刻使用#print命令来检查之前的定义。例如，在MyNat命名空间中使用#print Nat会显示以下信息：</p>
<p>对自然数的关注是本指南中许多偏向计算机科学的特点之一。数论学家可能更感兴趣的是整数<span class="math">\(\mathbb{Z}\)</span>和有理数<span class="math">\(\mathbb{Q}\)</span>；分析学家则希望研究实数<span class="math">\(\mathbb{R}\)</span>和复数<span class="math">\(\mathbb{C}\)</span>。然而，自然数在计算机科学中无处不在，并且作为一种归纳类型具有非常简单的定义。它们还可以用于构建其他类型，正如我们将在第12章中看到的那样。</p>
<pre><code>inductive AExp : Type where
    | num : \(\mathbb{Z} \rightarrow\) AExp
    | var : String \(\rightarrow\) AExp
    | add : AExp \(\rightarrow\) AExp \(\rightarrow\) AExp
    | sub : AExp \(\rightarrow\) AExp \(\rightarrow\) AExp
    | mul : AExp \(\rightarrow\) AExp \(\rightarrow\) AExp
    | div : AExp \(\rightarrow\) AExp \(\rightarrow\) AExp
</code></pre>
<h4>2.1.2 算术表达式的定义</h4>
<p>我们的下一个例子使用了整数。如果我们要指定一个计算器程序或一种编程语言，我们可能需要定义一个类型来表示作为抽象语法树的算术表达式。这个例子展示了如何在 Lean 中实现这一点：</p>
<p>从数学上讲，这个定义等价于通过以下形成规则归纳地定义类型AExp：</p>
<ol>
<li>对于每个整数<span class="math">\(i\)</span>，项AExp.num <span class="math">\(i\)</span>是一个AExp值。（直观上，构造函数AExp.num将一个整数“装箱”为算术表达式。）</li>
<li>对于每个字符串<span class="math">\(x\)</span>，项AExp.var <span class="math">\(x\)</span>是一个AExp值。</li>
<li>如果<span class="math">\(e_{1}\)</span>和<span class="math">\(e_{2}\)</span>是AExp值，那么AExp.add <span class="math">\(e_{1} e_{2}\)</span>、AExp.sub <span class="math">\(e_{1} e_{2}\)</span>、AExp.mul <span class="math">\(e_{1} e_{2}\)</span>和AExp.div <span class="math">\(e_{1} e_{2}\)</span>也是AExp值。上述定义是完备的。AExp的唯一可能值是那些使用形成规则1到3构建的值。此外，使用不同形成规则构建的AExp值是相互区分的。归纳类型的这两个性质被Joseph Goguen的格言“无冗余，无混淆”所概括。</li>
</ol>
<pre><code>public interface AExp { }
public class Num implements AExp {
    public int num;
    public Num(int num) { this.num = num; }
}
public class Var implements AExp {
    public String var;
    public Var(String var) { this.var = var; }
}
public class Add implements AExp {
    public AExp left;
    public AExp right;
    public Add(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
public class Sub implements AExp {
    public AExp left;
    public AExp right;
    public Sub(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
public class Mul implements AExp {
    public AExp left;

    public AExp right;
    public Mul(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
public class Div implements AExp {
    public AExp left;
    public AExp right;
    public Div(AExp left, AExp right)
    { this.left = left; this.right = right; }
}
</code></pre>
<p>将上述简洁的Lean规范与实现相同功能的Java程序进行比较可能会有所启发。该程序由一个接口和六个实现该接口的类组成，分别对应AExp类型及其六个构造函数：</p>
<pre><code>class AExp:
    pass
class Num(AExp):
    def __init__(self, num):
        self.num = num
class Var(AExp):
    def __init__(self, var):
        self.var = var
class Add(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
class Sub(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
class Mul(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
class Div(AExp):
    def __init__(self, left, right):
        self.left = left
        self.right = right
</code></pre>
<p>在Python中，类的声明如下：</p>
<pre><code>inductive List ( \(\alpha\) : Type) where
    | nil : List \(\alpha\)
    | cons : \(\alpha \rightarrow\) List \(\alpha \rightarrow\) List \(\alpha\)
</code></pre>

<h4>2.1.3 列表的定义</h4>
<p>接下来我们考虑的类型是有限列表：</p>

<p>该类型是多态的：它由一个类型<span class="math">\(\alpha\)</span>参数化，我们可以用具体类型来实例化它。例如，List <span class="math">\(\mathbb{Z}\)</span>是整数列表的类型，而List (List <span class="math">\(\mathbb{R}\)</span>)是实数列表的列表的类型。类型构造器List接受一个类型作为参数并返回一个类型。与Java中的泛型和C++中的模板类似，多态是一种提供参数化类型的机制。</p>
<pre><code>#check List.nil
#check List.cons
</code></pre>

<p>以下命令显示构造函数的类型：</p>

<pre><code>List.nil : List ?m. 2396
List.cons : ?m. }2397\mathrm{ -&gt; List ?m.2397 -&gt; List ?m.2397
</code></pre>
<p>输出看起来与我们预期的有所不同：</p>
<p>即使我们试图将自己限制在Lean语言的某个片段中，Lean也经常在输出中暴露出更高级的构造，例如上面的?m. 2396和?m. 2397。我们的建议是采取一种积极的态度：如果你第一次没有完全理解所有内容，不要担心。运用你的常识和想象力。最重要的是，不要犹豫，随时提问。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { [] for List.nil } \\
&amp; \mathrm{x}:: \mathrm{xs} \text { for List.cons x xs } \\
&amp; {\left[\mathrm{x}_{1}, \ldots, \mathrm{x}_{n}\right]} \text { for } \mathrm{x}_{1}:: \ldots:: \mathrm{x}_{n}::[] \text { }
\end{aligned}
$$</div>

<p>Lean 的内置列表为编写列表提供了语法糖。</p>

<p>:: 操作符与所有其他二元操作符一样，其绑定强度低于函数应用。因此，<span class="math">\(f x\)</span> :: List.reverse ys 被解析为 (<span class="math">\(f x\)</span>) :: (List.reverse ys)。避免不必要的括号是一种良好的实践，它们会迅速降低可读性。此外，在中缀操作符周围添加空格以提示正确的优先级也很重要。</p>
<p>函数式程序员通常使用诸如<span class="math">\(x \mathrm{~s}, \mathrm{ys}, \mathrm{zs}\)</span>这样的名称来表示列表，尽管在Lean中1也很常见。列表包含多个元素，因此使用复数形式是很自然的。一个猫的列表可能被称为cats；一个猫列表的列表可能被称为catss。当一个非空列表被表示为头部和尾部时，我们通常会写成<span class="math">\(x\)</span> : : xs或cat : : cats。</p>
<h3>2.2 函数定义</h3>
<p>如果我们只想声明一个函数，可以使用不透明命令（第1.2节）。但通常，我们希望定义函数的行为，为此可以使用def命令。由于Lean的根基在于函数式编程，函数被定义为求值为一个值的数学表达式，而不是修改某些状态的命令式程序。因此，递归，而不是使用while或for的迭代，是遍历数据的主要机制。</p>
<pre><code>def fib : \(\mathbb{N} \rightarrow \mathbb{N}\)
    | 0 =&gt; 0
    | 1 =&gt; 1
    | \(n+2=&gt;\) fib \((n+1)+\) fib \(n\)
</code></pre>
<h3>2.2.1 自然数上的递归</h3>
<p>让我们通过一个简单的例子来看看递归是如何工作的。Lean 中斐波那契数列的定义如下：</p>
<p>左侧的模式对应于函数的参数。这里，<span class="math">\(f i b\)</span>被声明为具有一个类型为<span class="math">\(\mathbb{N}\)</span>的参数，因此我们在一个自然数上进行模式匹配。当输入具有给定形式时，模式会被触发。例如，如果输入是1，那么模式1与之匹配，并评估相应的右侧表达式。如果输入是5，那么模式<span class="math">\(n+2\)</span>会被触发，且<span class="math">\(n:=3\)</span>。然后，右侧表达式在<span class="math">\(n\)</span>设置为3的情况下进行评估，得到fib <span class="math">\(4+\)</span> fib 3。</p>
<pre><code>def name (params \({ }_{1}:\) type \(_{1}\) ) ... (params \(_{m}:\) type \(_{m}\) ) : type
    | patterns \(_{1}=&gt;\) result \(_{1}\)
        \}
    | patterns \(_{n}=&gt;\) result \(_{n}\)
</code></pre>
<p>递归定义的一般格式为</p>
<p>参数 params <span class="math">\(_{1}\)</span> 到 params <span class="math">\(_{m}\)</span> 无法进行模式匹配，只有类型中声明的其余参数可以进行匹配。如果在一行中提供了多个模式，它们将用逗号分隔。模式可能包含变量，这些变量在对应的右侧可见，同时也可能包含构造函数。</p>
<pre><code>def add : \(\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}\)
    | m, Nat.zero =&gt; m
    | m, Nat.succ n =&gt; Nat.succ (add m n)
</code></pre>
<p>自然数的基本算术运算，如加法、乘法和幂运算，可以通过递归来定义。当然，它们已经在Lean中定义（如+、*和*），但它们是很有用的练习。我们从加法开始：</p>
<p>我们同时对两个参数进行模式匹配，区分第二个参数为零和不为零的情况。每次递归调用add都会从第二个参数中剥离一个Nat.succ构造函数。除了Nat.zero和Nat.succ n，Lean还允许我们使用0和<span class="math">\(n+1\)</span>作为语法糖。</p>
<pre><code>#eval add 2 7
#reduce add 2 7
</code></pre>
<p>我们可以使用#eval或#reduce来评估将add应用于数字的结果：</p>
<p>两个命令在 Visual Studio Code 中都会打印出 9。#eval 使用了一个优化的解释器，而 #reduce 使用了 Lean 的推理内核，后者效率较低。</p>
<p>每次定义函数时提供一些测试是一个良好的实践，以确保其行为符合预期。你甚至可以将#eval或#reduce调用留在Lean文件中作为文档。</p>
<pre><code>def mul : \(\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}\)
    | _, Nat.zero =&gt; Nat.zero
    | m, Nat.succ n =&gt; add m (mul m n)
</code></pre>
<p>乘法的定义与加法的定义类似：</p>

<p>下划线（_）代表未使用的变量。我们可以给它一个名字（例如，m），但使用_能更好地记录我们的意图。</p>

<pre><code>\#eval mul 27
</code></pre>
<p>下面的#eval命令如预期那样输出14：</p>
<pre><code>def power : N -&gt; N -&gt; N
    | _, Nat.zero =&gt; 1
    | m, Nat.succ n =&gt; mul m (power m n)
</code></pre>
<p>幂运算（“<span class="math">\(m\)</span>的<span class="math">\(n\)</span>次方”）可以通过多种方式定义。我们的第一个提议在结构上与乘法的定义完全相同：</p>
<pre><code>def powerParam (m : N) : N -&gt; N
    | Nat.zero =&gt; 1
    | Nat.succ n =&gt; mul m (powerParam m n)
</code></pre>
<p>由于第一个参数<span class="math">\(m\)</span>在递归调用中保持不变，幂<span class="math">\(m n\)</span>，我们可以将其提取出来，并将其放在函数名称旁边，作为参数，位于引入函数类型（不包括参数m）的冒号之前：</p>
<p>从外部看，这两种定义没有区别。事实上，我们已经在List构造函数的类型参数<span class="math">\(\alpha\)</span>中见过这种语法（第2.1节）。</p>
<pre><code>def iter ( }\alpha\mathrm{ : Type) (z : \alpha)(f : \alpha -&gt; \alpha): N -&gt; \alpha
    | Nat.zero =&gt; z
    | Nat.succ n =&gt; f (iter }\alpha\mathrm{ z f n)
def powerIter (m n : N) : N :=
    iter N 1 (mul m) n
</code></pre>
<p>另一种可能的定义是先引入一个通用迭代器，然后使用正确的参数：</p>
<div class="math">$$
\underbrace{f(f(\cdots(f z) \cdots))}_{n \text { times }}
$$</div>
<p>iter函数接受一个类型<span class="math">\(\alpha\)</span>，一个“零”值<span class="math">\(z\)</span>，一个一元函数<span class="math">\(f\)</span>，以及一个自然数<span class="math">\(n\)</span>，并计算</p>
<div class="math">$$
\underbrace{\operatorname{mul} m(\operatorname{mul} m(\cdots(\operatorname{mul} m 1) \cdots))}_{n \text { times }}
$$</div>
<p>这是一个高阶函数的例子：一个以另一个函数（这里为<span class="math">\(f\)</span>）作为参数的函数。在函数式编程中，函数被视为与其他对象一样，可以作为参数或函数的结果使用。在这里，我们使用iter来计算<span class="math">\(m\)</span>的<span class="math">\(n\)</span>次方。</p>
<pre><code>def name (params: : type ; ... (params: : type
    result
</code></pre>
<p>最后，注意到powerIter的定义不是递归的。对于没有模式匹配的非递归函数，语法非常简单。</p>
<h4>2.2.2 算术表达式上的递归</h4>
<p>回到算术表达式的类型，如果我们要在Java中实现一个eval函数，我们可能会将其作为AExp接口的一部分，并在每个子类中实现它。对于Add、Sub、Mul和Div，我们会在左对象和右对象上递归调用eval。</p>
<pre><code>def eval (env : String \(\rightarrow \mathbb{Z}\) ) : AExp \(\rightarrow \mathbb{Z}\)
    | AExp.num i \(\quad=&gt;\) i
    | AExp.var \(x \quad=&gt;\) env \(x\)
    | AExp.add \(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\) eval env \(\mathrm{e}_{1}+\) eval env \(\mathrm{e}_{2}\)
    | AExp.sub \(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\) eval env \(\mathrm{e}_{1}-\) eval env \(\mathrm{e}_{2}\)
    | AExp.mul \(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\) eval env \(\mathrm{e}_{1}+\) eval env \(\mathrm{e}_{2}\)
    | AExp.div \(\mathrm{e}_{1} \mathrm{e}_{2} \Rightarrow\) eval env \(\mathrm{e}_{1} /\) eval env \(\mathrm{e}_{2}\)
</code></pre>
<p>在Lean中，语法非常简洁。我们定义一个单一的函数，并使用模式匹配来区分六种情况：</p>
<p>注意这个函数是高阶的：它接受一个函数env，该函数表示一个为变量赋值的“环境”。在AExp.var的情况下，环境用于评估变量，并在递归情况（AExp.add、AExp.sub、AExp.mul和AExp.div）中传递。</p>
<pre><code>#eval eval (fun x \mapsto 7) (AExp.div (AExp.var "y") (AExp.num 0))
</code></pre>
<p>也许您对AExp.div情况下的除以零问题感到担忧。让我们看看#eval对此有何看法，使用一个将所有变量赋值为7的环境：</p>
<p>输出结果为0。在Lean中，除法被方便地定义为一个全函数，当分母为零时返回零。关于为什么这并不危险的清晰解释，请参阅Buzzard的博客。<span class="math">\({ }^{2}\)</span></p>
<pre><code>def append ( }\alpha\mathrm{ : Type) : List }\alpha\mathrm{ -&gt; List }\alpha\mathrm{ -&gt; List }\alpha
    | List.nil, ys =&gt; ys
    | List.cons x xs, ys =&gt; List.cons x (append }\alpha\mathrm{ xs ys)
</code></pre>

<h3>2.2.3 列表上的递归</h3>
<p>列表上的递归函数可以以类似的方式定义：</p>

<pre><code>#eval append N [3, 1] [4, 1, 5]
#eval append _ [3, 1] [4, 1, 5]
</code></pre>
<p>append函数接受三个参数：一个类型为<span class="math">\(\alpha\)</span>的参数和两个类型为List <span class="math">\(\alpha\)</span>的列表。</p>
<p>通过传递占位符 _，我们让 Lean 从其他两个参数的类型中推断出类型 <span class="math">\(\mathbb{N}\)</span>。</p>
<pre><code>def appendImplicit { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; List }\alpha\mathrm{ -&gt; List }\alpha
    | List.nil, ys =&gt; ys
    | List.cons x xs, ys =&gt; List.cons x (appendImplicit xs ys)
</code></pre>
<p>为了使类型参数<span class="math">\(\alpha\)</span>隐式化，我们可以将其放在花括号{ }中：</p>
<pre><code>def appendPretty { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow List }\alpha\mathrm{ List }\alpha
    | [], ys =&gt; ys
    | x :: xs, ys =&gt; x :: appendPretty xs ys
</code></pre>
<p>#eval appendImplicit <span class="math">\([3,1][4,1,5]\)</span>at符号（<span class="math">\(\square\)</span>）可用于使隐式参数显式化。这在指导Lean解析器时偶尔是必要的。#eval @appendImplicit <span class="math">\(\mathbb{N}[3,1][4,1,5]\)</span>#eval @appendImplicit _ [3, 1] [4, 1, 5]我们可以在定义中使用语法糖，无论是在<span class="math">\(\Rightarrow\)</span>左侧的模式中，还是在右侧的表达式中：</p>
<pre><code>def reverse { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow List }\alpha
    | [] =&gt; []
    | x :: xs =&gt; reverse xs ++ [x]
</code></pre>
<p>在Lean的标准库中，append函数是一个名为++的中缀运算符。我们可以用它来定义一个反转列表的函数：</p>
<h3>2.3 定理陈述</h3>
<p>使Lean既是编程语言又是证明助手的原因在于，我们可以陈述关于我们定义的类型和常量的定理，并证明它们成立。在交互式定理证明中，术语定理、引理、推论、事实、属性和真陈述或多或少可以互换使用。同样，命题、逻辑公式和陈述也将表示相同的含义。</p>
<p>在Lean中，命题只是类型为Prop的项。这与一阶逻辑形成对比，在一阶逻辑中，项和公式在语法上传统上是区分的。可以被证明的命题称为定理（或引理、推论等）；否则它就是一个非定理或假命题。数学家有时将“命题”一词作为定理的同义词使用（例如，“命题3.14”），但在形式逻辑中，命题也可能是假的。</p>
<pre><code>theorem add_comm (m n : N) :
    add m n = add n m :=
    sorry
theorem add_assoc (l m n : N) :
    add (add l m) n = add l (add m n) :=
    sorry
theorem mul_comm (m n : N) :
    mul m n = mul n m :=
    sorry
theorem mul_assoc (l m n : N) :
    mul (mul l m) n = mul l (mul m n) :=
    sorry

theorem mul_add (l m n : N) :
    mul l (add m n) = add (mul l m) (mul l n) :=
    sorry
theorem reverse_reverse { }\alpha\mathrm{ : Type} (xs : List }\alpha\mathrm{ ) :
    reverse (reverse xs) = xs :=
    sorry
</code></pre>
<p>以下是一些关于第2.2节中定义的加法、乘法和列表反转操作的真实陈述示例：</p>
<pre><code>theorem name (params; : type; ) ... (paramsm : type m):
    statement :=
    proof
</code></pre>

<p>通用格式为</p>

<p>:= 符号用于分隔定理的陈述和其证明。定理的语法与不带模式匹配的 def 命令非常相似，只是用 statement 代替了 type，用 proof 代替了 result。在上面的例子中，我们使用了标记 sorry 作为实际证明的占位符。这个标记字面上是对未来读者和 Lean 的道歉，因为缺少了证明。这也是一个令人担忧的原因，直到我们设法消除它。在第3章和第4章中，我们将看到如何实现这一点。</p>
<pre><code>opaque a : \(\mathbb{Z}\)
opaque b : \(\mathbb{Z}\)
axiom a_less_b :
    \(a&lt;b\)
</code></pre>
<p>带有 sorry 证明的定理命令的直观语义是，“这个命题应该是可证明的，但我还没有完成证明——抱歉。”有时，我们想表达一个相关的想法，即“让我们假设这个命题成立。”Lean 为此提供了 axiom 命令，通常与 opaque 结合使用。例如：</p>
<pre><code>axiom name (params; : type; ) ... (paramsm : type m):
    statement
</code></pre>
<p>在opaque命令之后，我们除了a和b的类型之外，没有关于它们的任何信息。axiom命令指定了它们应该具有的属性。该命令的一般格式为</p>
<p>公理是危险的，因为它们可能导致逻辑不一致，从而推导出False。例如，如果我们添加第二个公理，声明a &gt; b，我们可以很容易地推导出False。交互式定理证明的历史充满了不一致的公理。其中一个轶事是：在2020年的Certified Programs and Proofs会议上，一篇提交的论文由于一个有缺陷的公理被拒绝，其中一位同行评审员从中推导出了False。<span class="math">\({ }^{3}\)</span>因此，我们通常会避免使用公理。</p>
<p>从Lean的角度来看，带有sorry证明的定理实际上是一个公理，并且可以用来破坏逻辑的一致性。为了防止误解，最好只在开发证明时使用sorry作为临时措施，而不是作为更明确和诚实的公理的替代品。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">#eval</th>
  <th style="text-align:left">executes a term using an optimized interpreter</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">#print</td>
  <td style="text-align:left">prints the definition of a constant</td>
</tr>
<tr>
  <td style="text-align:left">#reduce</td>
  <td style="text-align:left">executes a term using Lean's inference kernel</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
  <th style="text-align:left">axiom</th>
  <th style="text-align:left">states an axiom</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">def</td>
  <td style="text-align:left">defines a new constant</td>
</tr>
<tr>
  <td style="text-align:left">inductive</td>
  <td style="text-align:left">introduces a type and its constructors</td>
</tr>
<tr>
  <td style="text-align:left">namespace ... end</td>
  <td style="text-align:left">collects declarations in a named scope</td>
</tr>
<tr>
  <td style="text-align:left">theorem</td>
  <td style="text-align:left">states a theorem and its proof</td>
</tr>
</tbody>
</table>
<h3>2.4 新引入的Lean结构诊断命令总结</h3>
<h4>声明</h4>
<h4>证明命令</h4>
<p>sorry代表缺失的证明或定义</p>
<h2>第3章：逆向证明</h2>
<p>策略是一种操作目标（即待证明的命题）的过程，它要么完全证明该目标，要么生成新的子目标，或者失败。当我们陈述一个定理时，定理陈述就是初始目标。一旦使用合适的策略消除了所有（子）目标，证明就完成了。这里描述的大多数策略在《Lean 4中的定理证明》第5章中有更详细的记录。</p>
<p>策略是一种逆向证明机制。它们从目标出发，逆向工作，直至已经证明的定理。考虑定理<span class="math">\(a, a \rightarrow b\)</span>和<span class="math">\(b \rightarrow c\)</span>以及目标<span class="math">\(\vdash c\)</span>。（目标，如类型判断，由符号<span class="math">\(\vdash\)</span>标识。）一个非正式的逆向证明如下：</p>
<p>要证明<span class="math">\(c\)</span>，根据<span class="math">\(b \rightarrow c\)</span>，只需证明<span class="math">\(b\)</span>。要证明<span class="math">\(b\)</span>，根据<span class="math">\(a \rightarrow b\)</span>，只需证明<span class="math">\(a\)</span>。要证明<span class="math">\(a\)</span>，我们直接使用<span class="math">\(a\)</span>。反向证明的标志性短语是“只需证明”。注意到我们是如何从一个目标逐步过渡到另一个目标（<span class="math">\(\vdash c, \vdash b, \vdash a\)</span>），直到没有目标需要证明。相比之下，正向证明会从定理<span class="math">\(a\)</span>开始，逐步推进，一次一个定理，最终达到所需的定理<span class="math">\(c\)</span>：</p>
<p>由<span class="math">\(a\)</span>和<span class="math">\(a \rightarrow b\)</span>，我们得到<span class="math">\(b\)</span>。由<span class="math">\(b\)</span>和<span class="math">\(b \rightarrow c\)</span>，我们得到<span class="math">\(c\)</span>，如所期望的。正向证明只操作定理，而不操作目标。我们将在第4章更深入地研究正向证明。</p>
<p>非正式证明有时会以混合两种风格的方式书写。只要通过诸如“为了证明……，只需证明……”等措辞明确标识出逆向步骤，这是可以管理的。在目标前加上<span class="math">\(\vdash\)</span>符号可能有助于提醒这些主张尚未被证明。</p>
<p>你可能熟悉的另一种表达证明的格式是自然演绎。与上述证明相对应的自然演绎推导如下：</p>
<p><img src="img-3.jpeg" alt="img-3.jpeg"></p>
<p>当从上到下阅读时，推导过程对应于正向证明；当从下到上阅读时，则对应于反向证明。</p>
<h3>3.1 策略模式</h3>
<p>在第2章中，每当需要证明时，我们仅使用了sorry占位符。对于策略证明，我们现在将使用by进入策略模式。在此模式下，我们可以调用一系列策略。</p>
<p>策略作用于目标，目标由我们想要证明的命题<span class="math">\(Q\)</span>和局部上下文C组成。局部上下文由形式为<span class="math">\(x: \sigma\)</span>的变量声明和形式为<span class="math">\(h: P\)</span>的假设组成。我们使用<span class="math">\(C \vdash Q\)</span>来表示一个目标，其中<span class="math">\(C\)</span>是变量和假设的列表，而<span class="math">\(Q\)</span>是目标的目标。</p>
<pre><code>theorem fst_of_two_props :
    Ya b : Prop, a -&gt; b -&gt; a :=
    by
        intro a b
        intro ha hb
        apply ha
</code></pre>
<p>为了使内容更加具体，考虑以下 Lean 示例：</p>
<p>注意蕴含箭头<span class="math">\(\rightarrow\)</span>是右结合的；这意味着<span class="math">\(a \rightarrow b \rightarrow a\)</span>与<span class="math">\(a \rightarrow(b \rightarrow a)\)</span>是相同的。直观地说，该语句的含义是“a蕴含b蕴含a”，或者等价地“a和b蕴含a”。</p>
<p>我们将逐行回顾这个证明。通过关键字表示我们进入了策略模式，在该模式下，我们可以通过策略来指定证明。策略随后逐行列出，并且所有行的缩进相同。</p>
<div class="math">$$
\vdash \forall a b: \text { Prop, } a \rightarrow b \rightarrow a
$$</div>
<p>如果我们将光标放在 by 关键字上，Visual Studio Code 会报告当前目标仅仅是原始定理的陈述：</p>
<div class="math">$$
a b: \text { Prop } \vdash a \rightarrow b \rightarrow a
$$</div>
<p>接下来，策略
intro a b
告诉 Lean 固定两个自由变量，<span class="math">\(a\)</span> 和 <span class="math">\(b\)</span>，对应于同名的两个绑定变量。该策略模仿了数学家在纸上工作的方式：要证明一个<span class="math">\(\forall\)</span>量化的命题，只需为绑定变量的一些任意但固定的值证明它即可。目标变为</p>
<p>其中命题<span class="math">\(a\)</span>和<span class="math">\(b\)</span>在目标的局部上下文中声明，位于<span class="math">\(\vdash\)</span>符号的左侧。我们通常为自由变量和绑定变量使用相同的名称，如此处所做，但这并非强制要求。一般来说，使用唯一的名称并避免遮蔽现有变量是良好的实践。</p>
<p>与使用两个变量名调用一次intro不同，我们也可以分别调用intro两次，即先调用intro a，再调用intro b。一般来说，每次使用<span class="math">\(n\)</span>个参数调用intro时，会提取接下来的<span class="math">\(n\)</span>个量化变量。</p>
<p>intro策略不仅限于量化变量。在我们的证明脚本中，intro ha hb告诉Lean将假设<span class="math">\(a\)</span>和<span class="math">\(b\)</span>（来自<span class="math">\(a \rightarrow b \rightarrow\)</span>）移至本地上下文，并将这些假设命名为ha和hb。</p>
<div class="math">$$
a b: \text { Prop, ha : a, hb : b } \vdash a
$$</div>
<p>实际上，要证明一个蕴含关系，只需将其左侧作为假设并证明其右侧。因此，目标变为</p>
<p>通常会在假设名称前加上前缀<span class="math">\(h\)</span>。最后，策略apply ha告诉Lean将假设a（称为ha）与目标<span class="math">\(\vdash\)</span> a进行匹配。由于a在语法上等于a，我们得到了匹配。这完成了证明。</p>
<p>非正式地，以一种类似于纸笔数学的风格，我们可以将证明写如下：</p>
<p>设<span class="math">\(a\)</span>和<span class="math">\(b\)</span>为命题。假设(ha) a和(hb) b为真。为了证明a，我们使用假设ha。（数学家可能会使用数字标签如(1)和(2)来表示假设，而不是使用有意义的名称。）</p>
<pre><code>theorem fst_of_two_props_params (a b : Prop) (ha : a) (hb : b) :
    a :=
    by apply ha
</code></pre>
<p>回到Lean证明，我们可以通过将变量和假设声明为定理的参数来避免引入调用，如下所示：</p>
<div class="math">$$
a b: \text { Prop, ha : a, hb : b } \vdash a
$$</div>
<p>目标是</p>
<p>定理的所有参数在上下文中立即可用。通过应用ha，目标得以证明，就像我们之前的例子一样。</p>
<pre><code>theorem prop_comp (a b c : Prop) (hab : a -&gt; b) (hbc : b -&gt; c) :
    a -&gt; c :=
    by
        intro ha
        apply hbc
        apply hab
        apply ha
</code></pre>
<p>以下是一个包含多个连续apply操作的示例：</p>
<p>戴上我们数学家的帽子，我们可以将最后一个证明表述如下：假设 (ha) a 为真。为了证明 c，根据假设 hbc，只需证明 b。为了证明 b，根据假设 hab，只需证明 a。为了证明 a，我们使用假设 ha。</p>
<h3>3.2 基本策略</h3>
<p>intro 和 apply 策略是策略证明的基石。其他基本策略包括 exact、assumption、rfl 和 ac_rfl。如果我们有足够的耐心使用它们进行推理，而不依赖于更强的证明自动化，这些策略可以走得很远。它们还可以用于解决各种逻辑谜题。</p>
<p>下方，细长的大方括号 [ ] 用于包含可选的语法。</p>
<div class="math">$$
\text { intro }\left[\text { name }_{1} \ldots \text { name }_{n}\right]
$$</div>
<h4>介绍</h4>
<p>intro 策略将目标中的前导 <span class="math">\(\forall\)</span>-量化变量或前导假设 <span class="math">\(\mathrm{a} \rightarrow\)</span> 移动到局部上下文中。该策略接受一个可选参数，用于指定在上下文中赋予变量或假设的名称，覆盖默认名称。如果提供了多个名称（即 <span class="math">\(\mathrm{n}&gt;1\)</span>），则会移动多个变量或假设。</p>
<p>给定一个可证明的目标，intro 总是会生成一个可证明的目标。因此，它被认为是安全的。</p>
<h4>应用</h4>
<p>应用定理或假设</p>
<p>apply策略将目标的目标与指定定理或假设的结论进行匹配，并将定理或假设的前提作为新的目标添加。匹配过程基于计算进行。</p>
<p>我们必须谨慎使用apply，因为它可能会将一个可证明的目标转化为一个不可证明的子目标。例如，如果目标是<span class="math">\(\vdash\)</span> True，而我们应用了定理False <span class="math">\(\rightarrow\)</span> True，结论True会与目标中的True匹配，最终我们会得到一个不可证明的子目标<span class="math">\(\vdash\)</span> False。因此，我们说apply是不安全的。</p>
<h4>exact</h4>
<p>exact 定理或假设</p>
<p>exact策略将目标与指定的定理或假设进行匹配，从而证明目标。在这种情况下，我们通常可以使用apply，但exact能更好地传达我们的意图。</p>
<h4>assumption</h4>
<p>assumption 策略从局部上下文中找到一个与目标匹配的假设，并应用它来证明目标。</p>
<div class="math">$$
\begin{array}{ll}
\alpha \text {-conversion } &amp; (\text { fun } x \mapsto f x)=(\text { fun } y \mapsto f y) \\
\beta \text {-conversion } &amp; (\text { fun } x \mapsto f x) a=f a \\
\delta \text {-conversion } &amp; \text { double } 5=5+5 \\
\zeta \text {-conversion } &amp; (\text { let } n: \mathbb{N}:=2 ; n+n)=4 \\
\eta \text {-conversion } &amp; (\text { fun } x \mapsto f x)=f \\
\iota \text {-conversion } &amp; \text { Prod.fst }(a, b)=a
\end{array}
$$</div>
<h4>rfl</h4>
<p>rfl 策略用于证明形式为 <span class="math">\(\vdash 1=r\)</span> 的目标，其中两边 <span class="math">\(l\)</span> 和 <span class="math">\(r\)</span> 在计算上是语法等价的。计算首先意味着定义的展开，但也包括将匿名函数的应用简化为参数，以及其他更多内容。这些转换有传统的名称。主要转换与示例一起列在下面，全局上下文中包含定义 double <span class="math">\((n: \mathbb{N}): \mathbb{N}:=n+n\)</span> ：</p>
<p>将转换从左到右重复应用作为重写规则的过程称为规约；将转换反向应用一次的过程称为展开。</p>
<p>简而言之，为了证明<span class="math">\(\vdash 1=r\)</span>，rfl策略会展开<span class="math">\(l\)</span>和<span class="math">\(r\)</span>中的定义，并执行<span class="math">\(\beta\)</span>-规约和其他规约。如果在此规约过程中<span class="math">\(l\)</span>和<span class="math">\(r\)</span>在某个时刻变得语法上完全相同，它就会成功。通常，rfl在数学家会说“根据定义”的情况下成功。</p>

<h4>ac_rfl</h4>
<p>ac_rfl 与 rfl 类似，但它可以用于在结合律（例如，<span class="math">\((a+b)+c=a+(b+c))\)</span>）和交换律（例如，<span class="math">\(a+b=b+a)\)</span>）的基础上进行推理。这适用于已注册为结合和交换的二元操作，例如算术类型上的 <span class="math">\(*\)</span> 和 *，以及集合上的 <span class="math">\(\cup\)</span> 和 <span class="math">\(\cap\)</span>。我们将在第3.6节中看到一个示例。</p>

<h4>sorry</h4>
<p>我们在第2章中遇到的sorry证明命令可以在战术证明的任何时刻作为战术使用。它“证明”当前目标，但实际上并未真正证明。请谨慎使用。</p>
<pre><code>theorem And_swap (a b : Prop) :
    \(a \wedge b \rightarrow b \wedge a:=\)
    by
        intro hab
        apply And.intro
        apply And.right
        exact hab
        apply And.left
        exact hab
</code></pre>
<h3>3.3 关于逻辑连接词和量词的推理</h3>
<p>在我们学习如何对自然数、列表或其他数据类型进行推理之前，我们必须首先学习如何对Lean的逻辑连接词和量词进行推理。让我们从一个简单的例子开始：合取<span class="math">\((\wedge)\)</span>的交换律。</p>

<p>此时，我们建议您将光标移到Visual Studio Code中的示例上，以查看证明状态的序列。通过将光标放在每个命令上或紧随其后，您可以看到该行命令的效果。对于最后一行，Lean仅报告“没有目标”。</p>

<pre><code>And.intro \(: ? a \rightarrow ? b \rightarrow ? a \wedge ? b\)
    And.left : ?a \(\wedge\) ?b \(\rightarrow\) ?a
And.right : ?a \(\wedge\) ?b \(\rightarrow\) b
</code></pre>
<p>该证明是一个典型的intro-apply-exact混合体。它使用了以下定理</p>
<p>其中问号（?）表示可以实例化的变量——例如，通过将目标与定理的结论进行匹配。这些被称为元变量。</p>
<p>上述三个定理是与合取相关的引入规则和两个消去规则。逻辑符号（例如，<span class="math">\(\wedge\)</span>）的引入规则是一个其结论以该符号为最外层符号的定理。对偶地，消去规则在假设中包含该符号。对于每个逻辑符号，引入规则告诉我们如何证明以该符号为最外层位置的命题。相反，消去规则告诉我们如何必须证明这样的命题。</p>
<p>在上述证明中，我们应用了<span class="math">\(\wedge\)</span>的引入规则来证明目标<span class="math">\(\vdash b\)</span> <span class="math">\(\wedge a\)</span>，并应用了两个消去规则从假设<span class="math">\(a \wedge b\)</span>中提取出<span class="math">\(b\)</span>和a。听起来可能有些奇怪，我们通过使用所谓的引入规则来“消去”<span class="math">\(\wedge\)</span>在<span class="math">\(\vdash b \wedge a\)</span>中的出现。这种术语是反向的，因为我们的证明是反向进行的。</p>
<div class="math">$$
\text { a b : Prop, hab : } a \wedge b \vdash ? \text { left. } a \wedge b
$$</div>
<p>问号也可能出现在目标中。它们表示可以任意实例化的变量。在上述证明的中间，紧接在应用tactic apply And.right之后，我们得到了目标</p>
<p>其中 ?left.a 是一个元变量。策略 exact hab 将 ?left.a（在目标中）与 a（在 hab 中）匹配。用于实例化变量以使两个项在语法上相等的过程称为统一。匹配是统一的一种特殊情况，其中一个项不包含变量，如此处所示。</p>
<p>顺便提一下，每当目标中出现元变量时，还会出现额外的子目标，每个元变量的类型都会作为一个子目标（例如，<span class="math">\(\vdash\)</span> Prop）。这些令人困惑的子目标仅仅是提醒我们需要用正确类型的项来实例化元变量。我们通常可以忽略这些子目标。一旦元变量被实例化（通常在我们解决另一个子目标时），其相关的子目标也会消失。</p>
<p>在Lean中，统一是在计算的基础上进行的。例如，项 (fun <span class="math">\(x \mapsto\)</span> ?m) a 和 b 可以通过取 <span class="math">\(? \mathrm{~m}:=\mathrm{b}\)</span> 来统一，因为 (fun <span class="math">\(\mathrm{x} \mapsto \mathrm{b}\)</span> ) a 和 <span class="math">\(b\)</span> 在 <span class="math">\(\beta\)</span>-转换下是语法上相等的。</p>
<pre><code>theorem And_swap_braces :
    Ya b : Prop, a \(\wedge b \rightarrow b \wedge a:=\)
    by
    intro a b hab
    apply And.intro
    \{ exact And.right hab \}
</code></pre>
<p>以下是定理 And_swap 的另一种证明方法：</p>

<h4>{ 精确的 And.left hab }</h4>
<p>该定理的陈述方式不同，其中<span class="math">\(a\)</span>和<span class="math">\(b\)</span>作为<span class="math">\(\forall\)</span>量化的变量，而不是定理的参数。从逻辑上讲，这是等价的，但在证明中，我们必须引入<span class="math">\(a\)</span>和<span class="math">\(b\)</span>，此外还有hab。</p>

<p>另一个区别是使用了大括号<span class="math">\(\}\)</span>。当我们面临两个或更多需要证明的目标时，通常良好的风格是将每个证明放在用大括号括起来的独立块中。<span class="math">\(\}\)</span>战术组合器专注于第一个子目标；内部的战术必须证明它。在我们的例子中，应用And.intro战术会创建两个子目标，<span class="math">\(\vdash b\)</span>和<span class="math">\(\vdash a\)</span>。</p>
<p>第三个区别是，我们现在通过并置直接将And.right和And.left应用于假设<span class="math">\(a \wedge b\)</span>，分别得到<span class="math">\(b\)</span>和<span class="math">\(a\)</span>，而不是等待定理的假设作为新的子目标出现。这是在反向证明中的一个小幅前向步骤。相同的语法既用于解除（即证明）假设，也用于实例化一个<span class="math">\(\forall\)</span>量词。这种方法的一个好处是，我们避免了可能令人困惑的?left.a元变量。</p>
<pre><code>theorem f5_if (h : \n : \%, f n = n) :
    f 5 = 5 :=
    by exact h 5
</code></pre>
<p>在下一个例子中，我们使用并置来实例化一个<span class="math">\(\forall\)</span>量词：</p>
<pre><code>Or.inl : \forallb : Prop, ?a -&gt; ?a \veeb
Or.inr : \forallb : Prop, ?a -&gt; b \vee?a
Or.elim : ?a \vee?b -&gt; (?a -&gt; ?c) -&gt; (?b -&gt; ?c) -&gt; ?c
</code></pre>
<p>如果<span class="math">\(h\)</span>是定理<span class="math">\(\forall n, f n=n\)</span>，那么<span class="math">\(h 5\)</span>就是定理<span class="math">\(f 5=5\)</span>。析取<span class="math">\((\vee)\)</span>的引入和消去规则如下：</p>
<p>在Or.inl（“左引入”）和Or.inr（“右引入”）中的<span class="math">\(\forall\)</span>量词可以通过将定理名称直接应用于我们想要实例化的值来进行实例化，通过简单的并列方式。因此，Or.inl False对应于定理<span class="math">\(? a \rightarrow\)</span> ?a <span class="math">\(\vee\)</span> False。这是前向风格。</p>
<p>或者，我们可以在形式为<span class="math">\(\ldots \vdash c \vee d\)</span>的目标上调用apply Or.inl。这会将定理中的<span class="math">\(? a:=c\)</span>和<span class="math">\(? b:=d\)</span>进行设置。新的子目标是<span class="math">\(\ldots \vdash c\)</span>。这是反向风格。</p>
<p>Or.inl 和 Or.inr 都是不安全的：如果你在证明中错误地应用了其中一个，或者过早地应用了它们中的任何一个，你可能会得到一个无法证明的子目标。这一点很容易理解，如果你考虑可证明的目标<span class="math">\(\vdash\)</span> True <span class="math">\(\vee\)</span> False：应用 Or.inr 会产生无法证明的子目标<span class="math">\(\vdash\)</span> False。</p>
<p>Or.elim规则乍一看可能有些反直觉。本质上，它表明如果我们有<span class="math">\(a \vee b\)</span>，那么要证明任意的<span class="math">\(c\)</span>，只需在<span class="math">\(a\)</span>成立时和<span class="math">\(b\)</span>成立时分别证明<span class="math">\(c\)</span>即可。你可以将<span class="math">\((? a \rightarrow ? c) \rightarrow(? b \rightarrow ? c) \rightarrow ? c\)</span>视为一种巧妙的技巧，仅用蕴含来表达析取的含义。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { Iff.intro: }(? a \rightarrow ? b) \rightarrow(? b \rightarrow ? a) \rightarrow(? a \leftrightarrow ? b) \\
&amp; \text { Iff.mp : }(? a \leftrightarrow ? b) \rightarrow ? a \rightarrow ? b \\
&amp; \text { Iff.mpr: }(? a \leftrightarrow ? b) \rightarrow ? b \rightarrow ? a
\end{aligned}
$$</div>
<p>等价关系<span class="math">\((\leftrightarrow)\)</span>的引入和消去规则如下：</p>
<pre><code>Exists.intro: \(\forall w,(? P w \rightarrow(\exists x, ? P x))\)
Exists.elm: \((\exists x, ? P x) \rightarrow(\forall a, ? P a \rightarrow ? c) \rightarrow ? c\)
</code></pre>
<p>存在量词（<span class="math">\(\exists\)</span>）的引入和消解规则如下：</p>
<pre><code>theorem Exists_double_iden :
    \(\exists n: N\), double \(n=n:=\)
    by
    apply Exists.intro \o
    rfl
</code></pre>
<p><span class="math">\(\exists\)</span>的引入规则可用于实例化一个存在量词，并提供一个见证——一个使量词主体为真的值。例如：</p>
<p>再次，我们以正向方式实例化一个<span class="math">\(\vee\)</span>量词：Exists.intro o 是定理 ?P <span class="math">\(\circ \rightarrow(\exists x, ? P x)\)</span>。该规则是不安全的：选择错误的<span class="math">\(x\)</span>见证者将导致一个无法证明的目标。例如，如果目标是<span class="math">\(\vdash \exists n, n&gt;5\)</span>而我们选择3作为见证者，最终会得到无法证明的子目标<span class="math">\(\vdash 3&gt;5\)</span>。</p>
<p><span class="math">\(\exists\)</span>的消解规则与<span class="math">\(\vee\)</span>的规则相似。实际上，将量化<span class="math">\(\exists n\)</span>, ?P <span class="math">\(n\)</span>视为一种可能无限的析取<span class="math">\(? P \circ\)</span> <span class="math">\(\vee ? P 1 \vee \cdots\)</span>是一种富有成效的思考方式。同样地，<span class="math">\(\forall n\)</span>, ?P <span class="math">\(n\)</span>可以被视为<span class="math">\(? P \circ \wedge ? P 1 \wedge \cdots\)</span>。</p>
<p>对于真值（True），只有一条引入规则：</p>

<h4>True.intro : True</h4>
<p>真值不包含任何信息。如果它作为假设出现，则完全无用，并且没有消除规则可以从中提取任何信息。下文第3.8节中描述的清除策略可用于移除此类无用的假设。</p>

<div class="math">$$
\text { False.elim : False } \rightarrow \text { ?a }
$$</div>
<p>相应地，对于假（False），只有一条消解规则：</p>
<p>无法证明假命题，但如果我们从某个地方（例如，从假设中）得到了它，那么我们可以推导出任何命题。</p>
<p>事实上，否定（Not）是通过蕴含和假来定义的：<span class="math">\(\neg\)</span> a 简写为 a <span class="math">\(\rightarrow\)</span> False。直观上，这两者的意思是相同的。我们可以将“非 a”理解为“a 会蕴含某种荒谬的东西（因此非 a）”。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { Classical.em : } \forall \mathrm{a}: \text { Prop, a } \vee \neg \mathrm{a} \\
&amp; \text { Classical.byContradiction }:(\neg ? \mathrm{a} \rightarrow \text { False }) \rightarrow ? \mathrm{a}
\end{aligned}
$$</div>
<p>Lean的逻辑是经典的，支持排中律和反证法：</p>
<p>蕴含 <span class="math">\((\rightarrow)\)</span> 和全称量化 <span class="math">\((\vee)\)</span> 是那些没有“吠叫”的谚语中的狗。它们没有引入或消除规则。相反，对于它们两者，intro 策略是引入原则，而应用（如在 <span class="math">\(\lambda\)</span>-演算中）是消除原则。例如，给定定理 hab <span class="math">\(: a \rightarrow b\)</span> 和 ha <span class="math">\(: a\)</span>，应用 hab ha 是一个陈述 <span class="math">\(b\)</span> 的定理。</p>
<p>为了证明涉及连接词和量词的逻辑谜题，我们提倡一种“无脑”、“视频游戏”式的推理风格，主要依赖于诸如intro和apply等基本策略。以下是一些通常有效的策略：</p>
<ul>
<li>如果目标是一个蕴含<span class="math">\(P \rightarrow Q\)</span>，调用intro <span class="math">\(h P\)</span>将<span class="math">\(P\)</span>移至你的假设中：<span class="math">\(\ldots, \mathrm{hP}: \mathrm{P} \vdash \mathrm{Q}\)</span>。</li>
<li>如果目标是一个全称量词<span class="math">\(\forall x: \sigma, Q\)</span>，调用intro <span class="math">\(x\)</span>将<span class="math">\(x\)</span>移至局部上下文中：<span class="math">\(\ldots, x: \sigma \vdash Q\)</span>。</li>
<li>寻找一个结论与目标形状相同的定理或假设（可能包含可以匹配的变量），并应用它。例如，如果目标是<span class="math">\(Q\)</span>，并且你有一个形式为hPQ: <span class="math">\(P \rightarrow Q\)</span>的定理或假设，尝试apply hPQ。</li>
<li>一个否定目标<span class="math">\(\vdash \neg P\)</span>在计算上等同于<span class="math">\(\vdash P \rightarrow\)</span> False，因此你可以调用intro hP来生成子目标hP : P <span class="math">\(\vdash\)</span> False。通过调用rw [Not]（在第3.5节中描述）来扩展否定的定义通常是一个好策略。</li>
<li>有时你可以通过将目标替换为False来取得进展，通过输入apply False. e lim。作为下一步，你通常会应用一个形式为<span class="math">\(P \rightarrow\)</span> False或<span class="math">\(\neg P\)</span>的定理或假设。</li>
<li>当你面临多个选择时（例如，在Or.inl和Or.inr之间），记住你做出的选择，并在遇到死胡同或感觉没有进展时回溯。</li>
<li>如果你怀疑自己可能已经陷入死胡同，检查目标是否在给定的假设下确实可证明。即使你从一个可证明的定理陈述开始，当前的目标也可能是不可证明的（例如，如果你应用了不安全的规则）。</li>
</ul>
<div class="math">$$
\begin{aligned}
&amp; \text { Eq.ref1: } \forall \mathrm{a}, \mathrm{a}=\mathrm{a} \\
&amp; \text { Eq.symm : } ? \mathrm{a}=? \mathrm{~b} \rightarrow ? \mathrm{~b}=? \mathrm{a} \\
&amp; \text { Eq.trans : } ? \mathrm{a}=? \mathrm{~b} \rightarrow ? \mathrm{~b}=? \mathrm{c} \rightarrow ? \mathrm{a}=? \mathrm{c} \\
&amp; \text { Eq.subst : } ? \mathrm{a}=? \mathrm{~b} \rightarrow ? \mathrm{P} ? \mathrm{a} \rightarrow ? \mathrm{P} ? \mathrm{~b}
\end{aligned}
$$</div>

<h3>3.4 关于等式的推理</h3>
<p>等式 (=) 也是一个基本的逻辑常量。它由以下引入和消解规则来表征：</p>

<p>前三个定理是指明=是一个等价关系的引入规则。第四个定理是一个消去规则，允许我们在任意上下文中用等量替换等量，该上下文由元变量?P表示。</p>
<pre><code>theorem Eq_trans_symm \(\{\alpha\) : Type\} (a b c : \(\alpha\) )
    (hab : a = b) (hcb : c = b) :
    \(a=c:=\)
    by
    apply Eq.trans
    \(\{\) exact hab \}
    \(\{\) apply Eq.symm
        exact hcb \}
</code></pre>
<p>一个例子将展示这些规则的实际应用。下面，我们应用Eq. trans和Eq.symm来证明<span class="math">\(a=c\)</span>，使用的等式是<span class="math">\(a=b\)</span>和<span class="math">\(c=b\)</span>：</p>
<pre><code>theorem Eq_trans_symm_rw {a : Type} (a b c : a)
    (hab : a = b) (hcb : c = b) :
    a = c :=
    by
    rw [hab]
    rw [hcb]
</code></pre>
<p>由于这种重写方式非常常见，Lean 提供了一个 rw 策略来实现相同的结果。该策略还会在适用时自动应用 rfl：</p>
<p>关于解析的说明：等式的绑定优先级高于逻辑连接符。因此，<span class="math">\(a=b \wedge c=d\)</span> 被解析为 <span class="math">\((a=b) \wedge(c=d)\)</span>。</p>
<h3>3.5 重写策略</h3>
<p>重写策略 rw 及其相关策略 simp 以等价替换为基础。它们将等式作为从左到右的重写规则，用右侧的表达式替换左侧的表达式。</p>
<div class="math">$$
\begin{array}{ll}
\text { at } h_{1} \ldots h_{n} &amp; \text { rewrites the specified hypotheses } \\
\text { at } * &amp; \text { rewrites all hypotheses and the target }
\end{array}
$$</div>
<p>默认情况下，它们作用于目标的目标，但也可以使用at关键字来重写指定的假设：</p>
<div class="math">$$
r w\left[\text { theorem-or-constant }_{1}, \ldots, \text { theorem-or-constant }_{n}\right][\text { at position }]
$$</div>
<h4>rw</h4>
<p>rw 策略使用一个或多个等式作为从左到右的重写规则来重写目标。它搜索与第一个等式左侧匹配的第一个子项；一旦找到，该子项的所有出现都会被右侧替换。如果等式包含变量，则根据需要实例化这些变量。要将定理反向使用，即作为从右到左的重写规则，请在定理名称前加上一个短左箭头 <span class="math">\((\leftarrow)\)</span>。如果指定了多个等式，则依次应用它们。</p>
<p>因此，给定定理 hg : <span class="math">\(\forall x, g x=f x\)</span> 和目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{f} a)(g b)(g c)\)</span>，策略 rw [hg] 会生成子目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{f} a)(\mathrm{f} b)(g c)\)</span>，而 rw [ <span class="math">\(\leftarrow \mathrm{hg}\)</span> ] 则会生成子目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{g} a)(\mathrm{g} b)(\mathrm{g} c)\)</span>。</p>
<p>除了定理，我们还可以指定一个常量的名称。这将尝试使用该常量的定义方程之一作为重写规则。</p>
<h4>simp</h4>
<p>simp [在指定位置] simp策略使用一组称为simp集的标准重写规则对目标进行详尽的重写。simp集中的每个等式都被用作从左到右的重写规则。simp集包含各种关于预定义符号（例如算术和列表运算符）的规则，并且可以通过将@[simp]属性应用于合适的定理来扩展。simp [定理或常量<span class="math">\(\left.{ }_{1}, \ldots\right, \text { theorem-or-constant }_{n}\)</span> ] [在指定位置]对于上述simp变体，指定的定理会临时添加到simp集中。在定理列表中，星号（<em>）可以用来表示所有假设。在定理名称前的减号（-）会临时将该定理从simp集中移除。一个强大的咒语是simp [</em>] at *，它既能简化假设，又能使用结果来简化目标。</p>
<p>给定定理 hg : <span class="math">\(\forall x, g x=f x\)</span> 和目标 <span class="math">\(\vdash h(f a)(g b)(g c)\)</span>，策略 simp [hg] 会生成子目标 <span class="math">\(\vdash \mathrm{h}(\mathrm{f} \mathrm{a})(\mathrm{f} b)(\mathrm{f} \mathrm{c})\)</span>，其中 g b 和 g c 都被重写了。除了定理，我们还可以指定常量的名称。这会暂时将常量的定义方程添加到 simp 集合中。</p>
<p>此时，你可能会想，“那么simp到底做了什么呢？”当然，你可以研究源代码或查阅科学文献。但这可能不是最有效利用时间的方式。事实上，即使是证明助手的专家用户，也不完全理解他们日常使用的策略的行为。最成功的用户采取一种轻松、运动式的态度，依次尝试策略，并研究出现的子目标（如果有的话），以判断他们是否走对了路。</p>
<p>随着你不断使用simp和其他策略，你会对它们适用于哪些类型的目标产生一些直觉。这也是为什么交互式定理证明只能通过实践来学习的众多原因之一。通常，你不会完全理解Lean的具体操作——为什么一个策略会成功或失败。定理证明有时会非常令人沮丧。《银河系漫游指南》封面上用大而友好的字母印着的建议在这里同样适用：不要惊慌。</p>
<h3>3.6 数学归纳法证明</h3>
<p>归纳策略对归纳类型的值执行结构归纳。结构归纳意味着归纳遵循归纳类型的结构。对于由Nat.zero和Nat.succ构造的自然数，结构归纳对应于标准的数学归纳法：要证明p n，只需证明<span class="math">\(p \ominus\)</span>和<span class="math">\(\forall k, p k \rightarrow p(k * 1)\)</span>。借助归纳法，我们可以推理出我们在2.2节中通过递归定义的加法和乘法操作。</p>
<pre><code>theorem add_zero ( \(n: \mathbb{N}\) ) :
    add \(\odot n=n:=\)
    by
        induction n with
        | zero \(\quad=&gt;r f l\)
        | succ \(n^{\prime}\) ih =&gt; simp [add, ih]
</code></pre>
<p>加法是通过对其第二个参数进行递归定义的。我们将证明两个定理，add_zero 和 add_succ，它们为我们提供了在第一个参数上递归的替代方程。我们从 add_zero 开始：</p>
<p>归纳策略后跟两个由它们对应的构造函数标识的子证明。此外，子证明中特定的任何变量或假设都可以在构造函数的名称后显式命名。</p>
<div class="math">$$
n^{\prime}: \mathbb{N}, \text { ih }: \text { add } \odot n^{\prime}=n^{\prime} \vdash \text { add } \odot\left(\text { Nat. succ } n^{\prime}\right)=\text { Nat. succ } n^{\prime}
$$</div>
<p>第一个案例，标记为zero，对应于基本情况<span class="math">\(\vdash\)</span> add <span class="math">\(\odot \odot=\odot\)</span>。第二个案例，标记为succ，对应于归纳步骤</p>
<p>在succ之后指定的名称<span class="math">\(n^{\prime}\)</span>和ih分别是我们赋予Nat.succ的参数和归纳假设的名称。其他名称也是可能的，但通常将归纳假设称为ih。</p>
<pre><code>theorem add_succ (m n : N) :
    add (Nat.succ m) n = Nat.succ (add m n) :=
    by
        induction n with
        | zero =&gt; rfl
        | succ n' ih =&gt; simp [add, ih]
theorem add_comm (m n : N) :
    add m n = add n m :=
    by
        induction n with
        | zero =&gt; simp [add, add_zero]
        | succ n' ih =&gt; simp [add, add_succ, ih]
theorem add_assoc (l m n : N) :
    add (add l m) n = add l (add m n) :=
    by
        induction n with
        | zero =&gt; rfl
        | succ n' ih =&gt; simp [add, ih]
</code></pre>
<p>我们可以继续通过结构归纳法来证明定理：</p>
<pre><code>instance Associative_add : Std.Associative add :=
    { assoc := add_assoc }
instance Commutative_add : Std.Commutative add :=
    { comm := add_comm }
</code></pre>
<p>一旦我们证明了一个二元运算符是交换和结合的，最好让Lean的自动化工具，特别是ac_rfl，知道这一点。以下命令为add实现了这一点：</p>
<pre><code>theorem mul_add (l m n : N) :
    mul l (add m n) = add (mul l m) (mul l n) :=
    by
    induction n with
    | zero =&gt; rfl
    | succ n' ih =&gt;
        simp [add, mul, ih]
        ac_rfl
</code></pre>
<p>（实例机制将在第5章中解释。）以下示例使用ac_rfl策略来推理加法的结合律和交换律：</p>
<p>以下是关于如何进行归纳证明的一些提示：</p>
<ul>
<li><p>通常，按照目标中出现的某个函数的定义结构进行归纳是有益的。特别是，如果一个函数是通过对其第<span class="math">\(n\)</span>个参数进行递归定义的，那么对该参数进行归纳可能是有意义的。</p></li>
<li><p>如果归纳的基例难以证明，这通常表明选择了错误的变量，或者应该先证明一些定理。</p></li>
</ul>
<pre><code>induction term [with
| constructor, names, =&gt; tactics
    \vdots
| constructor, names, =&gt; tactics
</code></pre>
<h3>3.7 归纳策略</h3>
<h4>induction</h4>
<p>归纳策略对指定的项执行结构归纳。这会生成与项类型的定义中构造函数数量相同的子目标。归纳假设在对应于递归构造函数（例如，Nat.succ 或 List.cons）的子目标中作为假设可用。可选名称 names, ..., names 用于任何新出现的变量或假设。</p>

<h3>3.8 清理策略</h3>
<p>以下策略有助于我们清理目标。到目前为止，它们尚未被需要，但在证明探索过程中可能会有所帮助。</p>

<h4>清除</h4>
<p>clear 变量或假设, ... 变量或假设, clear 策略会移除指定的变量和假设，只要它们没有在目标的其他地方被使用。</p>
<h4>重命名</h4>
<p>重命名 变量类型或假设命题 =&gt; 新名称</p>
<p>重命名策略用于更改变量或假设的名称。</p>
<h3>3.9 新引入的Lean结构总结</h3>
<p>属性
@[simp] 将定理添加到simp集合中</p>
<table>
<thead>
<tr>
  <th style="text-align:left">ac_rfl</th>
  <th style="text-align:left">proves <span class="math">\(1=\mathrm{r}\)</span> up to associativity and commutativity</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">apply</td>
  <td style="text-align:left">matches the goal's target against the theorem's conclusion</td>
</tr>
<tr>
  <td style="text-align:left">assumption</td>
  <td style="text-align:left">proves the goal using a hypothesis</td>
</tr>
<tr>
  <td style="text-align:left">clear</td>
  <td style="text-align:left">removes a variable or hypothesis from the goal</td>
</tr>
<tr>
  <td style="text-align:left">exact</td>
  <td style="text-align:left">proves the goal using the specified theorem</td>
</tr>
<tr>
  <td style="text-align:left">induction</td>
  <td style="text-align:left">performs structural induction on a variable of an inductive type</td>
</tr>
<tr>
  <td style="text-align:left">intro</td>
  <td style="text-align:left">moves <span class="math">\(\forall\)</span>-quantified variables into the goal's hypotheses</td>
</tr>
<tr>
  <td style="text-align:left">rename</td>
  <td style="text-align:left">renames a variable or hypothesis</td>
</tr>
<tr>
  <td style="text-align:left">rfl</td>
  <td style="text-align:left">proves <span class="math">\(1=\mathrm{r}\)</span> up to computation</td>
</tr>
<tr>
  <td style="text-align:left">rw</td>
  <td style="text-align:left">rewrites once using the given theorem as a rewrite rule</td>
</tr>
<tr>
  <td style="text-align:left">simp</td>
  <td style="text-align:left">rewrites using a set of preregistered rewrite rules exhaustively</td>
</tr>
<tr>
  <td style="text-align:left">sorry</td>
  <td style="text-align:left">stands for a missing proof</td>
</tr>
</tbody>
</table>

<h4>证明命令</h4>
<h4>策略</h4>
<h4>策略组合器</h4>
<p><span class="math">\(\{\ldots\}\)</span>聚焦于第一个子目标；需要证明该子目标</p>

<h2>第四章：正向证明</h2>
<p>战术证明是逆向进行的。它们从目标出发，将其简化为已有的定理和假设。通常，以正向的方式工作是有意义的：从已有的定理和假设开始，逐步推进到我们的目标。结构化证明是一种支持这种推理方式的风格。战术证明往往更容易编写，但更难阅读。大多数用户将这两种风格结合起来，根据情况选择最合适的方式。结构化证明的高可读性使其受到一些用户的欢迎。</p>
<p>结构化证明是撒在Lean证明术语上的语法糖。它们使用诸如assume、have、let和show等关键字构建，这些关键字模仿了纸笔证明。所有Lean证明，无论是策略性的还是结构化的，最终都会在内部简化为证明术语。我们已经在第3章中看到了一些例子：给定假设ha : a和hab : a <span class="math">\(\rightarrow\)</span> b，术语hab ha是命题<span class="math">\(b\)</span>的证明术语，我们写作hab ha : b。定理和假设的名称，如ha和hab，也是证明术语。进一步推进这个想法，给定hbc : b <span class="math">\(\rightarrow c\)</span>，我们可以构建命题c的证明术语hbc (hab ha)。我们可以将hab视为一个将a的证明转换为<span class="math">\(b\)</span>的证明的函数，类似地，hbc也是如此。</p>
<p>结构化证明是Lean中的默认方式。它们可以在策略模式之外使用。要进入策略模式，我们必须使用by命令。</p>
<p>这里涉及的概念在《Lean 4中的定理证明》第2至4章中有更详细的描述。Nederpelt和Geuvers的教科书是另一个有用的参考。</p>
<pre><code>theorem fst_of_two_props :
    Ya b : Prop, a -&gt; b -&gt; a :=
fix a b : Prop
assume ha : a
assume hb : b
show a from
    ha
</code></pre>
<h3>4.1 结构化证明</h3>
<p>作为第一个示例，考虑以下结构化证明：</p>
<p>每个由<span class="math">\(\forall\)</span>量词绑定的变量和每个蕴含的假设都在证明中使用fix和assume命令显式引入。可以同时引入多个变量。我们通常会省略变量的类型，尤其是当它们可以从名称中推断出来时；然而，我们总是会明确写出命题，并将它们逐行列出，以提高可读性，这毕竟是结构化风格的主要潜在优势之一。最后的show ... from命令为了可读性重复了要证明的命题，并在关键字from之后给出证明。此时的目标是a b : Prop, ha : a, hb : b <span class="math">\(\vdash\)</span> a。</p>
<p>非正式地，我们可以将证明写成如下形式：固定一些命题a和<span class="math">\(b\)</span>。假设(ha) a和(<span class="math">\(h b\)</span>) b为真。我们必须证明a。这显然从ha得出。一些作者会在“命题”前插入“任意但固定”等限定词，或者他们会写“设a和b为某些命题”。所有这些变体都是等价的。并且，我们可以用“QED”代替“<span class="math">\(\square\)</span>”来结束证明。</p>
<pre><code>theorem prop_comp (a b c : Prop) (hab : a \(\rightarrow\) b) (hbc : b \(\rightarrow\) c) :
        \(a \rightarrow c:=\)
    assume ha : a
    have hb : b :=
        hab ha
    have hc : c :=
        hbc hb
    show c from
        hc
</code></pre>
<p>上述的Lean证明并不典型，因为目标的目标出现在假设中。通常，我们需要执行一些中间推理步骤，本质上是“从某某，我们得到某某”的形式。在Lean中，每个中间步骤都以have命令的形式出现，如下例所示：</p>
<p>非正式地：
假设（ha）a为真。
从ha和hab，我们得到（<span class="math">\(h b\)</span>）b。
从hb和hbc，我们得到（hc）c。
我们必须证明c。这从hc中直接得出。
注意这是一个正向证明：它从假设a逐步推进到目标定理c，每次一个定理。假言推理（“从a和<span class="math">\(\mathrm{a} \rightarrow \mathrm{b}\)</span>，推导出b”）通过简单的并列表达（例如，hab ha）。</p>
<p>一般来说，fix-assume-show框架会重复定理的陈述。我们通常将固定的变量命名为目标中的绑定变量，正如我们在这里所做的那样，但这并不是强制性的。此外，避免遮蔽现有变量是一个良好的实践。在最后一个fix或assume与show之间，我们可以根据需要添加任意数量的have命令，这取决于我们希望论证的详细程度。细节可以增加可读性，但提供过多细节可能会让读者感到不知所措。</p>
<pre><code>theorem prop_comp_inline (a b c : Prop) (hab : a -&gt; b)
    (hbc : b -&gt; c) :
    a }-&gt;\mathrm{ c :=
    assume ha : a
    show c from
        hbc (hab ha)
</code></pre>
<p>have命令的语法与定理类似，但出现在结构化证明中。我们也可以将have视为一种定义。在have hb : b := hab ha中，右侧的hab ha是<span class="math">\(b\)</span>的证明项，而左侧的<span class="math">\(h b\)</span>被定义为该证明项的同义词。从那时起，hb和hab ha可以互换使用。由于<span class="math">\(h b\)</span>和<span class="math">\(h c\)</span>仅使用一次且它们的证明非常简短，专家通常会内联它们，将hc替换为hbc hb，然后将hb替换为hab ha，最终得到</p>
<pre><code>theorem hr :
    \forall}\mp@subsup{c}{1}{}\mathrm{ c}_{1}:\sigma_{1}\mathrm{ ) ... ( }c_{1}:\sigma_{1}\mathrm{ ), P}_{1}-&gt;\cdots-&gt;P_{m}-&gt;R:=
    fix (c}\mp@subsup{c}{1}{}\mathrm{ c}_{1}:\sigma_{1}\mathrm{ ) ... (c}\mp@subsup{c}{1}{}\mathrm{ c}_{1}:\sigma_{1}\mathrm{ )
    assume h}\mp@subsup{h}{1}{}\mathrm{ : P
        \vdots
    assume h m : P m
    have k
    have k
show R from ...
</code></pre>
<p>典型的结构化证明具有以下fix-assume-have-show格式：</p>
<h3>4.2 结构化构造</h3>
<p>前一节介绍了编写结构化证明的主要命令：fix、assume、have 和 show。现在我们将更系统地回顾结构化证明的组成部分。</p>
<pre><code>theorem two_add_two_Eq_four :
    \(2+2=4:=\)
    by ...
</code></pre>
<h4>定理或假设</h4>
<p>除了sorry之外，最简单的结构化证明是定理或假设的名称。如果我们有</p>
<pre><code>theorem this_time_with_feeling :
    \(2+2=4:=\)
    two_add_two_Eq_four
</code></pre>
<p>那么定理名称 two_add_two_Eq_four 可以作为<span class="math">\(2+2=4\)</span>的证明在后续使用。例如：</p>
<pre><code>theorem add_comm_zero_left (n : N) :
    add ○ n = add n ○ :=
    add_comm ○ n
</code></pre>
<p>我们可以向定理传递参数来实例化<span class="math">\(\forall\)</span>量词并解除假设。假设定理add_comm（<span class="math">\(\mathrm{m} \mathrm{n}: \mathbb{N}\)</span>）：add <span class="math">\(\mathrm{m} \mathrm{n}=\)</span> add n m可用，并且假设我们想要证明其实例add <span class="math">\(\circ \mathrm{n}=\)</span> add <span class="math">\(\mathrm{n} \circ\)</span>。这可以通过使用定理名称和两个参数简洁地实现：</p>
<p>这相当于通过精确的 add_comm <span class="math">\(\circ \mathrm{n}\)</span> 进行战术证明，但更加简洁。exact 战术可以看作是 by 的逆操作。为什么要进入战术模式只是为了立即退出呢？</p>
<p>与exact和apply一样，定理或假设的陈述会与当前目标在计算上进行匹配。这提供了一定的灵活性。</p>

<h4>fix</h4>
<p>fix 名称 : 类型
fix 命令将目标中的 <span class="math">\(\forall\)</span>-量词变量移动到局部上下文中。它是 intro 策略的结构化版本。</p>

<p>请注意，Lean 中用于固定变量的标准策略是 fun。我们更倾向于使用 LoVelib 提供的 fix 作为更易读的替代方案。我们将保留 fun 用于指定匿名函数。</p>
<h4>假设</h4>
<p>assume name : proposition
assume 命令将目标的前置假设移动到本地上下文中。它可以被视为 intro 策略的结构化版本。</p>
<p>需要注意的是，Lean中用于声明假设的标准策略是fun。我们更倾向于使用LoVelib提供的assume，因为它更具可读性。我们将保留fun用于指定匿名函数。</p>
<pre><code>have name : proposition :=
    proof
</code></pre>
<h4>have</h4>
<p>have 命令允许我们陈述并证明一个中间定理，该定理可以引用之前通过 fixes、assumes 和 haves 引入的名称。证明可以是策略式的或结构化的。通常，我们倾向于使用结构化证明来勾勒主要论点，并在证明子目标或无趣的中间步骤时采用策略式证明。另一种混合情况出现在我们向定理名称传递参数时。例如，给定 hab : <span class="math">\(a \rightarrow b\)</span> 和 ha : a，策略 exact hab ha 将证明目标 <span class="math">\(\vdash b\)</span>。在这里，hab ha 是嵌套在策略中的证明项。</p>
<h4>let</h4>
<p>let name [: type] := term let命令引入一个新的局部定义。它可用于为在后续证明中多次出现的复杂对象命名。它与have类似，但设计用于可计算的数据，而非证明。展开或引入let对应于<span class="math">\(\mathcal{L}\)</span>-转换（第3.2节）。</p>
<p>构造 let name [: type] := term 后必须跟一个换行符或分号（;）。</p>
<pre><code>show proposition from
    proof
</code></pre>
<h4>show</h4>
<p>show命令允许我们重复需要证明的目标，这在文档记录中非常有用。它还允许我们以计算上语法等价的形式重新表述目标。如果我们不想重复目标并且不需要重新表述它，我们可以简单地写成proof，而不是使用show proposition from proof的语法。proof可以是策略式的或结构式的。</p>
<pre><code>theorem And_swap (a b : Prop) :
    a \(\wedge b \rightarrow b \wedge a:=\)
assume hab : a \(\wedge b\)
have ha : a :=
    And.left hab
have hb : b :=
    And.right hab
show b \(\wedge\) a from
    And.intro hb ha
</code></pre>
<h3>4.3 关于连接词和量词的前向推理</h3>
<p>关于逻辑连接词和量词的前向推理使用与策略模式相同的引入和消除规则（第3.3节）。几个例子将展示其特点。让我们从合取开始：</p>
<pre><code>theorem And_swap_tactical (a b : Prop) :
    a \(\wedge b \rightarrow b \wedge a:=\)
    by
        intro hab
        apply And.intro
        apply And.right
        exact hab
        apply And.left
        exact hab
</code></pre>
<p>即使不知道 And.left 等含义的读者也能理解我们从<span class="math">\(a \wedge b\)</span>中提取<span class="math">\(a\)</span>和<span class="math">\(b\)</span>，并将它们重新组合为<span class="math">\(b \wedge a\)</span>。数学家们可能会比理解其战术对应物更容易理解这个证明：</p>
<p>一般来说，逆向证明更容易“无脑”推导，而且大多数证明助手提供的自动化功能都是逆向工作的。这很合理：假设你是马普尔小姐或赫尔克里·波洛，正在调查一起谋杀案。逆向调查会从犯罪现场开始，试图提取可能将少数嫌疑人连接到犯罪的线索。相比之下，正向调查可能会先询问多达八十亿人，以确定他们是否有不在场证明。哪种方法更有可能成功？</p>
<pre><code>theorem Forall.one_point \(\{\alpha\) : Type\} (t : \(\alpha\) ) (P : \(\alpha \rightarrow\) Prop) :
    \((\forall x, x=t \rightarrow P x) \leftrightarrow P t:=\)
    Iff.intro
    (assume hall : \(\forall x, x=t \rightarrow P x\)
        show \(P\) t from
            by
                apply hall \(t\)
                rfl)
    (assume hp : P t
    fix \(x: \alpha\)
    assume heq : \(x=t\)
    show \(P\) x from
        by
            rw [heq]
            exact hp )
</code></pre>
<p>我们的下一个例子涉及单点规则。这些定理可用于在绑定变量实际上只能取一个值时消除量词。例如，命题<span class="math">\(\forall n, n=666 \rightarrow\)</span> beast <span class="math">\(\geq n\)</span> 可以简化为 beast <span class="math">\(\geq 666\)</span>。以下定理证明了这种简化的合理性：</p>
<p>这个证明可能看起来令人生畏，但它的开发并不困难。关键在于一步一步地进行。首先，我们观察到目标是一个等价关系，因此我们写出了</p>
<p>当且仅当.intro (<em>) (</em>)，其中Iff.intro是<span class="math">\(\leftrightarrow\)</span>的引入规则（第3.3节）。这两个占位符对于使此证明结构良好非常重要。我们使用括号是因为我们强烈怀疑子证明将是非平凡的。由于证明本质上是项，而项本质上是程序，我们在第1.4节给出的建议在这里同样适用，稍作修改：</p>
<p>关键思想是证明在所有时刻都应语法正确。我们在Visual Studio Code中看到的唯一红色下划线应出现在占位符下。一般来说，证明开发的一个好原则是从一个能够编译的证明开始，执行最小的更改以获得一个新的可编译证明，并重复此过程直到证明完成。</p>
<pre><code>Iff.intro
    (assume hall : \(\forall x, x=t \rightarrow P x\)
        show \(P\) t from
            _ )
    (_)
</code></pre>
<p>将鼠标悬停在第一个占位符上，相应的子目标就会出现。我们可以看到，Lean期望得到一个<span class="math">\(\vdash(\forall x, x=t \rightarrow P x) \rightarrow P t\)</span>的证明，因此我们提供了一个合适的框架。一个结构化的蕴含证明由一个assume后跟一个show组成：</p>
<pre><code>Iff.intro
    (assume hall : \(\forall x, x=t \rightarrow P x\)
        show \(P t\) from
            by
                apply hall \(t\)
                rfl))
    (_)
</code></pre>
<p>剩余的每个占位符都可以用结构化证明或策略证明来替换。为了消除第一个占位符，我们进入策略模式并应用假设<span class="math">\(\forall x, x=t \rightarrow P x\)</span>的实例<span class="math">\(t=t \rightarrow P t\)</span>到目标<span class="math">\(\vdash P t\)</span>。这留下了证明义务<span class="math">\(t=t\)</span>，我们使用rfl策略来解除它：</p>
<pre><code>(assume hp : P t
fix x : \(\alpha\)
assume heq : \(x=t\)
show \(P x\) from
    _ )
</code></pre>
<p>第二个占位符代表<span class="math">\(\vdash P t \rightarrow \forall x, x=t \rightarrow P x\)</span>。为了消除它，我们为第一个蕴含的假设编写assume，为<span class="math">\(\forall\)</span>编写fix，为第二个蕴含的假设编写assume，并为结论编写show：</p>
<pre><code>(assume hp : P t
fix \(x: \alpha\)
assume heq : \(x=t\)
show \(P x\) from
    by
        rw [heq]
        exact hp )
</code></pre>

<p>展示的证明是战术性的：我们将<span class="math">\(x\)</span>重写为<span class="math">\(t\)</span>在<span class="math">\(\vdash P x\)</span>中，得到<span class="math">\(\vdash P t\)</span>，这与假设hp匹配：</p>

<pre><code>theorem beast_666 (beast : N) :
    \((\forall n, n=666 \rightarrow\) beast \(\geq n) \leftrightarrow\) beast \(\geq 666:=\)
Forall.one_point _ _
</code></pre>

<p>让我们验证一下单点规则在我们引用的示例中是否确实有效：</p>

<p>它起作用了。我们可以用 Forall. one_point 666 (fun <span class="math">\(m \mapsto\)</span> beast <span class="math">\(\geq m\)</span> ) 来代替 Forall. one_point __。</p>
<pre><code>theorem Exists.one_point \(\{\alpha\) : Type\}(t : \(\alpha\) ) (P : \(\alpha \rightarrow\) Prop) :
    \((\exists x: \alpha, x=t \wedge P x) \leftrightarrow P t:=\)
    Iff.intro
    (assume hex : \(\exists x, x=t \wedge P x\)
        show \(P t\) from
            Exists.elim hex
            (fix \(x: \alpha\)
                assume hand : \(x=t \wedge P x\)
                have hxt : \(x=t:=\)

        And.left hand
        have hpx : P x :=
            And.right hand
        show P t from
            by
                rw [ \leftarrowhxt]
                exact hpx))
(assume hp : P t
    show \(\exists x: \alpha, x=t \wedge P x\) from
        Exists.intro \(t\)
            (have tt : \(t=t:=\)
                by rfl
            show \(t=t \wedge P t\) from
                And.intro tt hp))
</code></pre>
<p>最后，关于<span class="math">\(\exists\)</span>的单点规则展示了如何在结构化证明中使用<span class="math">\(\exists\)</span>的引入和消除规则：</p>
<p>尽管证明可能看起来令人望而生畏，但它主要是在没有过多思考的情况下，按照与<span class="math">\(\forall\)</span>的单点规则证明相同的步骤开发的。</p>
<pre><code>Iff.intro (_) (_)
</code></pre>

<p>首先，我们使用<span class="math">\(\leftrightarrow\)</span>的引入规则：</p>

<pre><code>Iff.intro
    (assume hex : \(\exists x: \alpha, x=t \wedge P x\)
        show \(P t\) from
            _ )
    (_)
</code></pre>
<p>对于第一个占位符，我们必须在假设<span class="math">\(\exists x: \alpha, x=t \wedge P x\)</span>下提供<span class="math">\(P t\)</span>的证明。因此，我们将证明骨架扩展为</p>
<pre><code>Iff.intro
    (assume hex : \(\exists x: \alpha, x=t \wedge P x\)
        show \(P t\) from
            Exists.elim hex (_))
    (_)
</code></pre>
<p>此时，我们希望从假设hex中提取<span class="math">\(x\)</span>的见证。为此，我们使用<span class="math">\(\exists\)</span>的消去规则：</p>
<pre><code>Iff.intro
    (assume hex : \(\exists x: \alpha, x=t \wedge P x\)
        show \(P t\) from
            Exists.elim hex
            (fix \(x: \alpha\)
            assume hand : \(x=t \wedge P x\)
            show \(P t\) from
                _))
(_)
</code></pre>
<p>第一个占位符要求证明子目标<span class="math">\(\vdash \forall x, x=t \wedge P x \rightarrow P t\)</span>。我们简要描述一个证明：</p>
<pre><code>Iff.intro
    (assume hex : \(\exists x: \alpha, x=t \wedge P x\)
        show \(P\) t from
            Exists.elim hex
            (fix \(x: \alpha\)
                assume hand : \(x=t \wedge P x\)
                have hxt : \(x=t\) :=
                    And.left hand
                have hpx : P x :=
                    And.right hand
                show \(P\) t from
                    _))
    (_)
</code></pre>
<p>注意子证明如何镜像子目标，其中fix对应于<span class="math">\(\forall\)</span>，assume对应于<span class="math">\(\rightarrow\)</span>的假设，而show对应于<span class="math">\(\rightarrow\)</span>的结论。我们现在可以访问见证<span class="math">\(x\)</span>及其特征属性<span class="math">\(x=t \wedge P x\)</span>。接下来，我们使用have命令和<span class="math">\(\wedge\)</span>的消除规则（And.left和And.right）提取<span class="math">\(x=t \wedge P x\)</span>的两个合取项：</p>
<pre><code>Iff.intro
    (assume hex : \(\exists x: \alpha, x=t \wedge P x\)
        show \(P\) t from
            Exists.elim hex
            (fix \(x: \alpha\)
                assume hand : \(x=t \wedge P x\)
                have hxt : \(x=t\) :=
                    And.left hand
                have hpx : P x :=
                    And.right hand
                show \(P\) t from
                    by
                        rw [t-hxt]
                        exact hpx))
    (_)
</code></pre>
<p>现在我们可以尝试证明<span class="math">\(P t\)</span>。我们将<span class="math">\(t\)</span>重写为<span class="math">\(x\)</span>并应用假设P x：</p>
<pre><code>(assume hp : P t
    show \(\exists x: \alpha, x=t \wedge P x\) from
    _ )
</code></pre>
<p>对于剩余的占位符，我们首先基于子目标<span class="math">\(\vdash \mathrm{Pt} \rightarrow \exists \mathrm{x}: \alpha, \mathrm{x}=\mathrm{t} \wedge \mathrm{Px}\)</span>提供一个证明框架：</p>
<pre><code>(assume hp : P t
    show \(\exists x: \alpha, x=t \wedge P x\) from
        Exists.intro t (_))
</code></pre>
<p>然后我们使用<span class="math">\(\exists\)</span>的引入规则来提供见证<span class="math">\(t\)</span>：</p>
<pre><code>(assume hp : P t
    show \(\exists x: \alpha, x=t \wedge P x\) from
        Exists.intro t
</code></pre>
<div class="math">$$
\begin{aligned}
(\text { show } t &amp; =t \wedge P t \text { from } \\
\ldots &amp; \text { ) }
\end{aligned}
$$</div>

<p>接下来是更多的模板内容：</p>

<pre><code>(assume hp : P t
    show \(\exists x: \alpha, x=t \wedge P x\) from
        Exists.intro \(t\)
            (have tt : \(t=t:=\)
                by rfl
            show \(t=t \wedge P t\) from
                And.intro tt hp))
</code></pre>
<p>最后一个合取式，<span class="math">\(t=t \wedge P t\)</span>，很容易证明：它的左侧由自反性得出，而右侧则仅仅是假设 hp。最终，我们得到</p>
<p>为了构建上述的结构化证明，我们使用了与展示类型居民（第1.4节）大致相同的过程，将函数箭头理解为蕴含。这两个过程之间的相似性并非偶然，我们将在第4.7节中看到这一点。</p>
<h3>4.4 计算式证明</h3>
<p>在非正式的数学中，我们经常将证明表示为等式、不等式或等价关系的传递链（例如，<span class="math">\(a=b=c, a \geq b \geq c\)</span>，或<span class="math">\(a \leftrightarrow b \leftrightarrow c\)</span>）。在Lean中，此类计算式证明由calc命令支持，该命令提供了一种轻量级的语法，并负责为预先注册的关系（如等式和算术比较运算符）应用传递性定理。</p>
<pre><code>calc
    term
        \(o p_{1}\) term \(_{1}:=\)
        proo \(f_{1}\)
    _ \(o p_{2}\) term \(_{2}:=\)
        proo \(f_{2}\)
        \(\vdots\)
    _op \(_{n}\) term \(_{n}:=\)
        proo \(f_{n}\)
</code></pre>
<p>一般语法如下：</p>
<p>下划线（<em>）是语法的一部分。每个证明${ }</em>{i}$验证了语句项<span class="math">\(_{1-t} o p_{i}\)</span>项<span class="math">\(_{i}\)</span>。运算符<span class="math">\(o p_{i}\)</span>不必相同，但它们必须相互兼容。例如，<span class="math">\(=,&lt;\)</span>和<span class="math">\(\leq\)</span>是兼容的，而<span class="math">\(&gt;\)</span>和<span class="math">\(&lt;\)</span>则不兼容。</p>
<pre><code>theorem two_mul_example (m n : N) :
    2 * m + n = m + n + m :=
    calc
    2 * m + n = m + m + n :=
        by rw [Nat.two_mul]
    _ = m + n + m :=
        by ac_rfl
</code></pre>

<p>以下是一个简单的例子：</p>

<div class="math">$$
\begin{aligned}
2 * m+n &amp; =(m+m)+n \\
&amp; =m+n+m
\end{aligned}
$$</div>
<div class="math">$$
\begin{aligned}
&amp; \text { (since } 2 * m=m+n) \\
&amp; \text { (by associativity and commutativity of }+)
\end{aligned}
$$</div>
<p>数学家们（假设他们愿意为这样一个简单的结果提供理由）可能会将上述证明大致写成如下形式：</p>
<pre><code>theorem two_mul_example_have (m n : N) :
    \(2 * m+n=m+n+m:=\)
    have hmul : \(2 * m+n=m+m+n:=\)
        by rw [Nat.two_mul]
    have hcomm : \(m+m+n=m+n+m:=\)
        by ac_rfl
    show _ from
        Eq.trans hmul hcomm
</code></pre>
<p>在Lean证明中，下划线代表项<span class="math">\((m+m)+n\)</span>，如果我们在没有calc的情况下编写证明，就必须重复这一项。</p>
<p>请注意，在使用haves时，我们还需要显式调用Eq.trans并为两个中间步骤命名。</p>
<h3>4.5 使用策略进行前向推理</h3>
<p>许多用户更喜欢策略模式而非结构化证明。但即使在策略模式下，以向前的方式推理，混合前向和后向推理步骤，也可能是有用的。结构化证明命令have、let和calc也可以作为策略使用，这使得这种推理方式成为可能。</p>
<pre><code>theorem prop_comp_tactical (a b c : Prop) (hab : a \(\rightarrow\) b)
    (hbc : b \(\rightarrow\) c) :
    a \(\rightarrow\) c :=
    by
        intro ha
        have hb : b :=
            hab ha
        let \(c^{\prime}:=c\)
        have hc : c' :=
            hbc hb
        exact hc
</code></pre>
<p>以下示例展示了在我们已经多次见过的定理上使用have和let策略：</p>
<p>have
have name : proposition :=
proof
have 策略允许我们在策略模式中陈述并证明一个中间定理。之后，该定理将作为假设在目标状态中可用。</p>
<h4>let</h4>
<p>let 名称 <span class="math">\([\)</span> : 类型 <span class="math">\(]:=\)</span> 项 let 策略允许我们在策略模式中引入一个局部定义。之后，定义的符号及其定义将在目标状态中可用。</p>
<pre><code>calc
    term \(_{0}\) op \(_{1}\) term \(_{1}:=\)
        proof \(_{1}\)
    _ op \(_{2}\) term \(_{2}:=\)
        proof \(_{2}\)
            \vdots
    _ op \(_{n}\) term \(_{n}:=\)
        proof \(_{n}\)
</code></pre>
<h4>calc</h4>
<p>calc 策略允许我们在策略模式中输入计算性证明（第4.4节）。该策略与同名的结构化证明命令具有相同的语法。我们可以将 calc ...（其中 calc 是一个策略）视为 apply (exact calc ...) 的别名，其中 calc 是上述的结构化证明命令。</p>
<h3>4.6 依赖类型</h3>
<p>依赖类型是依赖类型理论家族逻辑的定义性特征。尽管你可能不熟悉这个术语，但你很可能以某种形式熟悉这个概念。</p>
<div class="math">$$
(\text { pick } n:\{i: \mathbb{N} / / i \leq n\})_{n: \mathbb{N}}
$$</div>
<p>考虑一个函数 pick，它接受一个自然数 <span class="math">\(n\)</span>（即来自 <span class="math">\(\mathbb{N}\)</span> <span class="math">\(=\{0,1,2, \ldots\}\)</span> 的值），并返回一个介于 0 和 <span class="math">\(n\)</span> 之间的自然数。直观上，pick <span class="math">\(n\)</span> 应该具有类型 <span class="math">\(\{0,1, \ldots, n\}\)</span>（即由所有自然数 <span class="math">\(i \leq n\)</span> 组成的类型）。在 Lean 中，这种类型被写作 <span class="math">\(\{i: \mathbb{N} / / i \leq n\}\)</span>。这将是 pick <span class="math">\(n\)</span> 的类型。数学倾向的读者可能会将 pick 视为一个 <span class="math">\(\mathbb{N}\)</span>-索引的项族</p>
<div class="math">$$
\text { pick }:(n: \mathbb{N}) \rightarrow\{i: \mathbb{N} / / i \leq n\}
$$</div>
<p>其中每个项的类型取决于索引——例如，pick <span class="math">\(5:\{i: \mathbb{N} / /\)</span> <span class="math">\(i \leq 5\)</span> }。但是pick本身的类型会是什么呢？我们希望表达pick是一个函数，它接受一个参数<span class="math">\(n: \mathbb{N}\)</span>并返回一个类型为<span class="math">\(\{i: \mathbb{N} / / i \leq n\}\)</span>的值。为了捕捉这一点，我们将写成</p>
<p>这是一个依赖类型：结果的类型取决于参数<span class="math">\(n\)</span>的值。（变量名<span class="math">\(n\)</span>本身并不重要；我们也可以写成<span class="math">\(m\)</span>或<span class="math">\(x\)</span>。）</p>
<p>除非另有说明，依赖类型通常指依赖于（非类型的）项的类型，如上所述，其中<span class="math">\(n: \mathbb{N}\)</span>作为项，<span class="math">\(\{i: \mathbb{N} / / i \leq n\}\)</span>作为依赖于它的类型。但是：- 类型也可能依赖于另一个类型——例如，类型构造器List，其<span class="math">\(\eta\)</span>扩展变体fun <span class="math">\(\alpha\)</span> : Type <span class="math">\(\mapsto\)</span> List <span class="math">\(\alpha\)</span>，或者具有相同定义域和陪域的函数的多态类型fun <span class="math">\(\alpha\)</span> : Type <span class="math">\(\mapsto \alpha \rightarrow \alpha\)</span>。</p>
<ul>
<li>项可能依赖于一个类型——例如，多态恒等函数fun <span class="math">\(\alpha\)</span> : Type <span class="math">\(\mapsto\)</span> fun <span class="math">\(x: \alpha \mapsto x\)</span>。</li>
<li>当然，项也可能依赖于另一个项——例如，fun <span class="math">\(n\)</span> : <span class="math">\(\mathbb{N}\)</span> <span class="math">\(\mapsto n+2\)</span>。总结来说，对于fun <span class="math">\(x \mapsto t\)</span>，有四种情况：</li>
</ul>
<table>
<thead>
<tr>
  <th style="text-align:left">Body (t)</th>
  <th style="text-align:left">Argument (x)</th>
  <th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">A term depending on</td>
  <td style="text-align:left">a term</td>
  <td style="text-align:left">Simply typed <span class="math">\(\lambda\)</span>-expression</td>
</tr>
<tr>
  <td style="text-align:left">A type depending on</td>
  <td style="text-align:left">a term</td>
  <td style="text-align:left">Dependent type (in the narrow sense)</td>
</tr>
<tr>
  <td style="text-align:left">A term depending on</td>
  <td style="text-align:left">a type</td>
  <td style="text-align:left">Polymorphic term</td>
</tr>
<tr>
  <td style="text-align:left">A type depending on</td>
  <td style="text-align:left">a type</td>
  <td style="text-align:left">Polymorphic type constructor</td>
</tr>
</tbody>
</table>
<div class="math">$$
\begin{aligned}
&amp; \frac{C \vdash t:(x: \sigma) \rightarrow \tau[x] \quad C \vdash u: \sigma}{C \vdash t u: \tau[u]} \text { APP }^{\prime} \\
&amp; \frac{C, x: \sigma \vdash t: \tau[x]}{C \vdash(\text { fun } x: \sigma \mapsto t):(x: \sigma) \rightarrow \tau[x]} \text { FUN }^{\prime}
\end{aligned}
$$</div>
<p>最后三行对应Henk Barendregt的<span class="math">\(\lambda\)</span>-立方体的三个轴。<span class="math">\({ }^{1}\)</span>第1.3节中介绍的APP和FUN规则必须进行泛化以处理依赖类型：</p>
<p>符号<span class="math">\(\tau[x]\)</span>表示可能包含<span class="math">\(x\)</span>的类型，而<span class="math">\(\tau[u]\)</span>表示将<span class="math">\(x\)</span>的所有出现替换为<span class="math">\(u\)</span>后的相同类型。</p>
<p>当<span class="math">\(x\)</span>不出现于<span class="math">\(\tau[x]\)</span>中时，便出现了简单类型的情况。此时，我们可以简单地写作<span class="math">\(\sigma \rightarrow\)</span>，而不是<span class="math">\((x: \sigma) \rightarrow\)</span>。熟悉的符号<span class="math">\(\sigma \rightarrow \tau\)</span>等价于<span class="math">\(\_: \sigma) \rightarrow \tau\)</span>。很容易验证，当<span class="math">\(x\)</span>不出现于<span class="math">\(\tau[x]\)</span>中时，APP'和FUN'与APP和FUN是一致的。</p>
<div class="math">$$
\frac{\vdash \text { pick }:(n: \mathbb{N}) \rightarrow i: \mathbb{N} / / i \leq n \quad \vdash 5: \mathbb{N}}{\vdash \text { pick } 5: i: \mathbb{N} / / i \leq 5} \text { APP }^{\prime}
$$</div>

<p>下面的示例展示了APP'：</p>

<div class="math">$$
\frac{\alpha: \text { Type, } x: \alpha \vdash x: \alpha}{\alpha: \text { Type } \vdash(\text { fun } x: \alpha \mapsto x): \alpha \rightarrow \alpha} \text { FUN or FUN' }
$$</div>
<p>下一个示例演示了FUN'：</p>
<p><span class="math">\(\vdash(\)</span> 函数 <span class="math">\(\alpha\)</span> : 类型 <span class="math">\(\mapsto\)</span> 函数 <span class="math">\(x: \alpha \mapsto x):(\alpha:\)</span> 类型 <span class="math">\() \rightarrow \alpha \rightarrow \alpha\)</span> FUN'</p>

<p>这幅图是不完整的，因为我们只检查了冒号（:）左侧的项——这些实体——是否类型正确。冒号右侧的实体——类型——也应该使用相同的类型系统进行检查。</p>

<p>例如，Nat.succ 的类型是 <span class="math">\(\mathbb{N} \rightarrow \mathbb{N}\)</span>，其类型为 Type。像 Type 和 Prop 这样的类型的类型被称为宇宙。我们将在第12章中更详细地研究它们。</p>
<p>值得注意的是，全称量化仅仅是依赖类型的一个别名：<span class="math">\(\forall x: \sigma, \tau\)</span> 是 <span class="math">\((x: \sigma) \rightarrow \tau\)</span> 的缩写。这一点将在下面变得更清晰。</p>

<h3>4.7 PAT原则</h3>
<p>你可能已经注意到，相同的符号<span class="math">\(\rightarrow\)</span>既用于表示蕴含（例如，False <span class="math">\(\rightarrow\)</span> True），也用作函数的类型构造器（例如，<span class="math">\(\mathbb{Z} \rightarrow \mathbb{N}\)</span>）。在没有上下文的情况下，我们无法确定<span class="math">\(a \rightarrow b\)</span>是指具有定义域<span class="math">\(a\)</span>和陪域<span class="math">\(b\)</span>的函数的类型，还是指命题“a蕴含<span class="math">\(b\)</span>”。</p>

<div class="math">$$
\text { PAT }=\text { propositions as types } \quad \text { PAT }=\text { proofs as terms }
$$</div>
<p>事实证明，这两个概念不仅看起来相同，它们实际上是相同的。这被称为PAT原则，其中PAT是一个双重助记符：</p>
<p>此外，因为类型也是项，这也意味着命题是项。然而，PAT 并不是一个四重助记符（-PAT—proofs as types）。还要注意，并非所有类型都是命题，也并非所有项都是证明。</p>
<p>通过使用项和类型来表示证明和命题，依赖类型理论实现了概念上的显著简化。问题“H 是 P 的证明吗？”等价于“项 H 是否具有类型 P？”。因此，在 Lean 内部，没有证明检查器，只有类型检查器。证明由类型检查器进行验证。</p>
<p>让我们逐一回顾这些角色。我们使用数学变量<span class="math">\(\sigma, \tau\)</span>表示类型；<span class="math">\(P, Q\)</span>表示命题；<span class="math">\(t, u, x\)</span>表示项；<span class="math">\(h, G, H\)</span>表示证明。</p>
<p>从“命题即类型”开始，对于类型，我们有以下内容：</p>
<ul>
<li>
<span class="math">\(\sigma \rightarrow \tau\)</span> 是从 <span class="math">\(\sigma\)</span> 到 <span class="math">\(\tau\)</span> 的函数类型。</li>
<li>
<span class="math">\((x: \sigma) \rightarrow \tau[x]\)</span> 是从 <span class="math">\(x: \sigma\)</span> 到 <span class="math">\(\tau[x]\)</span> 的依赖类型。</li>
</ul>
<p>相比之下，对于命题，我们有以下内容：</p>
<ul>
<li>
<span class="math">\(P \rightarrow Q\)</span>可以理解为“P蕴含<span class="math">\(Q\)</span>”，或者作为将<span class="math">\(P\)</span>的证明映射到<span class="math">\(Q\)</span>的证明的函数类型。</li>
<li>
<span class="math">\(\forall x: \sigma, Q[x]\)</span>可以理解为“对于所有<span class="math">\(x, Q[x]\)</span>”，或者作为类型为<span class="math">\((x: \sigma) \rightarrow Q[x]\)</span>的函数类型，将类型为<span class="math">\(\sigma\)</span>的值<span class="math">\(x\)</span>映射到<span class="math">\(Q[x]\)</span>的证明。继续“证明作为项”，对于项，我们有以下内容：</li>
<li>常量是一个项。</li>
<li>变量是一个项。</li>
<li>
<span class="math">\(t u\)</span>是将函数<span class="math">\(t\)</span>应用于参数<span class="math">\(u\)</span>。</li>
<li>fun <span class="math">\(x \mapsto t[x]\)</span>是一个将<span class="math">\(x\)</span>映射到<span class="math">\(t[x]\)</span>的函数。</li>
</ul>
<p>相比之下，对于证明（即证明项），我们有以下内容：</p>
<ul>
<li>定理或假设的名称是一个证明。</li>
<li>H t，它将证明H的语句中的前导<span class="math">\(\forall\)</span>量词用项<span class="math">\(t\)</span>实例化，是一个证明。</li>
<li>H G，它用证明G解除H的语句中的前导假设，是一个证明。此操作称为假言推理。</li>
<li>fun <span class="math">\(h: P \mapsto H[h]\)</span> 是<span class="math">\(P \rightarrow Q\)</span>的证明，假设<span class="math">\(H[h]\)</span>是对所有<span class="math">\(h: P\)</span>的<span class="math">\(Q\)</span>的证明。</li>
<li>fun <span class="math">\(x: \sigma \mapsto H[x]\)</span> 是<span class="math">\(\forall x: \sigma, Q[x]\)</span>的证明，假设<span class="math">\(H[x]\)</span>是对所有<span class="math">\(x: \sigma\)</span>的<span class="math">\(Q[x]\)</span>的证明。最后两种情况由Fun'规则证明。在结构化证明中，与原始证明项不同，我们会写assume或fix而不是fun，并且为了可读性，我们可能会使用show重复结论，如下所示：</li>
</ul>
<pre><code>theorem case_4 :
    \(P \rightarrow Q:=\)
    assume \(h: P\)
    show \(Q\) from
        \(H[h]\)
</code></pre>
<p>定理 case_5 :
<span class="math">\(\forall x: \sigma, Q[x]:=\)</span>
固定 <span class="math">\(x: \tau\)</span>
展示 <span class="math">\(Q[x]\)</span> 由
<span class="math">\(H[x]\)</span></p>
<p>依赖类型理论的术语可能相当令人困惑，因为某些词具有狭义和广义的含义。下图捕捉了重要词汇的各种含义：</p>
<p><img src="img-4.jpeg" alt="img-4.jpeg"></p>
<p>在广义上，任何表达式都是一个项，任何可能出现在类型判断右侧的表达式都是一个类型，而任何可能出现在类型判断右侧且左侧有一个类型的表达式都是一个宇宙。这与将<span class="math">\(t: u\)</span>解读为“<span class="math">\(t\)</span>具有类型<span class="math">\(u\)</span>”以及宇宙是类型的类型的概念是一致的。</p>
<p>根据PAT原则，一些Lean命令有两个名称，但本质上是相同的。例如fix和assume；实际上，它们都是fun的LoVelib别名。还有一些行为略有不同的命令对，如def/theorem和let/have。根本的区别在于：当我们定义某个函数或数据时，我们不仅关心类型，还关心主体——即行为。另一方面，一旦我们证明了一个定理，证明本身就不再重要。重要的是存在一个证明。我们将在第12章回到证明无关性的主题。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">Tactical proof</th>
  <th style="text-align:left">Structured proof</th>
  <th style="text-align:left">Raw proof term</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">intro <span class="math">\(x\)</span>
</td>
  <td style="text-align:left">fix <span class="math">\(x: \tau\)</span>
</td>
  <td style="text-align:left">fun <span class="math">\(x \mapsto\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">intro <span class="math">\(h\)</span>
</td>
  <td style="text-align:left">assume <span class="math">\(h: P\)</span>
</td>
  <td style="text-align:left">fun <span class="math">\(h \mapsto\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">have <span class="math">\(k:=H\)</span>
</td>
  <td style="text-align:left">have <span class="math">\(k:=H\)</span>
</td>
  <td style="text-align:left">(fun <span class="math">\(k \mapsto \ldots) H\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">let <span class="math">\(x:=t\)</span>
</td>
  <td style="text-align:left">let <span class="math">\(x:=t\)</span>
</td>
  <td style="text-align:left">(fun <span class="math">\(x \mapsto \ldots) t\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">exact <span class="math">\((H: P)\)</span>
</td>
  <td style="text-align:left">show <span class="math">\(P\)</span> from <span class="math">\(H\)</span>
</td>
  <td style="text-align:left"><span class="math">\(H: P\)</span></td>
</tr>
<tr>
  <td style="text-align:left">calc</td>
  <td style="text-align:left">calc</td>
  <td style="text-align:left">calc</td>
</tr>
</tbody>
</table>
<p>下表总结了战术证明、结构化证明和原始证明项之间的区别：</p>
<p>请注意，<span class="math">\(x:=t\)</span> 后跟 <span class="math">\(u\)</span> 本质上是书写 (fun <span class="math">\(x \mapsto u\)</span> ) <span class="math">\(t\)</span> 的一种方式，只是 <span class="math">\(\beta\)</span>-归约被禁用了。</p>
<h3>4.8 基于模式匹配和递归的归纳法</h3>
<p>在3.6节中，我们回顾了使用归纳策略进行归纳证明的方法。另一种更灵活的风格依赖于模式匹配和PAT原则。</p>
<pre><code>def reverse \(\{\alpha\) : Type \} : List \(\alpha \rightarrow\) List \(\alpha\)
    | [] \(\Rightarrow\) []\(x:: x s=&gt;\) reverse \(x s++[x]\)
</code></pre>
<p>回忆一下第2.2.3节末尾关于列表反转的定义：</p>
<pre><code>theorem reverse_append \(\{\alpha\) : Type \} :
    \(\forall x s\) ys : List \(\alpha\),
        reverse \((x s++y s)=\) reverse ys ++ reverse xs
    | [], ys =&gt; by simp [reverse]
    | x :: xs, ys =&gt; by simp [reverse, reverse_append xs]
</code></pre>
<p>事实上，reverse 作为 List.reverse 存在于 Lean 的标准库中，具有更高效但不太方便用于推理的定义。一个需要证明的有用性质是，reverse 是其自身的逆：对于所有列表 xs，reverse (reverse <span class="math">\(x s\)</span> ) = xs。然而，如果我们尝试通过归纳法来证明它，很快就会遇到一个障碍。归纳步骤是
ih : <span class="math">\(\forall x s\)</span>, reverse (reverse <span class="math">\(x s\)</span> ) = xs <span class="math">\(\vdash\)</span> reverse (reverse <span class="math">\(x s++[x]\)</span> ) = x : : xs
注意到在双 reverse 的“三明治”中出现了不愉快的 <span class="math">\(++[x]\)</span>。我们需要一种方法来将外部的 reverse “分配”到 ++ 上，以获得一个与归纳假设左侧匹配的项。技巧是证明并使用以下定理：</p>
<p>该定理的证明看起来更像是一个递归函数的定义，而不是一个证明。左边的模式，[]和<span class="math">\(x\)</span> : : xs，对应于<span class="math">\(\forall\)</span>量化的变量<span class="math">\(x\)</span> s的两个构造函数。在每个=&gt;符号的右边是对应情况的证明。我们可以进行模式匹配的变量是那些出现在<span class="math">\(\forall\)</span>量词中的变量，按出现顺序排列（这里是<span class="math">\(x\)</span> s和<span class="math">\(y\)</span> s）。在归纳步骤的证明中，归纳假设以与我们所证明的定理（reverse_append）相同的名称可用。</p>
<p>我们显式地将<span class="math">\(x s\)</span>作为参数传递给归纳假设。这限制了假设，使其仅适用于<span class="math">\(x\)</span> s，而不适用于其他列表。特别是，这确保了定理不会被应用于<span class="math">\(x\)</span> : : <span class="math">\(x\)</span> s，否则可能导致循环证明：“为了证明reverse_append ( <span class="math">\(x\)</span> : : xs)，使用reverse_append ( <span class="math">\(x\)</span> : : xs )。” Lean的终止检查器会注意到证明是不成立的并引发错误，但我们希望避免这种情况。此外，显式的参数xs作为文档也很有用，有效地表明：“我们需要的唯一递归定理实例是关于xs的。”</p>
<pre><code>theorem reverse_append_tactical {x : Type} (xs ys : List }\alpha\mathrm{ ) :
    reverse (xs ++ ys) = reverse ys ++ reverse xs :=
    by
        induction xs with
        | nil =&gt; simp [reverse]
        | cons x xs' ih =&gt; simp [reverse, ih]
</code></pre>
<p>作为参考，战术证明如下：</p>
<p>如果我们将[y]代替ys，定理仍然可以证明并且有用。但是，尽可能普遍地陈述定理是一个好习惯。这会导致更可重用的库。此外，这在通过归纳法证明时，通常需要获得足够强的归纳假设。一般来说，找到正确的归纳法和定理可能需要思考和创造力。</p>
<pre><code>theorem name (params \(\left.{ }_{1}: \operatorname{type}_{1}\right) \ldots\left(\right.\) params \(_{n}:\) type \(_{m}\) ) :
    statement
    | patterns \(_{1}=&gt;\) proof \(_{1}\)
        \vdots
    | patterns \(_{n}=&gt;\) proof \(_{n}\)
</code></pre>
<p>支持对多个变量进行同时模式匹配（例如上面的xs和ys）。模式之间用逗号分隔。一般格式为</p>
<p>请注意与def语法（第2.2节）的强烈相似性。事实上，这两个命令几乎相同，但theorem将定义的项或证明视为不透明的，而def则保持其透明性。由于一旦定理被证明（第12节），实际的证明就无关紧要了，因此无需在以后展开它们。let和have之间也存在类似的区别。</p>
<p>根据PAT原则，通过模式匹配和递归进行的归纳证明与递归证明项是相同的。当我们调用归纳假设时，实际上就是在递归地调用一个递归函数。这解释了为什么归纳假设与我们证明的定理具有相同的名称。Lean的终止检查器用于确立归纳证明的良基性。</p>
<pre><code>theorem reverse_reverse \(\{\alpha\) : Type \} :
    \(\forall x s\) : List \(\alpha\), reverse (reverse \(x s)=x s\)
    | [] \(\quad=&gt;\) by rfl
    \(\mid x:: x s=&gt;\)
    by simp [reverse, reverse_append, reverse_reverse xs]
</code></pre>
<p>有了reverse_append定理，我们可以回到最初的目标：</p>
<p>通过模式匹配和递归进行归纳在Lean用户中很受欢迎。其主要优点是方便的语法以及对良基归纳的支持，这比由归纳策略提供的结构归纳更强大（第3.7节）。然而，在本指南中，我们不需要良基归纳的全部功能。此外，由于一些微妙的逻辑原因，模式匹配和递归归纳不适用于归纳谓词，这是第6章的主题。出于这些原因，我们通常会优先使用归纳策略。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">assume</th>
  <th style="text-align:left">states assumptions</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">calc</td>
  <td style="text-align:left">combines proofs by transitivity</td>
</tr>
<tr>
  <td style="text-align:left">fix</td>
  <td style="text-align:left">fixes variables</td>
</tr>
<tr>
  <td style="text-align:left">have</td>
  <td style="text-align:left">states an intermediate theorem</td>
</tr>
<tr>
  <td style="text-align:left">let</td>
  <td style="text-align:left">introduces a local definition</td>
</tr>
<tr>
  <td style="text-align:left">show</td>
  <td style="text-align:left">states the target</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
  <th style="text-align:left">calc</th>
  <th style="text-align:left">combines proofs by transitivity</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">have</td>
  <td style="text-align:left">states an intermediate theorem</td>
</tr>
<tr>
  <td style="text-align:left">let</td>
  <td style="text-align:left">introduces a local definition</td>
</tr>
</tbody>
</table>
<h3>4.9 新引入的Lean结构总结</h3>
<h4>证明命令</h4>
<h4>策略</h4>
<h1>第二部分：函数逻辑编程</h1>
<h2>第五章：函数式编程</h2>
<p>我们将更深入地探讨类型化函数式编程的本质：归纳类型、归纳证明、递归函数、模式匹配、结构（记录）和类型类。这里涉及的概念在《Lean 4中的定理证明》第7至10章中有更详细的描述。</p>
<h3>5.1 归纳类型</h3>
<p>归纳类型是仿照类型化函数式编程语言（例如，Haskell、ML、OCaml）中的数据类型建模的。它们也让人联想到Scala中的密封类。在第2章中，我们看到了一些基本的归纳类型：自然数、算术表达式类型和有限列表。在本章中，我们将重新审视列表并研究二叉树。我们还将简要介绍长度为<span class="math">\(n\)</span>的向量，这是一种依赖类型。</p>
<pre><code>inductive Nat : Type where
    | zero : Nat
    | succ : Nat \(\rightarrow\) Nat
</code></pre>
<p>回顾自然数作为归纳类型的定义：</p>
<p>这定义了类型Nat以及两个常量Nat.zero和Nat.succ，称为构造函数。该定义还断言了构造函数的一些属性。此外，它还引入了进一步用于内部支持归纳和递归的常量。</p>
<p>正如我们在第2.1节中所看到的，归纳类型是一种类型，其成员都是通过其构造函数的有限次应用构建的所有值，且仅包含这些值。其宗旨如下：</p>
<ul>
<li>无冗余：该类型不包含无法通过构造函数表示的值。</li>
<li>无混淆：使用不同构造函数组合构建的值是不同的。</li>
</ul>
<p>对于自然数，“无冗余”意味着没有特殊值（如<span class="math">\(-1, c, \infty\)</span>或NAN）无法通过有限次使用Nat.zero和Nat.succ的组合来表示，而“无混淆”确保对于所有n，Nat.zero <span class="math">\(\neq\)</span> Nat.succ n，并且Nat.succ是单射的。此外，归纳类型的值总是有限的。无限项</p>
<p>Nat.succ (Nat.succ (Nat.succ (Nat.succ ...))) 不是一个值。也不存在一个值 <span class="math">\(n\)</span> 使得 Nat.succ <span class="math">\(n=n\)</span>，正如我们将在下面展示的那样。</p>
<p>归纳类型非常方便使用，因为它们支持归纳和递归，并且它们的构造函数行为良好，但并非所有类型都可以定义为归纳类型。特别是，诸如<span class="math">\(\mathbb{Q}\)</span>（有理数）和<span class="math">\(\mathbb{R}\)</span>（实数）这样的数学类型需要基于商类型和子类型的更复杂的构造。这将在第12章和第14章中解释。</p>
<div class="math">$$
\begin{gathered}
\vdash P[\varnothing] \\
k: \mathbb{N}, i h: P[k] \vdash P[k+1]
\end{gathered}
$$</div>
<h3>5.2 结构归纳法</h3>
<p>结构归纳法是数学归纳法对任意归纳类型的推广。要通过结构归纳法证明目标<span class="math">\(n: \mathbb{N} \vdash P[n]\)</span>，只需证明两个子目标，传统上称为基础情况和归纳步骤：</p>
<div class="math">$$
h Q: Q, n: \mathbb{N}, h R: R[n] \vdash S[n]
$$</div>
<p>当然，我们也可以使用 Nat. zero 和 Nat. succ k 来代替 <span class="math">\(\varnothing\)</span> 和 <span class="math">\(k+1\)</span>。一般情况下，情况会更加复杂。目标可能包含一些不依赖于 <span class="math">\(n\)</span> 的额外假设（例如 Q），以及其他依赖于 <span class="math">\(n\)</span> 的假设（例如 <span class="math">\(R[n]\)</span>）。假设我们每种假设各有一个，这将给出初始目标</p>
<div class="math">$$
\begin{gathered}
h Q: Q, h R: R[\varnothing] \vdash S[\varnothing] \\
h Q: Q, k: \mathbb{N}, i h: R[k] \rightarrow S[k], h R: R[k+1] \vdash S[k+1]
\end{gathered}
$$</div>
<p>对<span class="math">\(n\)</span>进行结构归纳后，会产生两个子目标</p>
<p>假设<span class="math">\(Q\)</span>直接从初始目标中保持不变地继承下来，而<span class="math">\(R[n] \vdash S[n]\)</span>的处理方式几乎与目标为<span class="math">\(R[n] \rightarrow\)</span> <span class="math">\(S[n]\)</span>时相同。这可以通过在上述第一个例子中取<span class="math">\(P[n]:=R[n] \rightarrow S[n]\)</span>来轻松验证。由于这种通用格式非常冗长且信息量有限（既然我们已经理解了它的工作原理），从现在开始，我们将以最简单的形式呈现目标，不再包含额外的假设。</p>
<div class="math">$$
\begin{gathered}
\vdash P[[]] \\
y: \alpha, y s: \text { list } \alpha, i h: P[y s] \vdash P[y:: y s]
\end{gathered}
$$</div>
<p>对于列表，给定目标<span class="math">\(x s\)</span> : list <span class="math">\(\alpha \vdash P[x s]\)</span>，对<span class="math">\(x s\)</span>进行结构归纳得到</p>
<p>我们当然也可以写成List.nil和List.cons y ys。由于<span class="math">\(y\)</span>不是列表类型，因此没有与<span class="math">\(y\)</span>相关的归纳假设。</p>
<div class="math">$$
i: \mathbb{Z} \vdash P[A E x p . n u m ~ i] \quad x: \text { String } \vdash P[A E x p . v a r ~ x]
$$</div>
<p>对于算术表达式，基本情况是</p>
<pre><code>\(\mathrm{e}_{1} \mathrm{e}_{2}:\) AExp, ih \(_{1}: \mathrm{P}\left[\mathrm{e}_{1}\right]\), ih \(_{2}: \mathrm{P}\left[\mathrm{e}_{2}\right] \vdash \mathrm{P}\left[\mathrm{AExp} . \mathrm{add} \mathrm{e}_{1} \mathrm{e}_{2}\right]\)
\(e_{1} e_{2}:\) AExp, ih \(_{1}: \mathrm{P}\left[\mathrm{e}_{1}\right]\), ih \(_{2}: \mathrm{P}\left[\mathrm{e}_{2}\right] \vdash \mathrm{P}\left[\mathrm{AExp} . \operatorname{sub} \mathrm{e}_{1} \mathrm{e}_{2}\right]\)
\(e_{1} e_{2}:\) AExp, ih \(_{1}: \mathrm{P}\left[\mathrm{e}_{1}\right]\), ih \(_{2}: \mathrm{P}\left[\mathrm{e}_{2}\right] \vdash \mathrm{P}\left[\mathrm{AExp} . \mathrm{mul} \mathrm{e}_{1} \mathrm{e}_{2}\right]\)
</code></pre>
<p>归纳步骤为</p>

<p>注意关于<span class="math">\(e_{1}\)</span>和<span class="math">\(e_{2}\)</span>的两个归纳假设。通常，结构归纳法会为每个构造函数生成一个子目标。在每个子目标中，归纳假设可用于我们正在进行归纳的类型的所有构造函数参数。</p>

<p>给定一个归纳类型<span class="math">\(\tau\)</span>，计算子目标的过程始终相同：</p>
<ol>
<li>将<span class="math">\(\mathrm{P}[\mathrm{]}\)</span>中的空洞替换为每个可能的构造函数应用于新变量（例如，<span class="math">\(y\)</span> : : ys），产生与构造函数数量相同的子目标。</li>
<li>将这些新变量（例如，<span class="math">\(y\)</span>, ys）添加到局部上下文中。</li>
<li>为所有类型为<span class="math">\(\tau\)</span>的新变量添加归纳假设。</li>
</ol>
<p>作为一个例子，我们将证明对于所有的<span class="math">\(\mathrm{n}: \mathbb{N}\)</span>，Nat. succ <span class="math">\(\mathrm{n} \neq \mathrm{n}\)</span>。我们从一个非正式的证明开始：</p>
<p>证明通过对<span class="math">\(n\)</span>的结构归纳进行。情况0：我们需要证明Nat.succ <span class="math">\(\circ \neq \circ\)</span>。这由归纳类型构造函数的“无混淆”性质得出。情况Nat.succ k：归纳假设为Nat.succ <span class="math">\(\mathrm{k} \neq \mathrm{k}\)</span>。我们需要证明Nat.succ (Nat.succ k) <span class="math">\(\neq\)</span> Nat.succ k。根据Nat.succ的单射性，我们有Nat.succ (Nat.succ k) = Nat.succ k等价于Nat.succ <span class="math">\(k=k\)</span>。因此，只需证明Nat.succ <span class="math">\(k \neq k\)</span>，这正好对应于归纳假设。</p>
<p>请注意这个非正式证明的主要特点，你在自己的非正式论证中应该力求重现这些特点：</p>
<ul>
<li>证明开始时明确宣布了我们要进行的证明类型（例如，哪种归纳法以及在哪个变量上）。</li>
<li>各个案例被明确标识，并且对于每个案例，都陈述了目标及其假设。</li>
<li>证明所依赖的关键定理被明确引用（例如，Nat.succ的注入性）。现在让我们在Lean中进行证明：</li>
</ul>
<pre><code>theorem Nat.succ_neq_self ( \(\mathrm{n}: \mathbb{N}\) ) :
    Nat.succ \(\mathrm{n} \neq \mathrm{n}:=\)
    by
    induction n with
    | zero \(\quad=&gt;\) simp
    | succ n' ih =&gt; simp [ih]
</code></pre>
<p>关于构造函数的常规推理全部由simp完成。</p>
<pre><code>def fact : N -&gt; N
    | 0 =&gt; 0
    | n + 1 =&gt;(n + 1)* fact n
</code></pre>
<h3>5.3 结构递归</h3>
<p>结构递归是一种递归形式，它允许我们从递归的值中剥离一个构造器。下面的阶乘函数是结构递归的：</p>
<p>在这里我们剥离的构造函数是 Nat. succ（写作 + 1）。这类函数保证在递归停止之前只会有限次地调用自身；例如，fact 12345 将调用自身 12345 次。该函数被称为终止函数。这一特性有助于确保逻辑一致性。</p>
<pre><code>def factThreeCases : N -&gt; N
    | 0 =&gt; 0
    | 1 =&gt; 1
    | n + 1 =&gt;(n + 1)* factThreeCases n
</code></pre>
<p>在结构递归中，方程的数量与构造函数的数量相同。新手常常会倾向于提供额外的、冗余的情况，如下例所示：</p>
<p>抵制这种诱惑符合你自己的最佳利益。定义中的情况越多，推理它们的工作量就越大。请记住一句格言：一个好的定义抵得上三个定理。</p>
<pre><code>-- fails
def illegal : N -&gt; N
    | n =&gt; illegal n + 1
</code></pre>
<p>对于结构递归函数，Lean 可以自动证明终止性。对于更一般的递归模式，终止检查可能会失败。有时这是有充分理由的，如下例所示：</p>
<p>如果Lean接受了这个定义，我们就可以利用它来证明<span class="math">\(\circ=1\)</span>，方法是从等式<span class="math">\(n=\)</span>非法<span class="math">\(n+1\)</span>的两边减去非法的<span class="math">\(n\)</span>。从<span class="math">\(\circ=1\)</span>出发，我们可以推导出False，而从False出发，我们可以推导出任何结论。显然，我们不希望这种情况发生。</p>
<pre><code>opaque immoral : N -&gt; N
axiom immoral_eq (n : N) :
    immoral n = immoral n + 1
theorem proof_of_False :
    False :=
    have hi : immoral }\circ\mathrm{ = immoral }\circ+1\mathrm{ :=
    immoral_eq 0
    have him :
    immoral }\circ\mathrm{ - immoral }\circ\mathrm{ = immoral }\circ+1\mathrm{-immoral }\circ\mathrm{ :=
    by rw [+-hi]
    have h@eq1 : }\circ\mathrm{ = 1 :=

    by simp at him
show False from
    by simp at hoeq1
</code></pre>
<p>如果我们使用了不透明和公理，那么没有什么能拯救我们：</p>
<p>相较于opaque和axiom，更倾向于使用def的另一个原因是定义方程可以用于计算。每次引入定义时，诸如rfl这样在计算上统一的策略会变得更强大，并且诊断命令#eval和#reduce可以用于定义的常量。</p>
<p>细心的读者会注意到，上述阶乘的定义在数学上是错误的：无论参数是什么，fact和factThreeCases都惊人地返回0。我们简直是把阶乘搞砸了。这些令人尴尬的错误提醒我们要测试我们的定义并证明它们的一些属性。尽管有缺陷的公理偶尔会出现，但更常见的是未能捕捉到预期概念的定义。仅仅因为一个函数被称为fact，并不意味着它实际上计算了阶乘。</p>
<pre><code>match \(\operatorname{term}_{1}, \ldots, \operatorname{term}_{n}\) with
    | pattern \(_{11}, \ldots\), pattern \(_{1 m} \Rightarrow\) result \(_{1}\)
        \(\vdots\)
    | pattern \(_{n 1}, \ldots\), pattern \(_{n m} \Rightarrow\) result \(_{n}\)
</code></pre>
<h3>5.4 模式匹配表达式</h3>
<p>模式匹配不仅可以在def命令的顶层进行，还可以通过match表达式在项的内部深层进行。该构造具有以下通用语法：</p>
<p>这种结构让人联想到一些现代编程语言中的匹配功能。上述匹配表达式的英文翻译如下：</p>
<p>考虑项 term <span class="math">\(_{1}, \ldots\)</span>, term <span class="math">\(_{n}\)</span>。如果它们分别符合模式 pattern <span class="math">\(_{11}, \ldots\)</span>, pattern <span class="math">\(_{1 m}\)</span>，则生成结果 result <span class="math">\(_{1}\)</span>。</p>
<p>如果它们分别是形式模式<span class="math">\(_{n 1}, \ldots\)</span>，模式<span class="math">\(_{n m}\)</span>，则生成结果<span class="math">\(_{n}\)</span>。</p>
<p>模式可能包含变量、构造函数和无名占位符（<em>）。结果${ }</em>{1}$表达式可以引用相应模式中引入的变量。</p>
<pre><code>def bcount { }\alpha\mathrm{ : Type} (p : \alpha -&gt; Bool) : List \alpha -&gt; N
    | [] =&gt; 0
    | x :: xs =&gt;
        match p x with
        | true =&gt; bcount p xs + 1
        | false =&gt; bcount p xs
</code></pre>

<p>以下函数定义展示了表达式中模式匹配的语法：</p>


<p>bcount函数用于计算列表中满足给定谓词<span class="math">\(p\)</span>的元素数量。谓词的陪域为Bool类型。作为一般规则，我们将在程序中使用布尔类型Bool，而在陈述程序属性时使用命题类型Prop。Bool类型的两个值称为false和true（小写）。<span class="math">\({ }^{1}\)</span> 连接词称为或（中缀：||）、与（中缀：88）和非（前缀：!）。</p>

<p>下图展示了Bool和Prop的解释：</p>
<p><img src="img-5.jpeg" alt="img-5.jpeg"></p>
<p>点表示元素，圆圈表示类型，矩形表示类型的类型，或称为宇宙。我们看到Bool被解释为具有两个值的集合，而Prop由无限数量的命题（即类型）组成，每个命题有零个或多个证明（即元素）。我们将在第6章中完善这一图示。</p>
<pre><code>def min (a b : N) : N :=
    if a \leq b then a else b
</code></pre>
<p>我们无法对命题（类型为Prop）进行匹配，但可以使用if-thenelse来代替。例如，自然数上的min操作符可以定义如下：</p>
<p>这需要一个可判定的（即可执行的）命题。对于<span class="math">\(\leq\)</span>来说就是这种情况：给定具体参数如35和49，Lean可以将<span class="math">\(35 \leq 49\)</span>简化为True。Lean使用一种称为类型类的机制来跟踪可判定性，这将在下面解释。</p>
<h3>5.5 结构体</h3>
<p>Lean 提供了一种便捷的语法来定义结构体（也称为记录）。这些本质上是一些带有语法糖的非递归单构造器归纳类型。</p>
<pre><code>structure RGB where
    red : N
    green : N
    blue : N
</code></pre>
<p>以下定义引入了一个名为RGB的结构，其中包含三个类型为N的字段，分别称为red、green和blue：</p>
<pre><code>inductive RGB : Type where
    | mk : N -&gt; N -&gt; N -&gt; RGB

def RGB.red : RGB \(\rightarrow\) N
    | RGB.mk r _ _ =&gt; r
def RGB.green : RGB \(\rightarrow\) N
    | RGB.mk _ g _ =&gt; g
def RGB.blue : RGB \(\rightarrow\) N
    | RGB.mk _ _ b =&gt; b
</code></pre>
<p>此定义与以下命令大致具有相同的效果：</p>
<pre><code>structure RGBA extends RGB where
    alpha : N
</code></pre>
<p>我们可以将新结构定义为现有结构的扩展。以下定义通过添加第四个字段（称为alpha）扩展了RGB：</p>
<pre><code>structure structure-name (params 1 : type 1 ) ... (params 12 : type 1
    [extends structure \(_{1}, \ldots\), structure \(_{n}\) ] where
    field-name \(_{1}\) : field-type \(_{1}\)
        \vdots
    field-name \(_{n}\) : field-type \(_{n}\)
</code></pre>
<p>定义结构的通用语法为</p>
<p>参数params <span class="math">\(_{1}, \ldots\)</span>, params <span class="math">\(_{k}\)</span>实际上是额外的字段，但与字段名称 <span class="math">\(_{1}, \ldots\)</span>, 字段名称 <span class="math">\(_{n}\)</span>不同，它们存储在类型中，作为类型构造函数（结构名称）的参数。</p>
<pre><code>def pureRed : RGB :=
    RGB.mk oxff oxoo oxoo
def pureGreen : RGB :=
    { red := oxoo
        green := oxff
        blue := oxoo }
def semitransparentGreen : RGBA :=
    { pureGreen with
        alpha := ox7f }
</code></pre>
<p>值可以用多种语法指定：</p>
<p>semitransparentGreen 的定义从 pureGreen 复制了所有值，除了 alpha 字段，该字段被显式设置。</p>
<pre><code>def shuffle (c : RGB) : RGB :=
    { red := RGB.green c
        green := RGB.blue c
        blue := RGB.red c }
</code></pre>
<p>接下来，我们定义一个名为shuffle的操作：</p>
<pre><code>theorem shuffle_shuffle_shuffle (c : RGB) :
    shuffle (shuffle (shuffle c)) = c :=
    by rfl
</code></pre>
<p>该定义依赖于生成的选取器RGB.red、RGB.green和RGB.blue。我们可以用c.red来代替RGB.red c，其他字段也类似。有时我们会在Lean的输出中看到这种表示法，即使我们自己不使用它。连续应用三次shuffle操作与完全不应用它效果相同：</p>
<h3>5.6 类型类</h3>
<p>类型类是一种由Haskell推广的机制，并在多个证明助手中存在。在Lean中，类型类是一种结合了抽象常量及其属性的结构类型。<span class="math">\({ }^{2}\)</span> 通过为常量提供具体定义并证明属性成立，可以将一个类型声明为类型类的实例。基于类型，Lean会检索相关的实例。</p>
<pre><code>class Inhabited ( }\alpha\mathrm{ : Type) : Type where
    default : }\alpha
</code></pre>
<p>一个简单的例子是类型类Inhabited，它只需要一个常量Inhabited.default，而不需要任何属性：</p>
<p>语法与结构相同，只是用关键字class代替了structure。参数<span class="math">\(\alpha\)</span>表示可以是该类成员的任意类型。这个特定的类型类有一个参数和一个字段，但通常一个类型类可以有多个参数和多个字段。</p>
<pre><code>instance Nat.Inhabited : Inhabited N :=
    { default := 0 }
</code></pre>
<p>任何至少包含一个元素的类型都可以注册为Inhabited类型类的实例。例如，我们可以通过选择一个任意数字作为默认值来注册<span class="math">\(\mathbb{N}\)</span>：</p>
<p>这指定了一个名为 Nat.Inhabited 的值，其类型为 Inhabited <span class="math">\(\mathbb{N}\)</span>。由于我们使用关键字 instance 而不是 def，该结构值被注册为规范实例，每当需要类型为 Inhabited <span class="math">\(\mathbb{N}\)</span> 的结构时，都会使用该实例。在存储类型类实例的全局表中，现在有一个条目</p>
<pre><code>instance List.Inhabited { }\alpha\mathrm{ : Type} : Inhabited (List }\alpha\mathrm{ :=
    { default := [] }
</code></pre>
<p>可居住的 <span class="math">\(\mathbb{N} \mapsto\)</span> 自然数. 可居住的 对于列表来说，空列表是一个明显的默认值，即使 <span class="math">\(\alpha\)</span> 不可居住，也可以构造出来：</p>
<div class="math">$$
\text { Inhabited (List ? } \alpha \text { ) } \mapsto \text { List. Inhabited }
$$</div>
<p>这将以下条目添加到全局表中：</p>
<p>作为一个例子，注意到类型为 <span class="math">\(\alpha \rightarrow \beta\)</span> 的有限函数可以通过它们的函数表来表示，其类型为 <span class="math">\(\beta \times \cdots \times \beta\)</span>（有 <span class="math">\(|\alpha|\)</span> 个 <span class="math">\(\beta\)</span> 的副本）。因此，<span class="math">\(|\alpha \rightarrow \beta|=|\beta|^{|\alpha|}\)</span>。为了使这个 <span class="math">\(\theta\)</span> 成立，我们必须同时满足 <span class="math">\(|\beta|=\theta\)</span> 和 <span class="math">\(|\alpha| \neq \theta\)</span>。换句话说，类型 <span class="math">\(\alpha \rightarrow \beta\)</span> 是可居的，如果 (1) <span class="math">\(\beta\)</span> 是可居的，或者 (2) <span class="math">\(\alpha\)</span> 是不可居的。我们重点关注情况 (1)：</p>
<p>实例 Fun.Inhabited <span class="math">\(\{\alpha \beta\)</span> : 类型 <span class="math">\(\}\)</span> [Inhabited <span class="math">\(\beta]\)</span> : Inhabited <span class="math">\((\alpha \rightarrow \beta):=\)</span> { 默认 := fun a : <span class="math">\(\alpha \mapsto\)</span> Inhabited.default }  
该实例依赖于同一类型类但不同类型的实例。这种情况经常发生。</p>
<pre><code>instance Prod.Inhabited \(\{\alpha \beta\) : Type \}
    [Inhabited \(\alpha]\) [Inhabited \(\beta]\) :
Inhabited \((\alpha \times \beta):=\)
\{ default := (Inhabited.default, Inhabited.default) \}
</code></pre>
<p>类型 <span class="math">\(\alpha \times \beta\)</span> 的配对，也称为积类型，包含形式为 <span class="math">\((a, b)\)</span> 的值，其中 <span class="math">\(a: \alpha\)</span> 且 <span class="math">\(b: \beta\)</span>。给定一个配对 <span class="math">\(a b: \alpha \times \beta\)</span>，可以通过写入 Prod.fst ab 和 Prod.snd ab 来提取第一个和第二个组件。为了提供 <span class="math">\(\alpha \times \beta\)</span> 的居民，我们需要同时拥有 <span class="math">\(\alpha\)</span> 和 <span class="math">\(\beta\)</span> 的居民：</p>
<pre><code>def head { }\alpha\mathrm{ : Type} [Inhabited }\alpha\mathrm{ ] : List }\alpha\mathrm{ \rightarrow }\alpha
    | [] =&gt; Inhabited.default
    | x :: _ =&gt; x
</code></pre>
<p>使用Inhabited类型类，我们可以定义列表的head操作：即返回列表第一个元素的函数。由于空列表不包含任何元素，因此在那种情况下没有有意义的值可以返回。给定一个属于Inhabited类型类的类型，我们可以简单地返回默认值：</p>
<p>我们要求<span class="math">\(\alpha\)</span>属于Inhabited，通过编写[Inhabited <span class="math">\(\alpha\)</span>]来实现。这使我们能够在定义中访问Inhabited.default。</p>

<p>语法 [Inhabited <span class="math">\(\alpha\)</span> ] 添加了一个隐式参数到头部常量。但与其他隐式参数不同，Lean 会通过所有已声明的实例进行类型类搜索以确定该参数的值。因此，当运行命令时</p>

<h4>#eval head ([] : List <span class="math">\(\mathbb{N}\)</span> )</h4>
<p>Lean 将会寻找一个 Inhabited <span class="math">\(\mathbb{N}\)</span> 实例，并找到我们之前声明的 Nat.Inhabited 实例。在那个声明中，我们将默认值设置为 <span class="math">\(\theta\)</span>，因此这就是 #eval 打印的内容。如果有多个实例适用且 Lean 选择了错误的实例，我们可以使用 <span class="math">\(\square\)</span> 语法将类型类参数转换为显式参数，并提供所需的类型类实例。</p>
<div class="math">$$
\text { Inhabited.default }\{\alpha: \text { Type }\}[\text { Inhabited } \alpha]: \alpha
$$</div>
<p>让我们更仔细地看一下 Inhabited. default：</p>
<p>请注意，普通结构的选择器使用圆括号 ( )，而类型类的选择器使用方括号 [ ]。当我们使用 Inhabited. default <span class="math">\(\alpha\)</span> 来定义 head 时，Lean 在全局注册实例表和本地上下文中查找 Inhabited <span class="math">\(\alpha\)</span> 的实例。全局表中包含 Inhabited <span class="math">\(\mathbb{N}\)</span> 的条目，但没有匹配 Inhabited <span class="math">\(\alpha\)</span> 的条目。另一方面，本地上下文中包含一个类型为 Inhabited <span class="math">\(\alpha\)</span> 的匿名参数，该参数可以被使用。</p>
<p>Lean的核心库与我们定义的方式完全一致地定义了List.head。实际上，几乎所有类型都是非空的（除了False这一显著例外），因此Inhabited的限制几乎不会成为问题。</p>
<p>我们可以证明关于Inhabited类型类的抽象定理，例如定理head_head { <span class="math">\(\alpha\)</span> : Type} [Inhabited <span class="math">\(\alpha\)</span> ] (xs : List <span class="math">\(\alpha\)</span> ) : head [head xs] = head xs</p>
<p>假设 [Inhabited <span class="math">\(\alpha\)</span> ] 是必要的，以便在类型为 List <span class="math">\(\alpha\)</span> 的列表上使用 head 操作符。如果我们省略这个假设，Lean 会抛出一个错误，告诉我们类型类合成失败。</p>
<pre><code>class Zero ( }\alpha\mathrm{ : Type) where
    zero : }\alpha
class Neg ( }\alpha\mathrm{ : Type) where
    neg : }\alpha\mathrm{ \rightarrow }\alpha
class Add ( }\alpha\mathrm{ : Type) where
    add : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha
</code></pre>
<p>还有更多仅包含常量但不包含属性的类型类，包括</p>
<p>类 One (<span class="math">\(\alpha\)</span> : Type) 其中 one : <span class="math">\(\alpha\)</span>
类 Inv (<span class="math">\(\alpha\)</span> : Type) 其中 inv : <span class="math">\(\alpha \rightarrow \alpha\)</span>
类 Mul (<span class="math">\(\alpha\)</span> : Type) 其中 mul : <span class="math">\(\alpha \rightarrow \alpha \rightarrow \alpha\)</span></p>
<p>这些语法类型类引入了在不同上下文中具有不同语义的常量。例如，one可以代表自然数1、整数1、实数1、单位矩阵以及许多其他“一”的概念。这些类型类的主要目的是为丰富的代数类型类（群、幺半群、环、域等）层次结构奠定基础，并允许重载常见的数学符号，如<span class="math">\(* \mathrm{,}, \mathrm{,}\)</span>和-1。</p>
<p>语法类型类并未对可以声明实例的类型施加严格的限制。相比之下，语义类型类包含了一些属性，这些属性限制了给定常量的行为方式。</p>
<pre><code>class IsCommutative ( }\alpha\mathrm{ : Type) (f : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ ) where
    comm : \Ya b, f a b = f b a
class IsAssociative ( }\alpha\mathrm{ : Type) (f : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ ) where
    assoc : \Ya b c, f(f a b) c = f a(f b c)
</code></pre>
<p>在第3.6节中，我们遇到了以下语义类型类：</p>
<p>这一次，关联不是从类型到常量，而是从类型和函数到属性。Lean 并不介意这种滥用：尽管它们被称为类型类，但 Lean 的类型类非常灵活，可以用来表达各种约束。</p>
<p>从概念上讲，IsCommutative 是一个依赖于三元组（<span class="math">\(\alpha, f\)</span>, comm）的类型，IsAssociative 也是如此。<span class="math">\(f\)</span> 的类型依赖于 <span class="math">\(\alpha\)</span>，而 comm 的类型依赖于 <span class="math">\(\alpha\)</span> 和 <span class="math">\(f\)</span>。尽管它们是参数，<span class="math">\(\alpha\)</span> 和 <span class="math">\(f\)</span> 也会与 comm 一起存储。</p>
<pre><code>instance Associative_add : Std.Associative add :=
    { assoc := add_assoc }
instance Commutative_add : Std.Commutative add :=
    { comm := add_comm }
</code></pre>
<p>在3.6节中，我们将<span class="math">\(\mathbb{N}\)</span>上的加法函数注册为一个可交换且可结合的操作：</p>
<p>每当我们尝试访问@IsCommutative.comm <span class="math">\(\mathbb{N}\)</span> add时，我们会得到add_comm，同样地，对于@IsAssociative.assoc <span class="math">\(\mathbb{N}\)</span> add也是如此。ac_rfl策略会尝试查找问题中所有二元运算符的comm和assoc属性，并在这些属性存在时利用它们。</p>
<pre><code>class class-name (params_{1}: type_{1})...(params_{k}: type_{k})
    [extends structure
    constant-name : constant-type
    \vdots
    constant-name: : constant-type,
    property-name : proposition
    \vdots
    property-name : proposition
</code></pre>
<p>定义类型类的通用语法如下：</p>
<pre><code>instance instance-name : type-class arguments :=
    { constant : = definition
        \vdots
    constant \(_{n}:=\) definition \(_{n}\)
    property \(_{1}:=\operatorname{proof}_{1}\),
        \vdots
    property \(_{p}:=\operatorname{proof}_{p}\)
</code></pre>
<p>实例化类型类的通用语法如下：</p>
<h3>5.7 列表</h3>
<p>Lean 提供了丰富的有限列表函数库。在本节中，我们将回顾其中一些函数，并定义一些我们自己的函数；这些是熟悉 Lean 中函数式编程的好练习。</p>
<pre><code>theorem head_head_cases { \(\alpha\) : Type \} [Inhabited \(\alpha]\)
    (xs : List \(\alpha\) ) :
    head [head xs] = head xs :=
    by
    cases xs with
    | nil =&gt; rfl
    | cons x xs' =&gt; rfl
</code></pre>
<p>在第一个例子中，我们对一个列表进行了情况分析：</p>

<p>该证明依赖于案例分析，这是归纳法的一种相关形式。它对参数进行案例分析，但不生成归纳假设。调用cases xs将目标<span class="math">\(\vdash \mathrm{P}[\mathrm{xs}]\)</span>转化为两个子目标，<span class="math">\(\vdash \mathrm{P}[[]]\)</span>和<span class="math">\(\vdash \mathrm{P}\left[\mathrm{x}::\right.\)</span> xs']。我们也可以使用induction xs。如果你在归纳法和案例分析之间犹豫不决，你可以始终选择归纳法，然后在之后查看是否需要归纳假设——如果不需要，最好通过将归纳法替换为案例分析来记录这一事实。</p>

<pre><code>theorem head_head_match \(\{\alpha\) : Type \} [Inhabited \(\alpha]\)
    (xs : List \(\alpha\) ) :
    head [head xs] = head xs :=
match xs with
| List.nil \(\quad=&gt;\) by rfl
| List.cons x xs' =&gt; by rfl
</code></pre>
<p>在结构化证明中，我们可以使用匹配表达式来进行情况区分：</p>
<pre><code>theorem injection_example \(\{\alpha\) : Type \} (x y : \(\alpha\) ) (xs ys : List \(\alpha\) )
        \((h: x:: x s=y:: y s):\)
    \(x=y \wedge x s=y s:=\)
    by
    cases \(h\)
    simp
</code></pre>
<p>在下一个例子中，我们展示了如何利用构造函数的单射性。cases 策略使用单射性来简化两边应用了相同构造函数的等式。在下面的证明中，简化前的等式是<span class="math">\(x:: x s=y:: y s:\)</span></p>
<div class="math">$$
\vdash x=x \wedge x s=x s
$$</div>
<p>cases策略将<span class="math">\(y\)</span>替换为<span class="math">\(x\)</span>，并将<span class="math">\(y s\)</span>替换为<span class="math">\(x s\)</span>，从而生成子目标</p>
<pre><code>theorem distinctness_example \(\{\alpha\) : Type \} (y : \(\alpha\) ) (ys : List \(\alpha\) )
        \((h:[]=y::\) ys) :
        False :=
    by cases \(h\)
</code></pre>
<p>simp 可以轻松证明这一点。当构造函数不同时，cases 策略也很有用，可以检测出不可能的情况：</p>
<pre><code>def map { \(\alpha \beta\) : Type \} (f : \(\alpha \rightarrow \beta)\) : List \(\alpha \rightarrow\) List \(\beta\)
    | [] \(\quad=&gt;[]\)
    | x :: xs =&gt; f x :: map f xs
</code></pre>
<p>接下来，我们定义列表上的映射函数：一个将其参数f（本身也是一个函数）应用于集合中存储的所有元素的函数。</p>
<pre><code>def mapArgs { \(\alpha \beta\) : Type \} : \((\alpha \rightarrow \beta) \rightarrow\) List \(\alpha \rightarrow\) List \(\beta\)
    | _, [] \(\quad=&gt;[]\)
    | f, x :: xs =&gt; f x :: mapArgs f xs
</code></pre>
<p>请注意，由于<span class="math">\(f\)</span>在递归调用中不发生变化，我们将其作为整个定义的参数。另一种方式，即对于在递归调用中发生变化的参数，唯一的选择如下：</p>
<pre><code>theorem map_ident \(\{\alpha\) : Type \} (xs : List \(\alpha\) ) :
    map (fun \(x \mapsto x) x s=x s:=\)
    by
    induction xs with
    | nil =&gt; rfl
    | cons x xs' ih =&gt; simp [map, ih]
</code></pre>
<p>映射函数的一个基本属性是，如果它们的参数是恒等函数（fun <span class="math">\(x \mapsto x\)</span>），则它们不会产生任何效果：</p>
<pre><code>theorem map_comp \(\{\alpha \beta \gamma\) : Type \} (f : \(\alpha \rightarrow \beta\) ) (g : \(\beta \rightarrow \gamma\) )
        (xs : List \(\alpha\) ) :
    map g (map f xs) = map (fun \(x \mapsto g(f x)) x s:=\)
    by
        induction xs with
    | nil =&gt; rfl
    | cons x xs' ih =&gt; simp [map, ih]
</code></pre>
<p>另一个基本属性是连续的映射可以压缩成一个单一的映射，其参数是所涉及函数的组合：</p>
<pre><code>theorem map_append \(\{\alpha \beta\) : Type \} (f : \(\alpha \rightarrow \beta\) )
            (xs ys : List \(\alpha\) ) :
    map f (xs ++ ys) = map f xs ++ map f ys :=
    by
        induction xs with
    | nil =&gt; rfl
    | cons x xs' ih =&gt; simp [map, ih]
</code></pre>
<p>在引入新操作时，展示这些操作如何与其他操作结合使用是非常有用的。以下是一个示例：</p>
<p>值得注意的是，最后三个证明在文本上是完全相同的。这些都是典型的归纳-rfl-简化证明。</p>
<pre><code>def tail \(\{\alpha\) : Type \} : List \(\alpha \rightarrow\) List \(\alpha\)
    | [] \(\quad=&gt;[]\)
    | _ :: xs =&gt; xs
</code></pre>
<p>下一个列表操作是移除列表的第一个元素，返回尾部：</p>
<pre><code>def headOpt \(\{\alpha\) : Type \} : List \(\alpha \rightarrow\) Option \(\alpha\)
    | [] \(\quad=&gt;\) Option. none
    | x :: _ =&gt; Option. some x
</code></pre>
<p>对于[ ]，我们简单地返回[ ]作为它自己的尾部。与尾部对应的是一个提取列表第一个元素的函数。我们已经在第5.6节中回顾了一种使用Inhabited类型类的解决方案。另一种可能的定义是使用Option包装器：</p>
<pre><code>match headOpt xs with
    | Option.none =&gt; handleTheError
    | Option.some x =&gt; doSomethingWithValue x
</code></pre>
<p>类型 Option <span class="math">\(\alpha\)</span> 有两个构造器：Option.none 和 Option.some a，其中 a : <span class="math">\(\alpha\)</span>。当没有有意义的返回值时，我们使用 Option.none，否则使用 Option.some。我们可以将 Option.none 视为函数式编程中的空指针，但与空指针（以及空引用）不同，类型系统会防止不安全的解引用。要获取存储在 Option 中的值，我们必须进行模式匹配。示意如下：</p>
<p>我们不能简单地写成 doSomethingWithValue (headOpt xs)，因为这将导致类型错误。类型系统迫使我们考虑错误处理。</p>
<pre><code>def headPre { }\alpha\mathrm{ : Type} : (xs : List }\alpha)\rightarrowxs\neq[]\rightarrow\alpha
    | [], hxs =&gt; by simp at *
    | x :: _, hxs =&gt; x
</code></pre>
<p>利用依赖类型的力量，我们有了另一种实现部分函数的方法——即，我们可以指定一个前置条件。调用者必须传递一个证明前置条件满足的参数：</p>
<p>headPre函数接受两个显式参数。第一个参数xs是一个列表。第二个参数<span class="math">\(h x s\)</span>是<span class="math">\(x s \neq[]\)</span>的证明。由于第二个参数的类型<span class="math">\(x s \neq[]\)</span>依赖于第一个参数，我们必须使用依赖类型语法(xs : List <span class="math">\(\alpha\)</span> ) <span class="math">\(\rightarrow\)</span>而不是List <span class="math">\(\alpha \rightarrow\)</span>，以便我们可以为第一个参数命名。函数的结果是一个类型为<span class="math">\(\alpha\)</span>的值；由于前提条件的存在，不需要Option包装。</p>
<p>第二个参数用于排除xs为[]的情况。在这种情况下，参数（称为hxs）是[] <span class="math">\(\neq[]\)</span>的证明，这是不可能的。该证明导出了一个矛盾，并利用它来推导任意的<span class="math">\(\alpha\)</span>。从矛盾中，我们可以推导出任何东西，甚至是<span class="math">\(\alpha\)</span>的一个实例。</p>
<pre><code>\#eval headPre [3, 1, 4] (by simp)
</code></pre>
<p>我们可以如下调用该函数：</p>
<pre><code>def zip { }\alpha\beta\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; List }\beta\mathrm{ -&gt; List ( }\alpha\times\beta\mathrm{ )
    | x :: xs, y :: ys =&gt; (x, y) :: zip xs ys
    | [], _ =&gt; []
    | _ :: _, [] =&gt; []
</code></pre>
<p>这将打印出3。第二个参数，通过simp，是一个证明[3, 1, 4]不是[]的证明。现在，给定两个长度相同的列表<span class="math">\(\left[x_{1}, \ldots, x_{n}\right]\)</span>和<span class="math">\(\left[y_{1}, \ldots, y_{n}\right]\)</span>，zip操作将构造一个由对组成的列表<span class="math">\(\left[\left(x_{1}, y_{1}\right), \ldots,\left(x_{n}, y_{n}\right)\right]\)</span>：</p>
<p>该函数在其中一个列表比另一个短时也有定义。例如，zip <span class="math">\([a, b, c][x, y]=[(a, x),(b, y)]\)</span>。请注意，递归的三个情况偏离了结构递归模式。</p>
<pre><code>def length { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; N
    | [] =&gt; 0
    | x :: xs =&gt; length xs + 1
</code></pre>
<p>列表的长度通过递归定义：</p>
<pre><code>theorem length_zip { }\alpha\beta\mathrm{ : Type} (xs : List }\alpha\mathrm{ ) (ys : List }\beta\mathrm{ ):
    length (zip xs ys) = min (length xs) (length ys) :=
    by
    induction xs generalizing ys with
    | nil =&gt; simp [min, length]
    | cons x xs' ih =&gt;
    cases ys with
    | nil =&gt; rfl
    | cons y ys' =&gt; simp [zip, length, ih ys', min_add_add]
</code></pre>
<p>我们可以对zip操作结果的长度说一些有趣的事情——即，它是两个输入列表长度的最小值：</p>
<div class="math">$$
\text { ih : } \forall \text { ys : list } \beta \text {, length (zip xs ys) = min (length xs) (length ys) }
$$</div>
<p>上述证明还教会了我们另一个技巧。归纳假设是</p>
<p>为什么会有<span class="math">\(\forall\)</span>量词？归纳xs泛化ys策略将定理陈述泛化，使得归纳假设不局限于某些固定的ys作为证明目标，而是可以用于任意的ys值。这种灵活性在这里是必要的，因为我们希望用量词的实例化来替换ys的尾部（称为ys'），而不是ys本身。</p>
<pre><code>theorem min_add_add (l m n : N) :
    min (m + l) (n + l) = min m n + l :=
    by
        cases Classical.em (m \leq n) with
        | inl h =&gt; simp [min, h]
        | inr h =&gt; simp [min, h]
</code></pre>
<p>该证明依赖于一个关于最小函数的定理，我们需要自己证明它：</p>
<p>回顾min函数的定义，min a b = (如果 a <span class="math">\(\leq\)</span> b 则 a 否则 b)。为了推理min函数，我们通常需要对条件 <span class="math">\(a \leq b\)</span> 进行区分处理。这是通过使用cases Classical.em ( <span class="math">\(a \leq b\)</span> )来实现的。这会生成两个子目标：一个以 <span class="math">\(a \leq b\)</span> 作为假设，另一个以 <span class="math">\(\neg a \leq b\)</span> 作为假设。在每种情况下，假设都可以作为 <span class="math">\(h\)</span> 使用。</p>
<pre><code>theorem min_add_add_match (l m n : N) :
    min (m + l) (n + l) = min m n + l :=
    match Classical.em (m \leq n) with
    | Or.inl h =&gt; by simp [min, h]
    | Or.inr h =&gt; by simp [min, h]
theorem min_add_add_if (l m n : N) :
    min (m + l) (n + l) = min m n + l :=
    if h : m \leq n then
        by simp [min, h]
    else
        by simp [min, h]
</code></pre>
<p>在结构化证明中，有两种方法可以对命题进行情况区分：</p>
<table>
<thead>
<tr>
  <th style="text-align:left">Tactical proof</th>
  <th style="text-align:left">Structured proof</th>
  <th style="text-align:left">Raw proof term</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">cases t</td>
  <td style="text-align:left">match t with</td>
  <td style="text-align:left">match t with</td>
</tr>
<tr>
  <td style="text-align:left">cases Classical.em Q</td>
  <td style="text-align:left">if Q then...else</td>
  <td style="text-align:left">if Q then...else</td>
</tr>
</tbody>
</table>
<p>我们再次看到，用于编写函数式程序的机制，如match和if-then-else，同样可用于编写结构化证明（毕竟它们也是项）。现在，我们可以向4.7节末尾的表格中添加几行：</p>
<pre><code>theorem map_zip \(\left\{\alpha \alpha^{\prime} \beta \beta^{\prime}: \text { Type }\right\}\left(f: \alpha \rightarrow \alpha^{\prime}\right)\)
    \((g: \beta \rightarrow \beta')\) :
    \(\forall x s\) ys,
        map (fun ab : \(\alpha \times \beta \mapsto\)
            (f (Prod.fst ab), g (Prod.snd ab)))
            (zip xs ys) \(=\)

        zip (map f xs) (map g ys)
| x :: xs, y :: ys =&gt; by simp [zip, map, map_zip f g xs ys]
| [], —_ =&gt; by rfl
| _ :: _, [] =&gt; by rfl
</code></pre>
<p>我们以一个关于map和zip的分配律作为结尾，该定律使用Prod.fst和Prod.snd选择器对表示：</p>
<p>左侧的模式与zip定义中使用的模式完全对应。这比我们在证明length_zip时分别对xs进行归纳和对ys进行案例分析要简单。好的证明通常遵循其所基于定义的结构。</p>
<pre><code>def f { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow \cdots
    | [] =&gt; ...
    | xs =&gt; ... xs ...
</code></pre>
<p>在zip的定义和map_zip的证明中，我们特别注意指定了三个不重叠的模式。也可以编写具有重叠模式的方程，如</p>
<pre><code>def f { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ \rightarrow \cdots
    | [] =&gt; ...
    | x :: xs =&gt; ... (x :: xs) ...
</code></pre>
<p>由于模式是按顺序应用的，上述命令定义了与以下相同的函数。</p>
<p>我们通常推荐后者，即更明确的风格，因为它带来的意外情况更少。</p>
<pre><code>inductive Tree ( }\alpha\mathrm{ : Type) : Type
    | nil : Tree }\alpha
    | node : }\alpha\mathrm{ \rightarrow Tree }\alpha\mathrm{ \rightarrow Tree }\alpha\mathrm{ \rightarrow Tree }\alpha
</code></pre>
<h3>5.8 二叉树</h3>
<p>带有多个递归参数的构造函数的归纳类型定义了类似树的对象。二叉树的节点最多有两个子节点。Lean 对二叉树的定义如下：</p>
<div class="math">$$
\begin{gathered}
\vdash P[\text { Tree.nil }] \\
\mathrm{a}: \alpha, 1 \mathrm{r}: \text { Tree } \alpha, \text { ih_l }: \mathrm{P}, \text { ih_r }: \mathrm{P}[\mathrm{r}] \vdash \mathrm{P}[\text { Tree.node a } 1 \mathrm{r}]
\end{gathered}
$$</div>
<p>对于二叉树，结构归纳法会产生两个归纳假设，分别对应于内部节点的每个子树。为了通过对<span class="math">\(t\)</span>的结构归纳来证明目标<span class="math">\(t\)</span> : Tree <span class="math">\(\alpha \vdash P[t]\)</span>，我们需要展示以下子目标：</p>
<pre><code>def mirror { }\alpha\mathrm{ : Type} : Tree }\alpha\mathrm{ \rightarrow Tree }\alpha
    | Tree.nil =&gt; Tree.nil
    | Tree.node a l r =&gt; Tree.node a (mirror r) (mirror l)
</code></pre>
<p>树结构中对列表反转的对应操作是镜像操作：</p>
<pre><code>theorem mirror_mirror { }\alpha\mathrm{ : Type} (t : Tree }\alpha\mathrm{ ):
    mirror (mirror t) = t :=
    by
        induction t with
        | nil =&gt; rfl
        | node a l r ih_l ih_r =&gt; simp [mirror, ih_l, ih_r]
</code></pre>
<p>镜像操作可以直接定义，而无需依赖于某种附加操作。因此，关于镜像的推理比关于反转的推理更简单，如下所示：</p>
<div class="math">$$
(\text { ih_l) mirror (mirror l) }=1 \quad(\text { ih_r) mirror (mirror r) }=r
$$</div>
<p>更详细的非正式证明如下：该证明通过对<span class="math">\(t\)</span>的结构归纳进行。CASE Tree.nil：我们需要证明 mirror (mirror Tree.nil) = Tree.nil。这直接由 mirror 的定义得出。CASE Tree.node a l r：归纳假设为</p>
<pre><code>    mirror (mirror (Tree.node a l r))
= mirror (Tree.node a (mirror r) (mirror l)) (by def. of mirror)
= Tree.node a (mirror (mirror l)) (mirror (mirror r)) (ditto)
= Tree.node a l (mirror (mirror r)) (by ih_l)
= Tree.node a l r
</code></pre>
<p>我们需要证明 mirror (mirror (Tree.node a l r)) = Tree.node a l r。我们有</p>
<pre><code>theorem mirror_mirror_calc { }\alpha\mathrm{ : Type} :
    \forallt : Tree }\alpha\mathrm{ , mirror (mirror t) = t
| Tree.nil =&gt; by rfl
| Tree.node a l r =&gt;
    calc
        mirror (mirror (Tree.node a l r))
        = mirror (Tree.node a (mirror r) (mirror l)) :=
            by rfl
            _ = Tree.node a (mirror (mirror l))
            (mirror (mirror r)) :=
            by rfl
            _ = Tree.node a l (mirror (mirror r)) :=
            by rw [mirror_mirror_calc l]
            _ = Tree.node a l r :=
            by rw [mirror_mirror_calc r]
</code></pre>
<p>为了在Lean证明中实现相同程度的细节，我们可以使用计算块（第4.4节）来代替simp：</p>
<pre><code>theorem mirror_Eq_nil_Iff { }\alpha\mathrm{ : Type} :
    \forallt : Tree }\alpha\mathrm{ , mirror t = Tree.nil }\leftrightarrow\mathrm{t}=\text { Tree.nil
| Tree.nil =&gt; by simp [mirror]
| Tree.node _ _ =&gt; by simp [mirror]
</code></pre>
<p>我们以以下定理作为结尾，该定理在第6章中将非常有用：</p>
<pre><code>cases term [with
| constructor, names, =&gt; tactics
    \vdots
    | constructor, names, =&gt; tactics
</code></pre>
<pre><code>cases hypothesis-of-the-form-1-equals-r
</code></pre>
<h3>5.9 案例分析策略</h3>
<h4>cases</h4>
<p>cases策略对指定的项进行案例分析。这会生成与该项类型定义中的构造器数量相同的子目标。该策略与归纳法类似，但它不生成归纳假设，并且会自动排除不可能的情况。可选名称<span class="math">\(_{1}, \ldots\)</span>, 名称<span class="math">\(_{n}\)</span>用于任何出现的变量或假设。</p>
<pre><code>cases Classical.em (proposition) with
| inl name-if-true =&gt; tactics-if-true
| inr name-if-false =&gt; tactics-if-false
</code></pre>
<p>cases策略也可以用于形式为<span class="math">\(1=r\)</span>的假设<span class="math">\(h\)</span>。它将<span class="math">\(r\)</span>与1进行匹配，并在目标中将<span class="math">\(r\)</span>中出现的所有变量替换为1中对应的项。剩余的假设<span class="math">\(1=1\)</span>可以使用clear h来移除（如果需要）。</p>
<p>cases 策略也可用于对命题进行情况区分。会出现两种情况：一种是命题为真的情况，另一种是命题为假的情况。可选的名称 name-if-true 和 name-if-false 分别用于真情况和假情况中的假设。</p>
<pre><code>inductive Vec ( }\alpha\mathrm{ : Type) : N -&gt; Type where
    | nil : Vec }\alpha\mathrm{ \emptyset
    | cons (a : \alpha) {n : N}(v : Vec \alpha n): Vec \alpha(n+1)
</code></pre>
<h3>5.10 依赖归纳类型</h3>
<p>归纳类型 List <span class="math">\(\alpha\)</span> 和 Tree <span class="math">\(\alpha\)</span> 属于 Lean 的简单类型片段。归纳类型也可以依赖于（非类型）项。一个典型的例子是长度为 <span class="math">\(n\)</span> 的列表类型，或称为向量：</p>
<p>因此，项 Vec. cons 3 (Vec. cons 1 Vec.nil) 的类型为 Vec <span class="math">\(\mathbb{N}_{2}\)</span>。通过在类型中编码向量的长度，我们可以提供关于函数结果的更精确信息。例如，Vec.reverse 这样的函数，它反转一个向量，会将值 <span class="math">\(\operatorname{Vec} \alpha n\)</span> 映射到另一个相同类型的值，且保持相同的 <span class="math">\(n\)</span>。而 Vec.zip 可能要求它的两个参数具有相同的长度。固定长度的向量和矩阵在计算机科学和数学中非常有用。</p>
<p>不幸的是，这种更精确的信息是以一定的代价换来的。依赖归纳类型在它们所依赖的项在可证明相等但在计算上不完全语法相等时（例如，<span class="math">\(m+n\)</span> 与 <span class="math">\(n+m\)</span>）会导致困难。在本指南中，我们通常会避免使用依赖归纳类型。它们在本节中为了完整性而简要提及。明确地说：这不是考试内容。</p>
<pre><code>def listOfVec { }\alpha\mathrm{ : Type} : V{n:N}, Vec \alpha n \rightarrow List \alpha
    | _, Vec.nil =&gt; []
    | _, Vec.cons a v =&gt; a :: listOfVec v
def vecOfList { }\alpha\mathrm{ : Type} :
    Vxs : List }\alpha\mathrm{ , Vec }\alpha\mathrm{ (List.length xs)
    | [] =&gt; Vec.nil
    | x :: xs =&gt; Vec.cons x (vecOfList xs)
</code></pre>

<p>以下定义介绍了列表与向量之间的转换：</p>

<p>listOfVec转换接受一个类型<span class="math">\(\alpha\)</span>、一个长度<span class="math">\(n\)</span>以及一个长度为<span class="math">\(n\)</span>的<span class="math">\(\alpha\)</span>向量作为参数，并返回一个<span class="math">\(\alpha\)</span>类型的列表。尽管我们不关心长度<span class="math">\(n\)</span>，但它仍然需要作为一个参数，因为它出现在第三个参数的类型中。我们将前两个参数<span class="math">\(\alpha\)</span>和<span class="math">\(n\)</span>设为隐式参数，因为它们可以从第三个参数的类型中推断出来。</p>
<p>vecOfList 转换接受一个类型 <span class="math">\(\alpha\)</span> 和一个基于 <span class="math">\(\alpha\)</span> 的列表作为参数，并返回一个与列表长度相同的向量。Lean 的类型检查器足够强大，能够确定右侧的两个表达式具有所需的类型。</p>
<pre><code>theorem length_listOfVec { }\alpha\mathrm{ : Type} :
    V(n : N)(v : Vec }\alpha\mathrm{n}), List.length (listOfVec v) = n
    | _, Vec.nil =&gt; by rfl
    | _, Vec.cons a v =&gt;
    by simp [listOfVec, length_listOfVec _ v]
</code></pre>
<p>根据PAT原理，证明类似于函数定义。让我们验证将向量转换为列表时是否保持其长度：</p>
<div class="math">$$
\begin{gathered}
\vdash P[\text { Vec.nil }] \\
m: \mathbb{N}, a: \alpha, u: \operatorname{Vec} \alpha m, i h: P[u] \vdash P[\text { Vec. cons } a u]
\end{gathered}
$$</div>
<p>为了通过结构归纳法证明目标<span class="math">\(v: \operatorname{Vec} \alpha n \vdash P[v]\)</span>，我们可能会天真地认为只需证明以下两个子目标即可：</p>
<div class="math">$$
\begin{gathered}
\vdash P_{\theta}[\text { Vec.nil }] \\
m: \mathbb{N}, a: \alpha, u: \operatorname{Vec} \alpha m, i h: P_{\theta}[u] \vdash P_{m+1}[\operatorname{Vec} \text {. cons } a u]
\end{gathered}
$$</div>
<p>这种想法是幼稚的，因为子目标甚至类型都不正确：P[ ]中的空洞类型为Vec <span class="math">\(\alpha n\)</span>（其原始居住者<span class="math">\(v\)</span>的类型），因此我们不能简单地将Vec.nil、<span class="math">\(u\)</span>或Vec.cons a <span class="math">\(u\)</span>（它们的类型分别为Vec <span class="math">\(\alpha \theta\)</span>、Vec <span class="math">\(\alpha m\)</span>和<span class="math">\(\operatorname{Vec} \alpha(m+1)\)</span>）插入该空洞中。每次我们都必须调整<span class="math">\(P\)</span>，将<span class="math">\(n\)</span>替换为<span class="math">\(\theta, m\)</span>或<span class="math">\(m+1\)</span>。使用符号<span class="math">\(P_{t}[\)</span> ]表示将<span class="math">\(P[]\)</span>中所有<span class="math">\(n\)</span>的出现替换为项<span class="math">\(t\)</span>的变体，我们得到</p>
<p>使用cases策略进行情况区分的证明类似，但没有归纳假设。通常，长度<span class="math">\(n\)</span>不会是一个变量，而是一个复杂的项。那么，在<span class="math">\(P[]\)</span>中替换<span class="math">\(n\)</span>可能并不直观有意义。使用cases时，相应的子目标会被静默消除。因此，对类型为<span class="math">\(\operatorname{Vec} \alpha \theta\)</span>的值进行情况区分将只产生一个子目标，形式为<span class="math">\(\vdash P[\)</span> Vec. nil]，因为<span class="math">\(\theta\)</span>永远不会等于形式为<span class="math">\(m+1\)</span>的项。</p>
<pre><code>match v with
| Vec.nil =&gt; ...
| Vec.cons a u =&gt; ...
</code></pre>
<p>依赖类型的模式匹配是微妙的，因为我们匹配的值的类型可能会根据构造函数而变化。给定<span class="math">\(v: \operatorname{Vec} \alpha n\)</span>，我们可能会想写</p>
<pre><code>match n, v with
| 0, Vec.nil =&gt; ...
| m + 1, Vec.cons a u =&gt; ...
</code></pre>
<p>但这与我们上面的第一个归纳证明尝试一样天真。由于类型<span class="math">\(\operatorname{Vec} \alpha n\)</span>中的项<span class="math">\(n\)</span>可能会根据构造函数而变化，我们必须同时对<span class="math">\(n\)</span>进行模式匹配：</p>
<pre><code>match n, v with
| 0, @Vec.nil }\alpha\mathrm{ =&gt; ...
| m + 1, @Vec.cons }\alpha\mathrm{ a m u =&gt; ...
</code></pre>
<p>展示隐式参数，我们得到</p>
<pre><code>match n, v with
| _, Vec.nil =&gt; ...
| _, Vec.cons a u =&gt; ...
</code></pre>
<p>通常，在第一列中放置占位符就足够了：</p>
<p>仅对<span class="math">\(n\)</span>进行模式匹配却忽略结果可能看似矛盾，但没有它，Lean 无法推断出 Vec.cons 的第二个隐式参数。在这方面，cases 比 match 更用户友好。</p>

<h3>5.11 新引入的 Lean 构造总结</h3>
<h4>声明</h4>
<p>class
instance
structure
将结构类型声明为类型类
将结构值声明为类型类实例
引入结构类型及其选择器</p>

<h4>表达式</h4>
<p>if... then... else 对可判定命题执行条件分支<br>match... with 执行模式匹配</p>
<h4>策略</h4>
<p>cases 执行情况区分</p>

<h2>第6章：归纳谓词</h2>
<p>归纳谓词，或归纳定义的命题，是一种方便的方式来指定类型为<span class="math">\(\cdots \rightarrow\)</span> Prop的函数。它们让人联想到形式系统（第1.3节）和Prolog风格的逻辑编程。但Lean比Prolog更具表达能力，因此我们需要做一些工作来建立定理，而不仅仅是运行Prolog解释器。对Lean的一种可能的看法是：</p>

<p>Lean <span class="math">\(=\)</span> 函数式编程 + 逻辑编程 + 更多逻辑</p>
<h3>6.1 入门示例</h3>
<p>除非你接触过Prolog或逻辑编程，否则你可能会想知道什么是归纳谓词以及它们为什么有用。我们首先回顾三个示例，展示其多样化的用途：偶数、网球比赛和自反传递闭包。</p>

<h3>6.1.1 偶数</h3>
<p>数学家通常将特定集合定义为满足某些条件的最小集合。考虑以下定义：</p>

<p>偶数自然数的集合<span class="math">\(E\)</span>被定义为满足以下规则的最小集合<span class="math">\(S\)</span>：
(1) <span class="math">\(0 \in S\)</span>；
(2) 对于每一个<span class="math">\(k \in \mathbb{N}\)</span>，如果<span class="math">\(k \in S\)</span>，那么<span class="math">\(k+2 \in S\)</span>。</p>
<p>根据Knaster-Tarski定理，这样的集合存在。（最后一句话通常被隐含。）我们很容易确信<span class="math">\(E\)</span>包含所有的偶数且仅包含这些数。让我们戴上数学家的帽子，证明4是偶数：</p>
<div class="math">$$
\underset{0 \in E}{-} \text { ZERO } \quad \frac{h \in E}{h+2 \in E} \text { ADDtwo }{ }_{R}
$$</div>
<p>根据规则（1），我们有<span class="math">\(0 \in E\)</span>。因此，根据规则（2）（令<span class="math">\(k:=0\)</span>），我们有<span class="math">\(2 \in E\)</span>。于是，根据规则（2）（令<span class="math">\(k:=2\)</span>），我们有<span class="math">\(4 \in E\)</span>，如所期望。相比之下，计算机科学家可能会使用一个由两条推导规则组成的形式系统来指定相同的集合：</p>
<div class="math">$$
\frac{\frac{0 \in E}{-} \text { ZERO }}{2 \in E} \text { ADDTwo }{ }_{0}
$$</div>
<p>那么，证明就是一个推导树：</p>
<pre><code>inductive Even : \(\mathbb{N} \rightarrow\) Prop where
    | zero : Even \0
    | add_two : Yk : N, Even k \(\rightarrow\) Even (k + 2)
</code></pre>
<p>如果我们向下阅读，证明是正向的；如果我们向上阅读，证明是反向的。归纳谓词是逻辑学家实现相同结果的方式。在Lean中，我们不会定义一个集合，而是会归纳地定义一个特征谓词：</p>
<p>这看起来应该很熟悉。我们使用了相同的语法，只是用 Type 代替了 Prop，来定义归纳类型。在 Lean 中，归纳类型和归纳谓词是由相同的机制提供的，符合 PAT 原则。</p>
<p>上述命令定义了一个一元谓词Even，以及两个引入规则Even.zero和Even.add_two，它们可用于证明形式为<span class="math">\(\vdash\)</span> Even . . . 的目标。回想一下，一个符号（例如Even）的引入规则是一个定理，其结论包含该符号（第4.3节）。根据PAT原则，Even n可以视为一个依赖归纳类型，如Vec <span class="math">\(\propto \mathrm{n}\)</span>（第5.10节），而Even.zero和Even.add_two则类似于Vec.nil和Vec.cons这样的构造函数。</p>
<p>如果我们将Lean定义翻译回英文，我们会得到类似于上述Knaster-Tarski风格的定义：</p>

<p>以下条款定义了偶数。
(1) <span class="math">\(\varnothing\)</span> 是偶数；
(2) 任何形式为 <span class="math">\(k+2\)</span> 的数字都是偶数，假设 <span class="math">\(k\)</span> 是偶数。</p>

<p>任何其他数字都不是偶数。值得注意的是，归纳定义的符号没有定义。因此，我们无法使用simp展开它们的定义。唯一可用的推理原则是引入和消除。</p>
<pre><code>theorem Even_4 :
    Even 4 :=
have Even_0 : Even 0 :=
    Even.zero
have Even_2 : Even 2 :=
    Even.add_two _ Even_0
show Even 4 from
    Even.add_two _ Even_2
</code></pre>
<p>作为热身练习，这里有一个关于 Even 4 的证明：</p>
<p>例如，证明项 Even.add_two _ Even_0 的类型为 Even (0 + 2)，这在计算上语法等同于 Even 2，因此从类型检查器的角度来看是相等的。下划线代表 0。</p>
<p>得益于归纳定义的“无冗余”保证，Even.zero 和 Even.add_two 是构造 <span class="math">\(\vdash\)</span> Even ... 证明的唯二方法。通过检查结论 Even 0 和 Even ( <span class="math">\(k+2\)</span> )，我们可以看到，绝不可能证明 1 是偶数。</p>
<pre><code>opaque Even : N -&gt; Prop
axiom Even. zero : Even 0
axiom Even.add_two : VK : N, Even k -&gt; Even (k + 2)
</code></pre>
<p>另一种理解上述归纳定义的方式如下：第一行引入了一个谓词，而第二行和第三行引入了我们希望该谓词满足的公理。因此，我们可以这样写：</p>
<p>将“归纳”替换为“不透明”，将“|”替换为“公理”。但这种公理化版本并没有给我们提供任何关于Even何时为假的信息。我们无法用它来证明<span class="math">\(\neg\)</span> Even 1或<span class="math">\(\neg\)</span> Even 17。就我们所知，Even可能对所有自然数都为真。相比之下，归纳定义保证了我们获得满足引入规则Even.zero和Even.add_two的最小（即最假）谓词，并提供了消除和归纳原则，使我们能够证明<span class="math">\(\neg\)</span> Even 1、<span class="math">\(\neg\)</span> Even 17或<span class="math">\(\neg\)</span> Even <span class="math">\((2+n+1)\)</span>。</p>
<pre><code>def evenRec : N -&gt; Bool
    | 0 =&gt; true
    | 1 =&gt; false
    | k + 2 =&gt; evenRec k
</code></pre>
<p>既然我们可以定义递归函数，为什么还要费心使用归纳谓词呢？事实上，以下定义是完全合法的：</p>
<p>每种风格都有其优点和缺点。递归版本迫使我们指定一个假情况（第二个等式），并且迫使我们担心终止问题。另一方面，由于它是等式和计算性的，它与rfl、simp、#eval和#reduce配合得很好。归纳版本可以说是更抽象和优雅的。每个引入规则都是独立陈述的。我们可以添加或删除规则，而不必考虑终止或可执行性。</p>
<pre><code>def evenNonrec (k : N) : Prop :=
    k % 2 = 0
</code></pre>
<p>另一种定义偶数的方式是使用取模运算符（%）的非递归定义：</p>
<p>数学家们可能更喜欢这个版本。但归纳版本是一个方便的“Hello, World!”示例，它类似于许多实际的归纳定义。它可能是一个玩具，但它是一个有用的玩具。</p>
<h4>6.1.2 网球比赛</h4>
<p>转换系统由连接“之前”和“之后”状态的转换规则组成。作为转换系统的一个示例，我们考虑网球比赛中的可能转换，从o-o（“零比零”）开始。网球比赛也是一个玩具，但在第9章中，我们将以类似的方式定义一个命令式编程语言的语义作为一个转换系统。</p>

<p>国际网球联合会的网球规则中的计分规则如下所示。</p>

<table>
<thead>
<tr>
  <th style="text-align:left">No point</th>
  <th style="text-align:left">- "Love"</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">First point</td>
  <td style="text-align:left">- "15"</td>
</tr>
<tr>
  <td style="text-align:left">Second point</td>
  <td style="text-align:left">- "30"</td>
</tr>
<tr>
  <td style="text-align:left">Third point</td>
  <td style="text-align:left">- "40"</td>
</tr>
<tr>
  <td style="text-align:left">Fourth point</td>
  <td style="text-align:left">- "Game"</td>
</tr>
</tbody>
</table>
<p>标准比赛的得分规则如下，发球方的得分先报：</p>
<p>除非每位选手/每支队伍各赢得三分，此时比分称为“平分”。在“平分”之后，赢得下一分的选手/队伍将获得“占先”。如果同一选手/队伍再次赢得下一分，则该选手/队伍赢得“局”；如果对手赢得下一分，则比分再次回到“平分”。选手/队伍需要在“平分”后连续赢得两分才能赢得“局”。</p>
<pre><code>inductive Score : Type where
    | vs \(\quad: \mathbb{N} \rightarrow \mathbb{N} \rightarrow\) Score
    | advServ : Score
    | advRecv : Score
    | gameServ : Score
    | gameRecv : Score
</code></pre>
<p>我们首先定义一个归纳类型来表示分数：</p>
<p>例如，30-15这样的分数表示为Score.vs 3015，我们也可以用中缀符号将其写为<span class="math">\(30-15\)</span>。我们忽略了一些得分规则中最不重要的部分，用o表示“Love”，用40-40表示“Deuce”。如果我们愿意，可以引入别名，例如def love : <span class="math">\(\mathbb{N}:=\)</span> Score.vs 00。</p>
<pre><code>inductive Step : Score \(\rightarrow\) Score \(\rightarrow\) Prop where
    | serv_0_15 : \(\forall n\), Step ( \(0-n\) ) (15-n)
    | serv_15_30 : \(\forall n\), Step (15-n) (30-n)
    | serv_30_40 : \(\forall n\), Step (30-n) (40-n)
    | serv_40_game : \(\forall n, n&lt;40 \rightarrow\) Step (40-n) Score.gameServ
    | serv_40_adv : Step (40-40) Score.advServ
    | serv_adv_40 : Step Score.advServ (40-40)
    | serv_adv_game : Step Score.advServ Score.gameServ
    | recv_0_15 : \(\forall n\), Step ( \(n-0\) ) ( \(n-15\) )
    | recv_15_30 : \(\forall n\), Step ( \(n-15\) ) ( \(n-30\) )
    | recv_30_40 : \(\forall n\), Step ( \(n-30\) ) ( \(n-40\) )
    | recv_40_game : \(\forall n, n&lt;40 \rightarrow\) Step ( \(n-40\) ) Score.gameRecv
    | recv_40_adv : Step (40-40) Score.advRecv
    | recv_adv_40 : Step Score.advRecv (40-40)
    | recv_adv_game : Step Score.advRecv Score.gameRecv
</code></pre>
<p>下一步是引入一个二元谓词Step，用于确定是否可以进行转换：</p>
<p>设<span class="math">\(s \sim t\)</span>表示Step<span class="math">\(s t\)</span>。一个游戏是一条链<span class="math">\(s_{0} \sim s_{1} \sim s_{2} \sim \cdots \sim s_{n}\)</span>，其中<span class="math">\(s_{0}=0-0\)</span>且无法从<span class="math">\(s_{n}\)</span>进行转换。该谓词允许无意义的转换，例如15-99到30-99，但由于分数15-99无法从<span class="math">\(0-0\)</span>达到，这些转换是无害的。</p>
<pre><code>theorem no_Step_to_0_0 (s : Score) :
    \(\neg \mathrm{s} \sim 0-0:=\)
    by
        intro h
        cases h
</code></pre>
<p>配备了正式定义后，我们可以提出并正式回答诸如以下问题：比赛是否有最大长度？有多少种不同的最终得分可能？从“Love all”能否达到15-99的比分？比分是否有可能回到o-o？让我们使用Lean来反驳最后一个说法：</p>
<p>下图总结了哪些分数可以从哪些分数达到：</p>
<p><img src="img-6.jpeg" alt="img-6.jpeg"></p>
<div class="math">$$
\begin{aligned}
&amp; r=\{(1,2),(2,4),(4,8)\} \\
&amp; r^{*}=\{(n, n) \mid n \in \mathbb{N}\} \cup\{(1,2),(1,4),(1,8),(2,4),(2,8),(4,8)\}
\end{aligned}
$$</div>
<h4>6.1.3 自反传递闭包</h4>
<p>作为归纳谓词的一个特别有用的应用，考虑二元关系<span class="math">\(r\)</span>的自反传递闭包<span class="math">\(r^{*}\)</span>。非正式地说，<span class="math">\(r^{*}\)</span>是表示<span class="math">\(r\)</span>的零步或多步的关系。例如，如果<span class="math">\(r\)</span>对应于在转移系统（例如，自动机）中采取一次转移，那么<span class="math">\(r^{*}\)</span>对应于采取任意数量的步骤，包括零步。为了更具体的例子，考虑以下内容：</p>
<div class="math">$$
\frac{(a, b) \in r}{(a, b) \in r^{*}} \text { BASE } \quad \frac{(a, a) \in r^{*}(b, c) \in r^{*}}{(a, c) \in r^{*}} \text { TRANS }
$$</div>
<p>星号（<span class="math">\(\left.{ }^{*}\right)\)</span>运算符通常被严格定义为一个形式系统：</p>
<p>这些规则将<span class="math">\(r^{*}\)</span>定义为包含<span class="math">\(r\)</span>（通过BASE）且是自反的（通过REFL）和传递的（通过TRANS）的最小关系。如果我们想要定义传递闭包<span class="math">\(r^{*}\)</span>，只需省略REFL规则。如果我们想要自反对称闭包，则可以用SYMM规则替换TRANS规则。在形式系统中，我们只需声明我们想要为真的属性，而无需考虑终止性或可执行性。</p>
<pre><code>inductive Star \(\{\alpha:\) Type \} (R : \alpha \rightarrow \alpha \rightarrow\) Prop) : \(\alpha \rightarrow \alpha \rightarrow\) Prop
where
    | base (a b : \(\alpha) \quad: R\) a b \(\rightarrow\) Star R a b
    | refl (a : \(\alpha) \quad\) : Star R a a
    | trans (a b c : \(\alpha\) ) : Star R a b \(\rightarrow\) Star R b c \(\rightarrow\) Star R a c
</code></pre>
<p>将上述推导规则转换为归纳谓词的引入规则是直接了当的。</p>
<div class="math">$$
\text { | base : } \forall \mathrm{a} \mathrm{~b}: \alpha, \mathrm{R} \text { a } \mathrm{b} \rightarrow \text { Star } \mathrm{R} \text { a } \mathrm{~b}
$$</div>
<p>我们将关系表示为二元谓词而非对集合，用R a b表示<span class="math">\((a, b) \in R\)</span>。关系和谓词可以互换使用，但在证明助手中使用谓词通常更为方便。<span class="math">\(R\)</span>的自反传递闭包写作Star R。注意<span class="math">\(a, b\)</span>和<span class="math">\(c\)</span>被声明为引入规则的参数，位于冒号的左侧。我们也可以写成</p>
<div class="math">$$
\text { | base (a b : } \alpha \text { ) (hab : R a b) : Star R a b }
$$</div>
<p>或者在另一个极端</p>
<pre><code>inductive predicate-name (params \({ }_{1}:\) type \(_{1}\) ) ... (params\(_{k}:\) type \(_{k}\) ) :
    type \(_{k+1} \rightarrow \cdots \rightarrow\) type \(_{k+p} \rightarrow\) Prop where
    | rule-name \(_{1}\) (params \(_{11}:\) type \(_{11}\) ) ... (params \(_{1 m_{1}}:\) type \(_{1 m_{1}}\)) :
        proposition \(_{1}\)
        \vdots
    | rule-name \(_{n}\) (params \(_{n 1}:\) type \(_{n 1}\) ) ... (params \(_{n m_{n}}:\) type \(_{n m_{n}}\)) :
        proposition \(_{n}\)
</code></pre>
<p>所有这些形式在逻辑上和操作上都是等价的。归纳谓词的一般格式如下：</p>
<p>其中每个命题<span class="math">\(j\)</span>的结论必须是对定义的谓词predicate-name应用于某些参数的应用。这些参数可以是任意项；它们不需要是构造函数模式。如果我们想要使参数对应于隐式参数，也可以使用花括号<span class="math">\(\}\)</span>代替括号( )。</p>
<pre><code>def starRec { }\alpha: Type} (R : \alpha -&gt; \alpha -&gt; \text { Bool}):\mathrm{
    \alpha -&gt; \alpha -&gt; Bool :=
</code></pre>
<p>上述Star的定义确实非常优雅。如果你仍然对此存疑，尝试将其实现为一个递归函数：</p>
<p>总结来说，归纳谓词<span class="math">\(P\)</span>的每个引入规则由以下从左到右的组件组成：</p>
<ul>
<li>一个名称；</li>
<li>可能出现在规则中的变量；</li>
<li>必须满足的零个或多个条件，这些条件可能递归地应用P；</li>
<li>将P应用于某些参数，形成一个模式。</li>
</ul>
<p>因此，对于规则 Star.base，模式是 Star R a b，条件是 R a b，变量是<span class="math">\(a\)</span>和<span class="math">\(b\)</span>。</p>
<pre><code>-- fails
inductive Illegal : Prop where
    | intro : ~ Illegal -&gt; Illegal
</code></pre>
<h4>6.1.4 非示例</h4>
<p>并非所有归纳定义都允许存在最小解。最简单的非示例是</p>
<p>如果Lean接受这个定义，我们可以用它来证明等价关系Illegal <span class="math">\(\leftrightarrow \neg\)</span> Illegal，从而很容易推导出False。幸运的是，Lean拒绝了该定义：'Illegal.intro'的第一个参数在声明的数据类型中具有非正出现。</p>
<p>它抱怨的非正出现是否定下的Illegal的出现。数学家会拒绝这个定义，理由是Knaster-Tarski定理的单调性条件不满足。</p>
<pre><code>inductive And (a b : Prop) : Prop where
    | intro : a -&gt; b -&gt; And a b
inductive Or (a b : Prop) : Prop where
    | inl : a -&gt; Or a b
    | inr : b -&gt; Or a b
inductive Iff (a b : Prop) : Prop where
    | intro : (a -&gt; b) -&gt; (b -&gt; a) -&gt; Iff a b
inductive Exists {a : Type} (P : \alpha -&gt; Prop) : Prop where
    | intro : Va : \alpha, P a -&gt; Exists P
inductive True : Prop where
    | intro : True
inductive False : Prop where
inductive Eq {a : Type} : \alpha -&gt; \alpha -&gt; Prop where
    | refl : Va : \alpha, Eq a a
</code></pre>
<h3>6.2 逻辑符号</h3>
<p>尽管Even是本指南中第一个公开的归纳谓词，但前面的章节已经暗中介绍了其他归纳谓词。其中第一个是相等（<span class="math">\(=\)</span>），在第二章中引入，随后是逻辑符号<span class="math">\(\wedge\)</span>、<span class="math">\(V, \leftrightarrow, \exists\)</span>、True和False。它们的定义值得仔细研究：</p>
<p>严格来说，在Lean中，上述部分定义实际上是结构体而非归纳谓词，但区别是表面的。正如我们在第5.5节中看到的，结构体本质上是带有一些语法糖的单构造器归纳谓词。</p>
<p>传统符号 <span class="math">\(\exists x: \alpha, P\)</span> 和 <span class="math">\(x=y\)</span> 是 Exists (fun <span class="math">\(x: \alpha \mapsto P\)</span> ) 和 Eq <span class="math">\(x\)</span> y 的语法糖。注意 fun 如何充当通用绑定器。还要注意，False 没有构造函数。就像 Even 1 没有证明一样，False 也没有证明。使用归纳谓词时，我们只陈述我们希望为真的规则。</p>
<p>符号<span class="math">\(\vee\)</span>，包括其特殊情况<span class="math">\(\rightarrow\)</span>，直接内置于逻辑中，并未定义为归纳谓词。它也没有明确的引入或消解规则。引入原则是匿名函数fun <span class="math">\(x \mapsto\)</span> _，而消解原则是函数应用 _ u。</p>
<p>对于任何归纳谓词，仅指定了引入规则。第3.3节和第3.4节中提出的消除规则必须手动推导。</p>
<h3>6.3 规则归纳</h3>
<p>正如我们可以对归纳类型的项进行归纳一样，我们也可以对归纳谓词的证明进行归纳。例如，给定目标<span class="math">\(h\)</span> : Even <span class="math">\(n \vdash P n\)</span>，我们可以对<span class="math">\(h\)</span>进行归纳，得到两个子目标，分别对应于Even.zero和Even.add_two。这被称为对<span class="math">\(h\)</span>的推导结构进行归纳，或简称为规则归纳，因为归纳是基于谓词的引入规则（即证明项的构造器）进行的。</p>
<p>有两种方式来看待规则归纳：“最小谓词满足条件视图”和“PAT视图”。要理解最小谓词满足条件视图，回想一下，归纳定义引入了一个符号作为满足引入规则的最小（即最不成立的）谓词。因此，Even 是最小谓词 Q，使得性质 Q <span class="math">\(\theta\)</span> 和 <span class="math">\(\forall k, Q k \rightarrow Q(k+2)\)</span> 成立。因此，如果我们能证明对于某个谓词 <span class="math">\(P\)</span>，<span class="math">\(P \theta\)</span> 和 <span class="math">\(\forall k, P k \rightarrow P(k+2)\)</span> 成立，那么 <span class="math">\(P\)</span> 要么是 Even 本身，要么比 Even 更大（即更成立）。因此，Even n 蕴含 P n，这正是我们证明目标 h : Even <span class="math">\(\mathrm{n} \vdash \mathrm{Pn}\)</span> 所需要的。</p>
<p>“最小谓词”观点为规则归纳提供了一个直观的解释，可用于非正式的论证，例如以下证明：对于所有n，Even n 意味着<span class="math">\(\mathrm{n} \% 2=\theta\)</span>。</p>
<p>该证明通过对假设 Even n 进行规则归纳。CASE Even. zero: 我们需要证明<span class="math">\(\theta \% 2=\theta\)</span>。这可以通过计算得出。CASE Even.add_two k: 归纳假设为<span class="math">\(\mathrm{k} \% 2=\theta\)</span>。我们需要证明<span class="math">\((k+2) \% 2=\theta\)</span>。这可以通过基本的算术推理得出。</p>
<pre><code>theorem mod_two_Eq_zero_of_Even (n : N) (h : Even n) :
    n % 2 = 0 :=
    by
        induction h with
        | zero =&gt; rfl
        | add_two k hk ih =&gt; simp [ih]
</code></pre>
<p>Lean 的证明具有相同的结构：</p>
<div class="math">$$
\begin{gathered}
\vdash P_{0}[\text { Even. zero : Even } \theta] \\
k: \mathbb{N}, h k: \text { Even } k, i h: P_{k}[h k] \vdash P_{k+2}[\text { Even.add_two } k h k: \text { Even }(k+2)]
\end{gathered}
$$</div>
<p>PAT 原则为我们提供了另一种富有成效的方式来审视规则归纳。关键思想是，在诸如 <span class="math">\(h\)</span> : Even <span class="math">\(n \vdash P[h]\)</span> 的目标中对 <span class="math">\(h\)</span> 进行规则归纳，与对依赖归纳类型的值（如 Vec <span class="math">\(\alpha n\)</span>，见第 5.10 节）进行结构归纳完全类似。将 <span class="math">\(P[\)</span> ] 中 <span class="math">\(n\)</span> 替换为某个项 <span class="math">\(u\)</span> 的变体记为 <span class="math">\(P_{u}[\)</span> ]，我们得到子目标</p>

<p>这些实际上是由归纳策略生成的子目标。无论归纳谓词Q是什么，计算子目标的程序始终相同：</p>
<ol>
<li>将<span class="math">\(P[h]\)</span>中的<span class="math">\(h\)</span>替换为每个可能的引入规则应用于新变量（例如，Even.add_two k hk），并实例化<span class="math">\(P[ ]\)</span>中的<span class="math">\(n\)</span>以使<span class="math">\(P[ ]\)</span>类型正确。这将生成与引入规则数量相同的子目标。</li>
<li>将这些新变量（例如，<span class="math">\(k, h k\)</span>）添加到局部上下文中。</li>
<li>为所有断言<span class="math">\(Q \ldots\)</span>的新假设添加归纳假设。</li>
</ol>

<p>请注意在上述假设中存在hk : Even k。它在最小谓词视图中是不存在的，并且不是必需的，因为它总是可以通过将<span class="math">\(P\)</span>加强为Even <span class="math">\(n \wedge \cdots\)</span>的形式来恢复。</p>
<div class="math">$$
\vdash P_{0} \quad k: \mathbb{N}, h k: \text { Even } k, i h: P_{k} \vdash P_{k+2}
$$</div>
<p>在几乎所有实际情况下，<span class="math">\(h\)</span>不会出现在<span class="math">\(P[h]\)</span>中。因此，我们可以简单地写成</p>
<p>在少数情况下，<span class="math">\(h\)</span> 会出现在 <span class="math">\(P[h]\)</span> 中。正如我们在第5.7节中尝试提取列表头部时所看到的，证明可能会作为子项出现在任意项中。</p>
<div class="math">$$
\begin{gathered}
a b: \alpha, h a b: R a b \vdash P_{a, b} \\
a: \alpha \vdash P_{a, a}
\end{gathered}
$$</div>
<p>接下来，我们考虑自反传递闭包 Star R。给定一个目标 h : Star <span class="math">\(R x y \vdash P\)</span>，对 <span class="math">\(h\)</span> 进行规则归纳会产生以下子目标，其中 <span class="math">\(P_{t, u}\)</span> 表示将 <span class="math">\(x\)</span> 和 <span class="math">\(y\)</span> 分别替换为 <span class="math">\(t\)</span> 和 <span class="math">\(u\)</span> 的 <span class="math">\(P\)</span> 的变体：</p>
<pre><code>theorem Star_Star_IIff_Star {\alpha : Type} (R : \alpha \rightarrow \alpha \rightarrow \text { Prop) }
    (a b : \alpha) :
    Star (Star R) a b \leftrightarrows Star R a b :=
    by
        apply Iff.intro
        { intro h
            induction h with
            | base a b hab =&gt; exact hab
            | refl a =&gt; apply Star.refl
            | trans a b c hab hbc ihab ihbc =&gt;

    apply Star.trans a b
    { exact ihab }
    { exact ihbc } }
{ intro h
    apply Star.base
    exact h }
</code></pre>
<p><span class="math">\(a b c: \alpha, h a b: S t a r R a b, h b c: S t a r R b c, i h a b: P_{a, b}, i h b c: P_{b, c} \vdash P_{a, c}\)</span>这正是“证明助手”中“助手”部分的体现。Star的一个关键性质是幂等性——将Star应用于Star R不会产生任何效果。这可以在Lean中通过规则归纳来证明，使用规则归纳来证明等价性的<span class="math">\(\rightarrow\)</span>方向：</p>
<p>我们谨慎地为新出现的变量赋予直观的名称。在包含长且自动生成名称的目标中很容易迷失方向。当面对大型目标时，第3.8节中介绍的清理策略也会有所帮助。</p>
<pre><code>@[simp] theorem Star_Star_Eq_Star {a : Type}
    (R : α -&gt; α \Prop) :
    Star (Star R) = Star R :=
    by
    apply funext
    intro a
    apply funext
    intro b
    apply propext
    apply Star_Star_Iff_Star
</code></pre>
<p>我们可以更传统地用等式而不是等价关系来表达幂等性：</p>
<div class="math">$$
\begin{gathered}
\text { funext }:(\forall x, ? f x=? g x) \rightarrow ? f=? g \\
\text { propext }:(? a \leftrightarrow ? b) \rightarrow ? a=? b
\end{gathered}
$$</div>
<p>该证明使用了两个定理，这些定理之所以可用，是因为Lean的逻辑是经典的。</p>
<p>函数外延性（funext）指出，如果两个函数对所有输入都产生相同的结果，那么这两个函数必须相等。命题外延性（propext）指出，命题的等价性与相等性一致。在这些表述中，外延性意味着“所见即所得”。尽管这些性质可能看起来显而易见，但有些基于较弱直觉主义逻辑的证明助手中，这些性质通常并不成立。</p>
<p>我们将定理Star_Star_Eq_Star注册为simp规则，因为从左到右的视角来看，它确实将一个复杂的项替换为一个更简单的项。很难想象在什么情况下我们会不希望simp将Star(Star...)重写为Star...</p>
<p>对于规则归纳，我们使用归纳策略。由于一些微妙的逻辑原因，通过模式匹配和递归进行规则归纳是不被允许的，这些原因将在第12章中更加清晰。</p>
<p>在5.4节中，我们看到了一个并排展示Bool和Prop解释的图表。该图表暗示了存在无限多的命题，但我们现在知道实际上只有两个命题：False和True。以下是修订后的图表：</p>
<p><img src="img-7.jpeg" alt="img-7.jpeg"></p>
<p>我们看到只有两个命题，一个没有证明，另一个则有多个证明。图中展示了三个证明。我们将在第12章再次完善这一图景。</p>

<h3>6.4 线性算术策略</h3>
<h4>linarith</h4>
<p>linarith策略可用于证明涉及线性算术等式（<span class="math">\(\circ\)</span>）、不等式（<span class="math">\(&lt;,&gt;, \leq\)</span>，和<span class="math">\(\geq\)</span>）以及不等关系（<span class="math">\((\neq)\)</span>）的目标。线性意味着乘法和除法不会出现，或者如果出现，其中一个操作数必须是数值常量。例如，<span class="math">\(2 * x&lt;y\)</span>是一个线性约束（可以重写为<span class="math">\(x+x&lt;y\)</span>），而<span class="math">\(x * y&lt;y\)</span>是非线性的。</p>

<h3>6.5 消除</h3>
<p>给定一个归纳谓词Q，其引入规则通常具有形式<span class="math">\(\forall \ldots, \cdots \rightarrow Q \ldots\)</span>，并可用于证明形式为<span class="math">\(\vdash Q \ldots\)</span>的目标。消除则相反：它从定理或假设h : Q . . . 中提取信息。消除有多种形式：cases和induction策略、模式匹配以及消除规则（例如And.left）。</p>
<p>在<span class="math">\(h : \mathrm{Q} \ldots\)</span>上调用时，cases h策略执行的规则归纳与<span class="math">\(h\)</span>的归纳大致相同，但不会产生任何归纳假设。我们在第5章中遇到了两种习语，现在终于可以进行分析。</p>
<div class="math">$$
a: \alpha \vdash P_{a, a}[E q . r e f l a: a=a]
$$</div>
<p>第一个习语是当<span class="math">\(h\)</span>的形式为<span class="math">\(1=r\)</span>时，即Eq <span class="math">\(1 r\)</span>（第6.2节）。假设目标为<span class="math">\(h: 1=r \vdash P[h]\)</span>。第6.3节中介绍的过程会生成子目标</p>
<div class="math">$$
1: \alpha \vdash P_{1,1}
$$</div>
<p>其中<span class="math">\(\mathrm{P}_{\mathrm{t}, \mathrm{o}}[\mathrm{l}\)</span>表示P[ ]的变体，其中1和r分别被t和<span class="math">\(u\)</span>替换。（严格来说，无用的假设<span class="math">\(h: a=a\)</span>也会出现在子目标中。）实际上，<span class="math">\(P[h]\)</span>很可能不依赖于<span class="math">\(h\)</span>。此外，cases重用了名称1，而不是使用像a这样的不同名称。因此，我们会得到</p>
<p>换句话说，原目标中所有<span class="math">\(r\)</span>的出现都已被替换为1。这与我们在第5.7节中观察到的行为相对应。</p>
<div class="math">$$
\begin{gathered}
h Q: Q \vdash P[O r . i n l h Q: Q \vee \neg Q] \\
h n Q: \neg Q \vdash P[O r . i n r h n Q: Q \vee \neg Q]
\end{gathered}
$$</div>
<p>第二个惯用法是策略 cases Classical.em Q，其中 Q 是一个命题。Classical.em Q 部分是一个证明项，用于 <span class="math">\(Q \vee \neg Q\)</span>，即 Or <span class="math">\(Q(\neg Q)\)</span>（第6.2节）。然后应用 cases 来消除 <span class="math">\(\vee\)</span> 连接词。假设目标是 <span class="math">\(\vdash P[\)</span> Classical.em Q]。根据 Or 谓词的定义，新的子目标是</p>
<div class="math">$$
h Q: Q \vdash P \quad h n Q: \neg Q \vdash P
$$</div>
<p>无需修改<span class="math">\(P\)</span>，因为Or.inl hQ和Or.inr hnQ与Classical.em Q具有相同的类型，即<span class="math">\(Q \vee \neg Q\)</span>。在实际应用中，目标通常不会包含Classical.em Q，而是简单地表示为<span class="math">\(\vdash P\)</span>，然后我们会得到子目标</p>
<p>同样，这是我们在第5.7节中观察到的行为。在结构化证明中，我们可以使用匹配表达式（第5.4节）来实现与cases相同的效果。这对于逻辑符号效果很好。然而，对于像Even和Star这样的谓词，随着归纳过程中参数的变化，我们最终会得到依赖类型的模式匹配，这是微妙的（第5.10节）。通常，让cases弄清楚子目标应该是什么样子比模式匹配更容易。我们将在下面回顾两种风格的示例。</p>
<div class="math">$$
\forall x_{1} \ldots x_{n}, Q\left(c x_{1} \ldots x_{n}\right) \rightarrow(\exists \ldots, \cdots \wedge \cdots) \vee \cdots \vee(\exists \ldots, \cdots \wedge \cdots)
$$</div>
<p>展开形式为<span class="math">\(Q(c \ldots)\)</span>的假设可能很有用，其中<span class="math">\(c\)</span>是一个构造函数或其他常量。我们可以陈述并证明一个反演规则来支持这种消除推理。典型的反演规则具有以下形式</p>
<div class="math">$$
\forall x_{1} \ldots x_{n}, Q\left(c x_{1} \ldots x_{n}\right) \leftrightarrow(\exists \ldots, \cdots \wedge \cdots) \vee \cdots \vee(\exists \ldots, \cdots \wedge \cdots)
$$</div>
<p>将引入规则和消除规则结合成一个单一的定理可能很有用，该定理可用于重写假设和目标。格式相同，只是中间的连接词为<span class="math">\(\leftrightarrow\)</span>：</p>
<pre><code>theorem Even_Iff ( \(n: \mathbb{N}\) ) :
    Even \(n \leftrightarrow n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge\) Even m \():=\)
    by
    apply Iff.intro
    \{ intro hn
        cases hn with
        | zero \(\quad=&gt;\) simp
        | add_two k hk =&gt;
            apply Or.inr
            apply Exists.intro k
            simp [hk] \}
    \{ intro hor
        cases hor with
        | inl heq =&gt; simp [heq, Even.zero]
        | inr hex =&gt;
            cases hex with
            | intro k hand =&gt;
                cases hand with
                | intro heq hk =&gt;
                simp [heq, Even.add_two _ hk] \}
</code></pre>
<p>关于Even的反演规则如下：</p>
<p>与往常一样，战术性证明并不特别易读，但我们看到引入规则和消除情况策略在逻辑符号和Even谓词中都发挥了重要作用。simp策略完成了最后的润色。</p>
<pre><code>theorem Even_Iff_struct ( \(n: \mathbb{N}\) ) :
    Even \(n \leftrightarrow n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge\) Even m \():=\)
    Iff.intro
    (assume hn : Even n

    match n, hn with
    | _, Even.zero =&gt;
        show 0 = 0 V _ from
            by simp
    | _, Even.add_two k hk =&gt;
        show _ V ( }\exists\mathrm{ m, k + 2 = m + 2 ^ Even m) from
            Or.inr (Exists.intro k (by simp [*])))
(assume hor : n = 0 V ( }\exists\mathrm{ m, n = m + 2 ^ Even m)
    match hor with
    | Or.inl heq =&gt;
        show Even n from
            by simp [heq, Even.zero]
    | Or.inr hex =&gt;
        match hex with
        | Exists.intro m hand =&gt;
        match hand with
            | And.intro heq hm =&gt;
                show Even n from
                    by simp [heq, Even.add_two _ hm])
</code></pre>
<p>如果你更喜欢结构化的证明，这里是一个基于 hn : Even n 的依赖类型模式匹配的证明版本。</p>
<h3>6.6 更多示例</h3>
<p>在对归纳谓词有了更深入的理解之后，我们现在可以依次回顾四个进一步的应用。</p>
<pre><code>inductive Sorted : List }\mathbb{N} \rightarrow \text { Prop where }
    | nil : Sorted []
    | single (x : N) : Sorted [x]
    | two_or_more (x y : N) {zs : List N} (hle : x \leq y)
        (hsorted : Sorted (y :: zs)) :
    Sorted (x :: y :: zs)
</code></pre>
<h3>6.6.1 排序列表</h3>
<p>我们的第一个示例是一个谓词，用于检查一个自然数列表是否按递增顺序排序：</p>
<p>这个定义捕捉了以下数学直觉：排序列表的集合被定义为在以下规则下闭合的最小集合：(1) 列表 [] 是已排序的；(2) 给定一个数字 <span class="math">\(x\)</span>，列表 <span class="math">\([x]\)</span> 是已排序的；(3) 给定两个数字 <span class="math">\(x, y\)</span> 和一个列表 <span class="math">\(z s\)</span>，如果 <span class="math">\(x \leq y\)</span> 且 <span class="math">\(y:: z s\)</span> 是已排序的，那么 <span class="math">\(x:: y:: z s\)</span> 是已排序的。</p>
<pre><code>theorem Sorted_3_5 :
    Sorted [3, 5] :=
    by
        apply Sorted.two_or_more
        { simp }
        { exact Sorted.single _ }
</code></pre>
<p>通过在小例子中测试我们的定义总是一个好主意。列表<span class="math">\([3,5]\)</span>是已排序的吗？看起来是的：</p>
<pre><code>theorem Sorted_3_5_raw :
    Sorted [3, 5] :=
    Sorted.two_or_more _ _ (by simp) (Sorted.single _)
</code></pre>

<p>该示例使用了排序的两个引入规则。以下是使用证明项的更简洁证明：</p>

<pre><code>theorem sorted_7_9_9_11 :
    Sorted [7, 9, 9, 11] :=
    Sorted.two_or_more _ _ (by simp)
    (Sorted.two_or_more _ _ (by simp)
        (Sorted.two_or_more _ _ (by simp)
            (Sorted.single _)))
</code></pre>
<p>同样的思路可以用来证明<span class="math">\([7,9,9,11]\)</span>是有序的：</p>
<pre><code>theorem Not_Sorted_17_13 :
    ~ Sorted [17, 13] :=
    by
        intro h
        cases h with
        | two_or_more _ _ hlet hsorted =&gt; simp at hlet
</code></pre>
<p>相反，我们可以证明某些列表是未排序的。为此，我们需要进行排除：</p>
<p>从假设列表<span class="math">\([17,13]\)</span>已排序出发，我们得出不等式17 <span class="math">\(\leq 13\)</span>。cases策略默默地排除了空列表和单元素列表的情况，因为它们无法匹配一个包含两个元素的列表。然后我们调用simp来利用这个不可能成立的假设<span class="math">\(17 \leq 13\)</span>。</p>
<pre><code>inductive Palindrome \(\{\alpha\) : Type\} : List \(\alpha \rightarrow\) Prop where
    | nil : Palindrome []
    | single (x : \(\alpha\) ) : Palindrome [x]
    | sandwich (x : \(\alpha\) ) (xs : List \(\alpha\) ) (hxs : Palindrome xs) :
        Palindrome ([x] ++ xs ++ [x])
</code></pre>
<h4>6.6.2 回文</h4>
<p>回文是指从左到右和从右到左读取都相同的列表。例如，<span class="math">\([a, b, b, a]\)</span>和<span class="math">\([a, h, a]\)</span>都是回文。以下归纳谓词在且仅当传递的列表是回文时为真：</p>
<pre><code>-- fails
def palindromeRec { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; Bool
    | [] =&gt; true
    | [_] =&gt; true
    | ([x] ++ xs ++ [x]) =&gt; palindromeRec xs
    | _ =&gt; false
</code></pre>
<p>该定义区分了三种情况：(1) [ ] 是回文；(2) 对于任何元素 <span class="math">\(x\)</span>，单元素列表 <span class="math">\([x]\)</span> 是回文；(3) 对于任何元素 <span class="math">\(x\)</span> 和任何回文 <span class="math">\(\left[y_{1}, \ldots, y_{n}\right]\)</span>，列表 <span class="math">\(\left[x, y_{1}, \ldots, y_{n}, x\right]\)</span> 是回文。回文是另一个展示归纳谓词优势的例子。以下的天真递归定义无法工作，因为 [x] ++ xs ++ [x] 不是一个构造器模式，且变量 <span class="math">\(x\)</span> 被重复了：</p>
<pre><code>theorem Palindrome_reverse { }\alpha\mathrm{ : Type} (xs : List }\alpha\mathrm{ )
    (hxs : Palindrome xs) :
    Palindrome (reverse xs) :=
    by
        induction hxs with
        | nil =&gt; exact Palindrome.nil
        | single x =&gt; exact Palindrome.single x
        | sandwich x xs hxs ih =&gt;
            { simp [reverse, reverse_append]
                exact Palindrome.sandwich _ _ ih }
</code></pre>
<p>一个正确的递归定义是可能的，但超出了本指南的范围。自然地，回文的逆序也是一个回文。这是一个很好的练习：</p>
<p>非正式地：证明通过对假设hxs进行规则归纳。CASE Palindrome.nil：我们必须证明Palindrome (reverse [])。这可以通过Palindrome.nil和reverse [] = []得出。CASE Palindrome.single x：我们必须证明Palindrome (reverse [x])。这可以通过Palindrome.single和reverse <span class="math">\([x]=[x]\)</span>得出。CASE Palindrome.sandwich x xs hxs：我们必须在假设(hxs) Palindrome xs下证明Palindrome (reverse ([x] ++ xs ++ [x]))。归纳假设是Palindrome (reverse xs)。通过简化，只需证明Palindrome ([x] ++ reverse xs ++ [x])。通过Palindrome.sandwich，只需证明Palindrome (reverse xs)，这正是归纳假设。</p>
<pre><code>inductive IsFull { }\alpha\mathrm{ : Type} : Tree }\alpha\mathrm{ -&gt; Prop where
    | nil : IsFull Tree.nil
    | node (a : }\alpha\mathrm{ ) (l r : Tree }\alpha\mathrm{ )
        (hl : IsFull l) (hr : IsFull r)
        (hiff : l = Tree.nil ++ r = Tree.nil) :
    IsFull (Tree.node a l r)
</code></pre>
<h4>6.6.3 满二叉树</h4>
<p>我们的第三个例子基于第5.8节中介绍的二叉树类型。如果一棵二叉树的所有节点要么有零个子节点，要么有两个子节点，那么这棵树就是满的。这可以编码为一个归纳谓词：</p>
<p>第一种情况表明，nil树是一棵满二叉树。第二种情况表明，一棵非nil树是满二叉树，如果它有两个子树，且这两个子树本身都是满二叉树，并且它们要么都是nil，要么都是非nil。这两种情况巧妙地遵循了归纳类型的结构，因此自然可以重用nil和node这两个名称。</p>
<pre><code>theorem IsFull_singleton {\alpha : Type} (a : \alpha) :
    IsFull (Tree.node a Tree.nil Tree.nil) :=
    by
        apply IsFull.node
        { exact IsFull.nil }
        { exact IsFull.nil }
        { rfl }
</code></pre>
<p>以nil树作为子节点的树是一棵满树。这里有一个简单的证明：</p>
<pre><code>theorem IsFull_mirror { }\alpha\mathrm{ : Type} (t : Tree \alpha)
    (ht : IsFull t) :
    IsFull (mirror t) :=
    by
        induction ht with
    | nil =&gt; exact IsFull.nil
    | node a l r hl hr hiff ih_l ih_r =&gt;
        { rw [mirror]
            apply IsFull.node
            { exact ih_r }
            { exact ih_l }
            { simp [mirror_Eq_nil_Iff, *] } }
</code></pre>
<p>满树的一个更有趣的性质是，镜像操作会保持满性。我们的第一个证明是通过对ht : IsFull t进行规则归纳：</p>
<pre><code>theorem IsFull_mirror_struct_induct { }\alpha\mathrm{ : Type} (t : Tree \alpha) :
    IsFull t -&gt; IsFull (mirror t) :=
    by
        induction t with
    | nil =&gt;
        { intro ht
            exact ht }
    | node a l r ih_l ih_r =&gt;
        { intro ht
            cases ht with
            | node _ _ _ hll hr hiff =&gt;
                { rw [mirror]
                    apply IsFull.node
                    { exact ih_r hr }
                    { apply ih_l hl }
                    { simp [mirror_Eq_nil_Iff, *] } } }
</code></pre>
<p>由于 IsFull 的定义遵循 Tree 的定义，因此对树 t 进行结构归纳也是合理的。</p>

<p>这里的关键在于对假设 ht : IsFull (Tree. node a l r) 进行情况区分。cases 策略注意到 IsFull.nil 引入规则不可能用于推导 ht，因此它只生成一个对应于 IsFull. node 的情况。与往常一样，如果你在 Visual Studio Code 中检查这个策略证明，移动光标，它会更有意义。</p>

<pre><code>inductive Term ( }\alpha\beta\mathrm{ : Type) : Type where
    | var : \(\beta \rightarrow\) Term \(\alpha \beta\)
    | fn : }\alpha\mathrm{ List (Term }\alpha\beta\mathrm{ ) } \rightarrow\) Term }\alpha\beta\mathrm{ }
</code></pre>

<h4>6.6.4 一阶项</h4>
<p>我们的最后一个示例基于一阶项的归纳类型：</p>

<p>一阶项要么是一个变量<span class="math">\(x\)</span>，要么是一个函数符号<span class="math">\(f\)</span>应用于一系列参数：<span class="math">\(f\left(t_{1}, \ldots, t_{n}\right)\)</span>，其中数学变量<span class="math">\(t_{1}, \ldots, t_{n}\)</span>代表这些参数，而参数本身也是项。因此，<span class="math">\(\sin (\max (x, y))\)</span>是一个一阶项。参数<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>分别是函数符号和变量的类型。</p>
<p>并非所有项都是合法的。例如，项<span class="math">\(\min (\cos (a), \cos (a, b))\)</span>被认为是格式错误的，因为函数cos被调用的参数数量不一致（1个与2个）。除了<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>之外，我们还考虑由函数arity表示的数量：<span class="math">\(\alpha \rightarrow \mathbb{N}\)</span>，它指示每个函数符号需要多少个参数。例如，二元符号的数量为2。</p>
<pre><code>inductive WellFormed \(\{\alpha \beta\) : Type \} (arity : \(\alpha \rightarrow \mathbb{N})\) :
    Term \(\alpha \beta \rightarrow\) Prop where
    | var \((x: \beta)\) : WellFormed arity (Term.var x)
    | fn (f : \(\alpha\) ) (ts : List (Term \(\alpha \beta\) ))
        (hargs : \(\forall \mathrm{t} \in \mathrm{ts}\), WellFormed arity t )
        (hlen : length ts = arity f) :
    WellFormed arity (Term.fn f ts)
</code></pre>
<p>wellFormed谓词随后检查给定的项是否仅包含具有指定参数数量的函数符号应用：</p>
<p>变量情况表明变量总是良构的。函数情况检查参数<span class="math">\(t s\)</span>是否递归地良构，并且<span class="math">\(t s\)</span>的长度等于所讨论的函数符号<span class="math">\(f\)</span>的指定元数。</p>
<pre><code>inductive VariableFree \(\{\alpha \beta\) : Type \} : Term \(\alpha \beta \rightarrow\) Prop where
    | fn (f : \(\alpha\) ) (ts : List (Term \(\alpha \beta\) ))
        (hargs : \(\forall \mathrm{t} \in \mathrm{ts}\), VariableFree t) :
        VariableFree (Term.fn f ts)
</code></pre>

<p>一阶项的另一个有趣特性是它们是否包含变量。这可以通过一个归纳谓词轻松检查：</p>

<p>没有与 Term. var 对应的引入规则，因为变量永远不是无变量的。</p>
<h3>6.7 归纳陷阱</h3>
<p>在归纳谓词上应用归纳法时需要格外小心。归纳谓词的参数通常会在归纳过程中演变。这些细节在非正式证明中经常被忽略，但证明助手要求我们保持精确。</p>
<pre><code>inductive Even : \(\mathbb{N} \rightarrow\) Prop where
    | zero : Even \ 0
    | add_two : \(\forall \mathrm{k}: \mathbb{N}\), Even \(\mathrm{k} \rightarrow\) Even \((k+2)\)
</code></pre>
<p>回顾偶数的定义：</p>
<div class="math">$$
\vdash P \text { 0 } \quad k: \mathbb{N}, h k: P k \vdash P(k+2)
$$</div>
<p>如果目标的形式为<span class="math">\(h\)</span> : Even <span class="math">\(n \vdash P n\)</span>，对<span class="math">\(h\)</span>应用归纳法将产生以下子目标：</p>
<div class="math">$$
m: 2 * n+1, \text { hev : Even } m \vdash \text { False }
$$</div>
<p>这按预期工作。问题在于当Even的参数不是变量时。在目标hev : Even <span class="math">\((2 * n+1) \vdash\)</span> False中对假设hev应用归纳法会失败，并出现错误：目标类型中的索引不是变量（考虑使用'cases'策略代替）。为了解决这个问题，我们需要将<span class="math">\(2 * n+1\)</span>替换为变量<span class="math">\(m\)</span>，并添加一个等式<span class="math">\(m=2 * n+1\)</span>作为假设：</p>
<div class="math">$$
\begin{gathered}
m n: \mathbb{N}, h m: \emptyset=2 * n+1 \vdash \text { False } \\
m: 2 * n+1, i h: m=2 * n+1 \rightarrow \text { False, } h m: m+2=2 * n+1 \vdash \text { False }
\end{gathered}
$$</div>
<p>这个目标在逻辑上是等价的，但现在归纳法会产生两个子目标：</p>
<p>遗憾的是，第二个子目标无法被证明。问题在于我们想要在归纳假设<span class="math">\(i h\)</span>中将<span class="math">\(n\)</span>实例化为<span class="math">\(n-1\)</span>，但<span class="math">\(n\)</span>不可实例化。</p>
<div class="math">$$
\begin{gathered}
m n: \mathbb{N}, h m: \emptyset=2 * n+1 \vdash \text { False } \\
m: 2 * n+1, i h: \forall n, m=2 * n+1 \rightarrow \text { False, } h m: m+2=2 * n+1 \vdash \text { False }
\end{gathered}
$$</div>
<p>解决方案是什么？我们需要对<span class="math">\(n\)</span>进行全称量化，以便能够在归纳假设中实例化它。这是通过在归纳<span class="math">\(h\)</span>后指定泛化<span class="math">\(n\)</span>来实现的。现在我们得到了子目标</p>
<p>现在归纳假设中的变量<span class="math">\(n\)</span>与目标其余部分的变量<span class="math">\(n\)</span>断开连接，我们可以用<span class="math">\(n-1\)</span>来实例化假设中的<span class="math">\(n\)</span>。</p>
<pre><code>theorem Not_Even_two_mul_add_one (m n : N)
    (hm : m = 2 * n + 1) :
    \sim Even m :=
    by
    intro h
    induction h generalizing n with
    | zero =&gt; linarith
    | add_two k hk ih =&gt;
        apply ih (n - 1)
        cases n with
</code></pre>
<p>将所有这些结合起来，我们得到</p>
<p>| zero =&gt; simp [Nat.ctor_eq_zero] at *
| succ n' =&gt;
simp [Nat.succ_eq_add_one] at *
linarith
我们使用定理Nat.succ_eq_add_one将形式为Nat.succ n的项重写为<span class="math">\(\mathrm{n}+1\)</span>，并使用linarith策略进行简单的算术推理。当我们面对Nat.succ和加法混合的情况时，这个定理非常有用。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">funext</th>
  <th style="text-align:left">functional extensionality</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">propext</td>
  <td style="text-align:left">propositional extensionality</td>
</tr>
</tbody>
</table>
<h3>6.8 新引入的Lean结构总结</h3>
<h4>定理</h4>
<h4>策略</h4>
<p>linarith调用线性算术的过程</p>
<h2>第7章：有副作用的编程</h2>
<p>纯函数式编程有时可能感觉过于受限。有副作用的函数式编程提供了一些惯用法，可以缓解这些限制，让我们能够以带有副作用、异常、非确定性等效果的方式进行编程。</p>
<p>底层的抽象概念被称为单子（monad）。单子将带有效应的程序进行了泛化。它们在Haskell中很流行，用于编写命令式程序。在Lean中，它们被用来表达命令式程序并对其进行推理。正如我们将在第8章中看到的，它们甚至对编程Lean本身也很有用。</p>
<p>这些笔记受到《Lean编程》第7章的启发。我们还参考了《Real World Haskell》第14章，以了解有关效果式函数式编程的全面介绍。</p>
<h3>7.1 入门示例</h3>
<p>考虑以下编程任务：实现一个函数 sum257 ns，该函数对一个自然数列表 ns 的第二、第五和第七项求和。使用 Option N 作为结果类型，以便在列表项数不足时返回 Option.none。</p>
<pre><code>def nth { }\alpha\mathrm{ : Type} : List }\alpha\mathrm{ -&gt; Nat -&gt; Option }\alpha
    | [], _ =&gt; Option.none
    | x :: _, 0 =&gt; Option.some x
    | _ :: xs, n + 1 =&gt; nth xs n
def sum257 (ns : List N) : Option N :=
    match nth ns 1 with
    | Option.none =&gt; Option.none
    | Option.some n 2 =&gt;
        match nth ns 4 with
        | Option.none =&gt; Option.none
        | Option.some n 5 =&gt;
            match nth ns 6 with
            | Option.none =&gt; Option.none
            | Option.some n 7 =&gt; Option.some ( }\mp@subsup{n}{2}{}+\mathrm{n}_{5}+\mathrm{n}_{7}\right)
</code></pre>
<p>一个直接的解决方案如下：</p>
<p>（令人困惑的是，nth从0开始计数元素。）由于所有对option的模式匹配，代码显得相当不优雅。尽管这个编程任务是人为设计的，但我们都能回忆起自己写过的那些嵌套错误处理和不断增加的缩进级别的代码。</p>
<pre><code>def connect { }\alpha\mathrm{ : Type} { }\beta\mathrm{ : Type} :
    Option }\alpha\mathrm{ \rightarrow ( }\alpha\mathrm{ \rightarrow Option }\beta\mathrm{ ) }-&gt;\mathrm{ Option }\beta
    | Option.none, _ =&gt; Option.none
    | Option.some a, f =&gt; f a
</code></pre>

<p>我们可以做得更好，通过将丑陋的代码集中在一个函数中：</p>

<pre><code>def sum257Connect (ns : List N) : Option N :=
    connect (nth ns 1)
    (fun n}\mp@subsup{n}{2}{}\mapsto\mathrm{ connect (nth ns 4)
        (fun n}\mp@subsup{n}{5}{}\mapsto\mathrm{ connect (nth ns 6)
        (fun n}\mp@subsup{n}{7}{}\mapsto\mathrm{ Option.some ( }\mp@subsup{n}{2}{}+n
</code></pre>
<p>连接函数作用于一个选项。如果值是option.none，我们保持原样。这对应于一个错误条件，而错误是“粘性的”。否则，值的形式为option.some a，我们对a应用操作f——或将f的参数绑定到a。我们现在可以使用connect来编写我们的求和函数：</p>
<p>直观上，程序执行以下步骤：</p>
<ol>
<li>使用nth从列表中提取第二个项。如果没有这样的项，nth返回option. none；直接返回该值。否则，将n2绑定到该项并继续下一步。</li>
<li>对第五和第七项执行相同的操作，相应地调整。</li>
<li>返回<span class="math">\(n 2, n 5\)</span>和<span class="math">\(n 7\)</span>的和，并用option. some包装。</li>
</ol>
<p>从数学上讲，我们的新函数sum257Connect等同于原始函数sum257。</p>
<pre><code>def sum257Bind (ns : List N) : Option N :=
    bind (nth ns 1)
    (fun n}\mp@subsup{n}{2}{}\mapsto\mathrm{ bind (nth ns 4)
        (fun n}\mp@subsup{n}{5}{}\mapsto\mathrm{ bind (nth ns 6)
            (fun n}\mp@subsup{n}{7}{}\mapsto\mathrm{ pure ( }\mp@subsup{n}{2}{}+n
</code></pre>
<p>与其自己定义 connect，我们可以使用 Lean 预定义的通用 bind 操作。它接受相同的参数且顺序一致。以下是新代码：</p>
<p>我们还使用预定义的pure函数而不是option.some来将纯<span class="math">\(\alpha\)</span>值转换为option <span class="math">\(\alpha\)</span>。</p>
<pre><code>def sum2570p (ns : List N) : Option N :=
    nth ns 1 &gt;&gt;=
    fun n}\mp@subsup{n}{2}{}\mapsto\mathrm{ nth ns 4 &gt;&gt;=
        fun n}\mp@subsup{n}{5}{}\mapsto\mathrm{nth ns 6 &gt;&gt;=
            fun n}\mp@subsup{n}{7}{}\mapsto\mathrm{ pure ( }\mp@subsup{n}{2}{}+n
</code></pre>
<p>使用预定义的bind函数的一个优势在于它提供了语法糖，形式为<span class="math">\(&gt;&gt;=\)</span>运算符：</p>
<pre><code>def sum257Dos (ns : List N) : Option N :=
    do
    let }\mp@subsup{n}{2}{}\leftarrow\mathrm{ nth ns 1
    do
        let }\mp@subsup{n}{5}{}\leftarrow\mathrm{ nth ns 4
        do
            let }\mp@subsup{n}{7}{}\leftarrow\mathrm{ nth ns 6
            pure ( }\mp@subsup{n}{2}{}+{ }_{5}{}+{ }_{7}{}\)
</code></pre>
<p>语法 <span class="math">\(&gt;&gt;=\)</span> f 展开为 bind oa <span class="math">\(f\)</span>，其中 oa 的类型为 Option <span class="math">\(\alpha\)</span>。倒数第二个版本的求和程序使用了更重的语法糖：</p>
<p>do 表示法为带有副作用的程序提供了一种便捷的语法。程序 do let a <span class="math">\(\leftarrow\)</span> oa ... 等价于 oa <span class="math">\(\gg&gt;=\)</span> (fun a <span class="math">\(\mapsto \ldots\)</span> )。如果我们对 oa 的计算结果不感兴趣，可以省略 let a <span class="math">\(\leftarrow\)</span> 绑定，直接写成 do oa ...，这会展开为 oa <span class="math">\(\gg&gt;=\)</span> (fun <span class="math">\(\_\)</span> <span class="math">\(\mapsto \ldots\)</span> )。</p>
<pre><code>def sum257Do (ns : List N) : Option N :=
    do
    let n}\mp@subsup{n}{2}{}\leftarrow\mathrm{ nth ns 1
    let n}\mp@subsup{n}{5}{}\leftarrow\mathrm{ nth ns 4
    let n}\mp@subsup{n}{7}{}\leftarrow\mathrm{ nth ns 6
    pure ( }\mp@subsup{n}{2}{}+{ }_{5}{}+{ }_{7}{}\)
</code></pre>
<p>do 表示法方便地允许在单个块中进行多个 let 绑定。这使我们得到了程序的最终版本：</p>
<p>每一行带有箭头<span class="math">\(\leftarrow\)</span>的语句都尝试读取一个值。如果读取失败，整个程序将评估为option.none。</p>
<p>上述函数可以被解读为一个命令式程序，其中每次第n次调用都可能抛出异常。但尽管该符号具有命令式的风格，该函数实际上是一个纯函数式程序。</p>
<div class="math">$$
\begin{gathered}
\text { pure }\{\alpha: \text { Type }\}: \alpha \rightarrow \mathrm{m} \alpha \\
\text { bind }\{\alpha \beta: \text { Type }\}: \mathrm{m} \alpha \rightarrow(\alpha \rightarrow \mathrm{~m} \beta) \rightarrow \mathrm{m} \beta
\end{gathered}
$$</div>
<h3>7.2 两种操作与三条法则</h3>
<p>选项类型构造器是单子（monad）的一个例子，称为选项单子。一般来说，单子是一个一元类型构造器<span class="math">\(m\)</span> : Type <span class="math">\(\rightarrow\)</span> Type，它依赖于某个类型参数<span class="math">\(\alpha\)</span>，并配备两种特定的操作：</p>
<p>通常，花括号表示隐式参数。对于选项类型，pure操作就是option.some，而bind操作相当于我们的connect。</p>
<p>类型为<span class="math">\(m \alpha\)</span>的值是一个带有副作用的程序。纯操作将一个纯的、无副作用的类型为<span class="math">\(\alpha\)</span>的程序嵌入到<span class="math">\(m \alpha\)</span>中。绑定操作将两个带有副作用的程序组合在一起，这两个程序的类型分别为<span class="math">\(m \alpha\)</span>和<span class="math">\(m \beta\)</span>。第一个程序的输出类型为<span class="math">\(\alpha\)</span>，并将其传递给第二个程序。第二个程序的输出也是组合程序的输出。</p>
<p>我们可以将单子（monad）视为一个包含某些数据的盒子。这个盒子捕获了一些特殊的效果（例如，异常、可变状态）。纯操作（pure）将数据放入盒子中，而绑定操作（bind）允许我们访问盒子中的数据并修改它——甚至可能改变其类型，因为结果的类型是<span class="math">\(m \beta\)</span>，而不是<span class="math">\(m \alpha\)</span>。然而，没有通用的方法可以从盒子中提取数据——即从<span class="math">\(m \alpha\)</span>中获取<span class="math">\(\alpha\)</span>。盒子中可能没有任何<span class="math">\(\alpha\)</span>值，或者可能有多个。总结来说，pure a 是一个包含值 a 的盒子，没有任何效果，而 bind ma f（也写作 ma &gt;&gt;= f 或 do a <span class="math">\(\leftarrow \mathrm{ma}, \mathrm{f}\)</span> a）执行 ma，然后使用 ma 的未装箱结果 a 执行 f。为了方便起见，我们可以使用诸如 ma 或 mb 这样的名称来表示类型为<span class="math">\(m \alpha\)</span>或<span class="math">\(m \beta\)</span>的装箱值，并使用<span class="math">\(a\)</span>或<span class="math">\(b\)</span>来表示类型为<span class="math">\(\alpha\)</span>或<span class="math">\(\beta\)</span>的数据。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">Type</th>
  <th style="text-align:left">Effect</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">id</td>
  <td style="text-align:left">no effects</td>
</tr>
<tr>
  <td style="text-align:left">Option</td>
  <td style="text-align:left">simple exceptions</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto \sigma \rightarrow \alpha \times \sigma\)</span>
</td>
  <td style="text-align:left">threading through a state of type <span class="math">\(\sigma\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">Set</td>
  <td style="text-align:left">nondeterministic computations returning <span class="math">\(\alpha\)</span> values</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto t \rightarrow \alpha\)</span>
</td>
  <td style="text-align:left">reading elements of type <span class="math">\(t\)</span> (e.g., a configuration)</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto \mathbb{N} \times \alpha\)</span>
</td>
  <td style="text-align:left">adjoining running time (e.g., to model time complexity)</td>
</tr>
<tr>
  <td style="text-align:left">fun <span class="math">\(\alpha \mapsto\)</span> String <span class="math">\(\times \alpha\)</span>
</td>
  <td style="text-align:left">adjoining text output (e.g., for logging)</td>
</tr>
<tr>
  <td style="text-align:left">IO</td>
  <td style="text-align:left">interaction with the operating system</td>
</tr>
<tr>
  <td style="text-align:left">TacticM</td>
  <td style="text-align:left">interaction with the proof assistant</td>
</tr>
</tbody>
</table>
<p>单子是一个抽象概念，具有许多应用。选项类型只是众多实例中的一个。下表概述了一些单子实例及其效果。</p>
<p>以上所有都是一元类型构造器 m : Type <span class="math">\(\rightarrow\)</span> Type。某些效果可以组合（例如，函数 <span class="math">\(\alpha \mapsto\)</span> Option ( <span class="math">\(t \rightarrow \alpha\)</span> )）。某些效果不可执行（例如，Set）；尽管如此，它们对于抽象地建模程序仍然有用。特定的类型构造器 <span class="math">\(m\)</span> 可能提供除 pure 和 bind 之外的更多操作符。例如，它们可能提供一种提取封装值的方式。</p>

<p>单子有多个优点。它们提供了高度可读的do表示法。它们支持通用操作，例如List.mmap <span class="math">\(\{\alpha \beta\)</span> : Type <span class="math">\(\}:(x \rightarrow m \beta) \rightarrow\)</span> List <span class="math">\(\alpha \rightarrow m\)</span> (List <span class="math">\(\beta\)</span> )，这些操作对所有单子m都一致适用。引用《Lean编程》中的话：</p>

<p>抽象的力量不仅在于它提供了可以在所有这些不同实例中使用的通用函数和符号，还在于它提供了一种有助于思考它们共同点的方式。</p>
<p>除了作为一个有用的计算机科学概念外，单子还提供了一个关于公理化推理的很好例子。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { do } \\
&amp; \text { let } a^{\prime} \leftarrow \text { pure a } \quad=\quad f a \\
&amp; f a^{\prime}
\end{aligned}
$$</div>
<p>绑定和纯操作通常需要遵循三条法则。绑定操作将两个程序组合在一起。如果其中一个是纯程序，我们可以将其内联并消除绑定。这为我们提供了前两条法则：</p>
<div class="math">$$
\begin{aligned}
&amp; \text { do } \\
&amp; \text { let } a \leftarrow \mathrm{ma} \quad=\quad \mathrm{ma} \\
&amp; \text { pure a }
\end{aligned}
$$</div>

<p>以及</p>

<table>
<thead>
<tr>
  <th style="text-align:center">do</th>
  <th style="text-align:center"></th>
  <th style="text-align:center"></th>
  <th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center">let b <span class="math">\(\leftarrow\)</span>
</td>
  <td style="text-align:center"></td>
  <td style="text-align:center">do</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">do</td>
  <td style="text-align:center"></td>
  <td style="text-align:center">let a <span class="math">\(\leftarrow\)</span> ma</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">let a <span class="math">\(\leftarrow\)</span> ma</td>
  <td style="text-align:center"><span class="math">\(=\)</span></td>
  <td style="text-align:center">let <span class="math">\(b \leftarrow f a\)</span>
</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">f a</td>
  <td style="text-align:center"></td>
  <td style="text-align:center">g b</td>
  <td style="text-align:center"></td>
</tr>
<tr>
  <td style="text-align:center">g b</td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>第三条定律是绑定的结合律。它允许我们将嵌套的计算扁平化：</p>
<p>早些时候，我们将单子比作一个盒子。更具体地，可以将其想象为一个瑞士银行账户，其中<span class="math">\(\alpha:=\)</span>代表钱。第一定律意味着，如果你将一些钱存入账户，你可以将其取出。第二定律意味着，如果你取出一些钱然后又将其存回，没有人会注意到。第三定律意味着，将两个银行操作一起执行后再执行第三个操作，与先执行第一个操作再执行其他两个操作是相同的。考虑到瑞士银行在保密方面的声誉，这三条定律似乎都是合理的。</p>
<h3>7.3 类型类</h3>
<p>单子是一种数学结构，因此我们在Lean中使用类型类来指定它们。回想一下，类型类是一种参数化的结构类型，通常由类型参数化，但在这里由类型构造函数<span class="math">\(m\)</span> : Type <span class="math">\(\rightarrow\)</span> Type参数化。每当我们对具体的<span class="math">\(m\)</span>使用类型类中的字段时，类型类推断机制会检索相关的结构值——类型类实例。</p>
<pre><code>class LawfulMonad (m : Type \(\rightarrow\) Type)
    extends Pure m, Bind m where
    pure_bind \(\{\alpha \beta\) : Type \(\}(\mathrm{a}: \alpha)(\mathrm{f}: \alpha \rightarrow \mathrm{m} \beta)\) :
        (pure a \(\gg&gt;=\mathrm{f})=\mathrm{f}\) a
    bind_pure \(\{\alpha\) : Type \(\}(\) ma : \(\mathrm{m} \alpha)\) :
        (ma &gt;&gt;= pure) \(=\) ma
    bind_assoc \(\{\alpha \beta \gamma\) : Type \(\}(f: \alpha \rightarrow m \beta)(\mathrm{g}: \beta \rightarrow \mathrm{m} \gamma)\)
        (ma : \(m \alpha\) ) :
        \(((\) ma \(\gg&gt;=f) \gg&gt;=g)=(\mathrm{ma} \gg&gt;=(\mathrm{fun} \mathrm{a} \mapsto \mathrm{f} \mathrm{a} \gg&gt;=g))\)
</code></pre>
<p>单子的一个可能的Lean定义，连同三条定律，如下所示：</p>
<p>让我们逐步研究这个定义：</p>
<ul>
<li>我们正在创建一个由一元类型构造器m参数化的结构——即一个类型为Type <span class="math">\(\rightarrow\)</span> Type的值。</li>
<li>该结构继承了来自名为Pure和Bind的结构的字段以及任何语法糖。这些结构提供了m上的pure和bind操作，具有预期的类型和语法糖。</li>
<li>最后，三个字段（pure_bind、bind_pure和bind_assoc）被添加到由Pure和Bind已经提供的字段中。每个字段都是对三条定律之一的证明。</li>
</ul>
<p>我们将我们的类型类称为LawfulMonad，因为需要满足这三条定律。要实例化这个定义，我们必须提供类型构造函数m、合适的bind和pure操作符，以及这些定律的证明。</p>
<p>Lean 包含其自身的单子概念，也称为 LawfulMonad。它与我们的定义大致相同，但分布在多个类型类中。</p>

<h3>7.4 无副作用</h3>
<p>在本节及7.5至7.7节中，我们将回顾由特定单子提供的各种副作用。我们从身份单子开始，它不提供任何特殊副作用。</p>

<pre><code>def id.pure { }\alpha\mathrm{ : Type} : \alpha-&gt;\mathrm{ id }\alpha
    | a =&gt; a
def id.bind { }\alpha\beta\mathrm{ : Type} : id }\alpha-&gt;(\alpha-&gt;\mathrm{ id }\beta)-&gt;\mathrm{ id }\beta
    | a, f =&gt; f a
instance id.LawfulMonad : LawfulMonad id :=
    { pure := id.pure
        bind := id.bind
        pure_bind :=
            by
                intro }\alpha\beta\mathrm{ a f
            rfl
        bind_pure :=
            by
                intro }\alpha\mathrm{ ma
            rfl
        bind_assoc :=
            by
                intro }\alpha\beta\gamma\mathrm{ f g ma
            rfl }
</code></pre>
<p>Lean的常量id <span class="math">\(\{\alpha\)</span> : Type <span class="math">\(\}: \alpha \rightarrow \alpha\)</span>被定义为恒等函数fun <span class="math">\(x \mapsto x\)</span>。通过取<span class="math">\(\alpha:=\)</span> Type可以获得恒等类型构造函数。我们可以将其注册为一个单子：</p>
<p>注册过程需要我们提供五个组件：纯操作和绑定操作，以及三条定律的证明。</p>
<p>身份单子是最简单的单子。它提供了一个简单的盒子，里面只有一个值，没有任何效果。它在加法算术中扮演着类似于o的角色。我们可以将其他单子视为它的变体；例如，选项单子是一个身份单子，它增加了一个特殊的Option.none值，表示错误状态。</p>
<pre><code>def Option.pure { }\alpha\mathrm{ : Type} : \alpha-&gt;\mathrm{ Option }\alpha\mathrm{ :=
    Option.some
def Option.bind { }\alpha\beta\mathrm{ : Type} :
    Option }\alpha\mathrm{ -&gt; ( }\alpha\mathrm{ -&gt; Option }\beta\mathrm{ ) -&gt; Option }\beta
    | Option.none, _ =&gt; Option.none

    | Option.some a, f =&gt; f a
instance Option.LawfulMonad : LawfulMonad Option :=
    { pure := Option.pure
        bind := Option.bind
        pure_bind :=
            by
            intro }\alpha\beta\mathrm{ a f
            rfl
    bind_pure :=
        by
            intro }\alpha\mathrm{ ma
            cases ma with
            | none =&gt; rfl
            | some _ =&gt; rfl
    bind_assoc :=
        by
            intro }\alpha\beta\gamma\mathrm{ f g ma
            cases ma with
            | none =&gt; rfl
            | some _ =&gt; rfl }
</code></pre>
<h3>7.5 基本异常</h3>
<p>正如我们上面所看到的，选项类型提供了一种基本的异常机制。以下代码展示了如何将Option : Type <span class="math">\(\rightarrow\)</span> Type注册为一个合法的单子：</p>
<pre><code>def Option.throw { }\alpha\mathrm{ : Type} : Option \alpha :=
    Option.none
def Option.catch { }\alpha\mathrm{ : Type} : Option \alpha \rightarrow Option \alpha \rightarrow Option \alpha
    | Option.none, ma' =&gt; ma'
    | Option.some a, _ =&gt; Option.some a
</code></pre>
<p>这三个证明都很直接。除了标准操作之外，抛出和捕获异常也很有用。这可以通过以下方式实现：</p>
<p>Option.throw 操作会引发异常，使程序处于错误状态（Option.none）。Option.catch 操作用于从先前的异常中恢复。如果程序当前处于错误状态，option.catch 会调用一些异常处理代码（其第二个参数）。这段代码可能会再次引发新的异常。如果 Option.catch 应用于正常状态（形式为 Option.some a），则不会发生任何操作。</p>
<pre><code>do
    ~..
    if ... then
        Option.throw
    else
        ...
    .catch do
    ...
</code></pre>
<p>作为Option.catch ma ma'的便捷替代方案，Lean支持语法ma.catch ma'。以下是一个使用该语法演示抛出和捕获异常的示意性示例：</p>
<pre><code>try {
    ...
    if (...) {
        throw new UnknownException();
    } else {
        ...
    }
} catch (UnknownException e) {
    ...
}
</code></pre>
<p>对应的Java代码如下所示：</p>
<p>选项仅处理一种错误状态。一种更通用的抽象，称为错误单子，支持不同的错误，就像Java和其他编程语言中的异常一样。</p>

<h3>7.6 可变状态</h3>
<p>状态单子提供了一种与可变状态相对应的抽象。对于某些编程语言，编译器可以检测到状态单子的使用，并将使用它们的程序翻译为更高效的命令式程序。</p>

<pre><code>def welcomeNewUser (userName : String) (ctxt : Context) :
    (N}\times\mathrm{ String) \times Context :=
    let
        (user, ctxt') := createUser userName ctxt
        (password, ctxt'') := generateTemporaryPassword user ctxt'
        (ok, ctxt''') := sendUnencryptedEmail user password ctxt''
    in
        ((user, password), ctxt''')
</code></pre>
<p>诚然，“对应于可变状态的抽象”听起来可能有些抽象，因此让我们考虑一个半具体的例子。如果你有一些函数式编程的经验，你可能在某些时候写过看起来非常像这个片段的代码：</p>
<p>（通过未加密的电子邮件发送密码并忽略函数的ok状态是非常重要的。）该函数将一些全局状态或上下文作为输入，并依次调用三个函数，每个函数都接受一个上下文值并返回一些数据和一个新的上下文。上下文实际上在程序中传递。这使我们能够在没有副作用的编程语言中拥有可变状态。</p>
<pre><code>def welcomeNewUserDo (userName : String) :
    Context }-&gt;\mathrm{ (N} \times\mathrm{ String) } \times\mathrm{ Context :=
    do
        let user \leftarrow createUser userName
        let password \leftarrow generateTemporaryPassword user

    let ok \leftarrow sendUnencryptedEmail user password
pure (user, password)
</code></pre>
<p>上述方法容易出错——很容易忘记一个撇号（'）并将错误的上下文传递给函数。代码也因所有上下文变量而显得杂乱。如果我们能简单地写成以下形式会怎样？</p>
<pre><code>def Action ( }\sigma\alpha\mathrm{ : Type) : Type :=
    }\sigma\mathrm{ \rightarrow \alpha \times \sigma
</code></pre>
<p>这正是状态单子所提供的内容。状态单子建立在二元类型构造器Action之上，它捕获了在类型为<span class="math">\(\sigma\)</span>的状态上进行计算或操作的概念，并返回类型为<span class="math">\(\alpha\)</span>的值。在Lean中，Action <span class="math">\(\sigma \alpha\)</span>被定义为等于<span class="math">\(\sigma \rightarrow \alpha \times \sigma:^{1}\)</span>。</p>
<p>（由于类型是项，我们也可以使用 def 来定义类型缩写。）对于给定的类型 <span class="math">\(\sigma\)</span>，我们有 Action <span class="math">\(\sigma\)</span> : Type <span class="math">\(\rightarrow\)</span> Type 是一个单子。类型 <span class="math">\(\sigma\)</span> 抽象了具体的内存布局。例如，我们可以使用元组或列表来表示内存，并相应地实例化抽象状态 <span class="math">\(\sigma\)</span>。</p>
<p>有状态的操作是一个函数，它接受某些状态并返回一个值以及一些新状态。Action定义中的<span class="math">\(\sigma \rightarrow\)</span>部分给出了旧状态；笛卡尔积的左分量<span class="math">\(\alpha\)</span>给出了计算的结果；而积的右分量<span class="math">\(\sigma\)</span>则给出了新状态。因此，状态是隐式地贯穿整个程序的。与其他有副作用的程序一样，do表示法仅暴露数据——类型为<span class="math">\(\alpha\)</span>的值——并隐藏了副作用——旧的和新的<span class="math">\(\sigma\)</span>状态。</p>
<p>当<span class="math">\(\sigma:=\)</span> Unit时，这是一种基数为1的类型（类似于C或Java中的void），其唯一值写作( )，这对应于恒等单子：类型Unit <span class="math">\(\rightarrow \alpha \times\)</span> Unit与<span class="math">\(\alpha\)</span>同构。这种直觉可以在定义pure和bind时指导我们。</p>
<pre><code>def Action.read { }\sigma\mathrm{ : Type} : Action \sigma\sigma
    | s =&gt; (s, s)
def Action.write { }\sigma\mathrm{ : Type} (s : \sigma)\mathrm{ : Action \sigma Unit
    | _ =&gt; ((), s)
def Action.pure { }\sigma\alpha\mathrm{ : Type} (a : \alpha)\mathrm{ : Action \sigma\alpha
    | s =&gt; (a, s)
def Action.bind { }\sigma\mathrm{ : Type} { }\alpha\beta\mathrm{ : Type} (ma : Action \sigma\alpha)
            (f : }\alpha\mathrm{ \rightarrow Action \sigma\beta):
        Action \sigma\beta
    | s =&gt;
        match ma s with
        | (a, s') =&gt; f a s'
</code></pre>
<p>我们首先定义基本操作：两个操作，读取和写入，用于访问内存，以及标准的绑定和纯操作：</p>
<p>读取操作简单地返回当前状态<span class="math">\(s\)</span>（在第一个对组件中）并保持状态不变（在第二个对组件中）。写入操作将当前状态替换为<span class="math">\(s\)</span>并返回（）。纯操作返回当前状态<span class="math">\(s\)</span>不变，并与给定的值a一起组成元组。绑定操作将初始状态传递给ma参数，生成结果a和新状态s'。这些被传递给<span class="math">\(f\)</span>，它返回一个新的结果和一个新的状态。</p>
<pre><code>instance Action.LawfulMonad {\sigma: Type} :
    LawfulMonad (Action \sigma) :=
    { pure := Action.pure
        bind := Action.bind
        pure_bind :=
            by
            intro \(\alpha \beta\) a f
            rfl
    bind_pure :=
        by
            intro \(\alpha\) ma
            rfl
    bind_assoc :=
        by
            intro \(\alpha \beta \gamma\) f g ma
            rfl }
</code></pre>
<p>要将Action类型构造器注册为合法的单子，我们需要像之前一样证明三条定律：</p>
<pre><code>def increasingly : List N -&gt; Action N (List N)
    | [] =&gt; pure []
    | (n :: ns) =&gt;
        do
            let prev \leftarrow Action.read
            if n &lt; prev then
                increasingly ns
            else
                do
                    Action.write n
                    let ns' \leftarrow increasingly ns
                    pure (n :: ns')
</code></pre>
<p>作为一个具体示例，以下程序移除列表中所有小于前一个元素的元素，最终得到一个递增元素的列表。最大元素被存储为状态<span class="math">\(\sigma\)</span>。请注意如何通过读取和写入来访问状态。</p>
<pre><code>#eval increasingly [1, 2, 3, 2] 0
#eval increasingly [1, 2, 3, 2, 4, 5, 2] 0
</code></pre>
<p>要执行该程序，我们必须提供一个初始状态。最终状态将与结果列表一起返回。它对应于列表中遇到的最大元素或起始状态。因此，命令</p>
<div class="math">$$
\begin{aligned}
&amp; ([1,2,3], 3) \\
&amp; ([1,2,3,4,5], 5)
\end{aligned}
$$</div>
<p>生成输出</p>
<h3>7.7 非确定性</h3>
<p>虽然选项单子存储零个或一个<span class="math">\(\alpha\)</span>值，且恒等单子和状态单子存储恰好一个值，但集合单子存储可能无限数量的值。这对于建模非确定性非常有用，因为它可以表示一组可能的行为。</p>
<p>Lean 中的类型 Set <span class="math">\(\alpha\)</span> 被定义为 <span class="math">\(\alpha \rightarrow\)</span> Prop。换句话说，集合由其特征谓词标识。常见的操作符如空集 <span class="math">\((\emptyset)\)</span>、全集 (Set.univ)、并集 <span class="math">\((\cup)\)</span>、交集 <span class="math">\((\cap)\)</span> 和成员关系 <span class="math">\((\in)\)</span> 都得到支持，以及传统的花括号表示法，如 <span class="math">\(\{a\},\{a, b\}\)</span> 和 <span class="math">\(\{x \mid\)</span> <span class="math">\(P \times\}\)</span>。许多集合构造可以通过 simp 进行简化。</p>
<pre><code>def Set.pure { }\alpha\mathrm{ : Type} : \alpha \rightarrow \text { Set }\alpha
    | a =&gt; {a}
def Set.bind { }\alpha\beta\mathrm{ : Type} : Set }\alpha\mathrm{ \rightarrow ( }\alpha\mathrm{ \rightarrow Set }\beta\mathrm{ ) } \rightarrow \text { Set }\beta
    | A, f =&gt; {b | | |a, a \in A \wedge b \in f a}
instance Set.LawfulMonad : LawfulMonad Set :=
    { pure := Set.pure
        bind := Set.bind
        pure_bind :=
            by
            intro }\alpha\beta\mathrm{ a f
            simp [Pure.pure, Bind.bind, Set.pure, Set.bind]
    bind_pure :=
        by
            intro }\alpha\mathrm{ ma
            simp [Pure.pure, Bind.bind, Set.pure, Set.bind]
    bind_assoc :=
        by
            intro }\alpha\beta\mathrm{ \gamma f g ma
            simp [Pure.pure, Bind.bind, Set.pure, Set.bind]
            apply Set.ext
            aesop }
</code></pre>
<p>Set类型构造函数可以注册为一个合法的单子，如下所示：</p>
<p>纯操作简单地将给定值a放入单例集合<span class="math">\(\{\mathrm{a}\}\)</span>中。绑定操作对集合<span class="math">\(A\)</span>中的所有值调用<span class="math">\(f\)</span>，并返回所有结果的并集。例如，如果<span class="math">\(A:=\{3,8\}\)</span>且<span class="math">\(f:=\)</span> (fun a <span class="math">\(\mapsto\{a \cdot 1, a \cdot 2\}\)</span> )，那么Set.bind A f等于<span class="math">\(\{4,5,9,10\}\)</span>。</p>
<p>请注意，在这三个证明中，我们展开了通用的pure和bind常量的定义，随后是Set.pure和Set.bind的定义。</p>
<p>最后一个证明依赖于集合外延性，该原理指出包含相同元素的两个集合必须相等：</p>
<div class="math">$$
\begin{aligned}
&amp; \forall x, x \in b|\exists a,(\exists a \_1, a \_1 \in m a \wedge a \in f a \_1) \wedge b \in g a \\
&amp; \quad \leftrightarrow x \in b \mid \exists a, a \in m a \wedge \exists a \_1, a \_1 \in f a \wedge b \in g a \_1
\end{aligned}
$$</div>
<p>Set.ext <span class="math">\(\{\alpha\)</span> : Type <span class="math">\(\}\{A B:\)</span> set <span class="math">\(\alpha\}:(\forall x, x \in A \leftrightarrow x \in B) \rightarrow A=B\)</span> 另一个值得注意的点是aesop策略的使用。目标的目标是</p>
<p>其中<span class="math">\(\leftrightarrow\)</span>的两边除了存在量词的位置（以及令人困惑的是，绑定变量的名称）外是相同的。这个丑陋的命题可以通过一系列繁琐的引入和消除步骤来证明，但我们值得拥有更多的自动化。</p>
<h3>7.8 Aesop策略</h3>
<h4>aesop</h4>
<p>aesop策略，其名称代表“自动化可扩展的明显证明搜索”，是一种通用的证明搜索策略。其中，它在假设中执行逻辑符号<span class="math">\(\wedge, \vee, \leftrightarrow\)</span>和<span class="math">\(\exists\)</span>的消除，并在目标中引入<span class="math">\(\wedge, \leftrightarrow\)</span>和<span class="math">\(\exists\)</span>，并且它经常调用simp。它可以成功证明一个目标，失败，或者部分成功，留下一些未完成的子目标给用户。</p>
<pre><code>def nthsFine { }\alpha\mathrm{ : Type} (xss : List (List }\alpha\mathrm{ ) (n : N) :
    List (Option }\alpha\mathrm{ ) :=
    List.map (fun xs }\mapsto\mathrm{ nth xs n) xss
</code></pre>
<h3>7.9 通用算法：列表迭代</h3>
<p>假设我们使用 map 对列表中的所有元素应用一个带副作用的函数 <span class="math">\(f\)</span>。然后我们将得到一个包含带副作用值的常规列表。例如：</p>
<pre><code>#eval nthsFine [[11, 12, 13, 14], [21, 22, 23]] 2
</code></pre>
<p>函数 nthsFine xss n 尝试提取 xss 中每个列表的第 <span class="math">\((n+1)\)</span> 个元素。</p>
<pre><code>def mmap {m : Type }-&gt;\mathrm{ Type} [LawfulMonad m] { }\alpha\beta\mathrm{ : Type}
    (f : }\alpha\mathrm{ \rightarrow m \beta) :
    List }\alpha\mathrm{ \rightarrow m (List }\beta\mathrm{ )
    | [] =&gt; pure []
    | a :: as =&gt;
        do
            let b \leftarrow f a
            let bs \leftarrow mmap f as
            pure (b :: bs)
</code></pre>
<p>返回 [Option. some 13, Option. some 23]。这些 Option. some 构造函数可能会带来不便。通常，我们只关心是否出现任何错误。这引导我们到最后一个示例：一个通用的带效用的程序 mmap，它遍历列表并对每个元素应用一个带效用的函数 <span class="math">\(f\)</span>。该定义是递归的：</p>
<p>请注意，该函数返回一个包含列表的单一<span class="math">\(m\)</span>值，而不是<span class="math">\(m\)</span>值的列表。尝试理解为什么它是类型良好的，并且具有预期的行为。</p>
<pre><code>def nthsCoarse { }\alpha\mathrm{ : Type} (xss : List (List }\alpha\mathrm{ ) (n : N) :
    Option (List }\alpha\mathrm{ ) :=
    mmap (fun xs }\mapsto\mathrm{ nth xs n) xss
</code></pre>
<p>我们现在可以尝试使用mmap代替List.map：</p>
<pre><code>theorem mmap_append \{m : Type \(\rightarrow\) Type\} [LawfulMonad m]
    \(\{\alpha \beta\) : Type \} (f : \(\alpha \rightarrow \mathrm{m} \beta\) ) :
    Yas as' : List \(\alpha\), mmap f (as ++ as') =
        do
            let bs \(\leftarrow\) mmap f as
            let bs' \(\leftarrow\) mmap f as'
            pure (bs ++ bs')
    | [], _ =&gt;
    by simp [mmap, LawfulMonad.bind_pure, LawfulMonad.pure_bind]
    | a :: as, as' =&gt;
    by simp [mmap, mmap_append _ as as', LawfulMonad.pure_bind,
        LawfulMonad.bind_assoc]
</code></pre>
<p>运行
#eval nthsCoarse [[11, 12, 13, 14], [21, 22, 23]] 2
返回 Option.some [13, 23]，其中包含一个单一的 Option.some 包裹一个纯列表。
mmap 函数分布在追加运算符 ++ 上。do 表示法不仅对定义函数有用，还对陈述它们的属性有用：</p>

<h3>7.10 新引入的Lean结构总结</h3>
<h4>符号</h4>
<p>do 表示一个有效程序的开始
let ... <span class="math">\(\leftarrow\)</span>... 在有效程序中赋值一个变量
&gt;&gt;= 组合有效计算</p>


<h4>定理</h4>
<p>Set.ext 集合外延性</p>

<h4>策略</h4>
<p>aesop 使用通用搜索程序来证明命题</p>
<h2>第8章：元编程</h2>
<p>与大多数证明助手一样，Lean可以通过自定义策略和其他功能进行扩展。编程Lean本身，而不仅仅是使用它，被称为元编程。Lean的元编程框架主要使用与Lean输入语言相同的概念和语法，因此我们不需要学习另一种语言来编程Lean。单子用于访问Lean的状态。</p>
<p>抽象语法树以归纳类型的形式呈现，反映了内部数据结构。证明助手的内部机制通过Lean函数暴露，我们可以使用这些函数来访问当前目标、统一术语、查询和修改全局上下文，以及设置属性（例如，@[simp]）。</p>
<p>以下是元编程的一些应用示例：</p>
<ul>
<li>目标转换（例如，应用安全引入规则，将目标转换为否定范式）；</li>
<li>启发式证明搜索（例如，应用带回溯的不安全引入规则）；</li>
<li>决策过程（例如，用于线性算术、命题逻辑）；</li>
<li>定义生成器（例如，Haskell风格的归纳类型派生）；</li>
<li>顾问工具（例如，定理查找器、反例生成器）；</li>
<li>导出工具（例如，文档生成器）；</li>
<li>临时证明自动化（以避免样板代码或重复）。</li>
</ul>
<p>正如数学家和Lean用户凯文·巴扎德所写：<span class="math">\({ }^{1}\)</span>如果你发现自己“苦战”（借用电子游戏术语），一遍又一遍地做同样的事情，因为你需要这样做才能取得进展，那么你可以尝试说服一位计算机科学家为你编写一个策略来完成它（或者如果你足够勇敢去编写元Lean代码，甚至可以自己编写策略）。</p>
<h3>8.1 策略组合器</h3>
<p>首先，一些术语：如果应用策略时产生错误，则该策略失败；否则，它成功。策略成功的一种方式是完全证明目标。另一种方式是生成新的子目标来替换当前目标。有些策略通过不执行任何操作而成功。</p>
<pre><code>theorem repeat'_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        repeat' apply Even.add_two
</code></pre>
<p>在编写我们自己的策略时，我们经常需要在多个目标上重复某些操作，或者在策略失败时进行恢复。策略组合器在这种情况下非常有用。其中最有用的策略组合器之一是repeat'策略。它在所有目标上重复调用策略，然后在出现的子目标上调用，接着在出现的子子目标上调用，依此类推，直到策略在所有可用目标上失败。以下是一个涉及第6章中介绍的Even谓词的repeat'示例：</p>
<div class="math">$$
\vdash \text { Even } 4 \quad \vdash \text { Even } 7 \quad \vdash \text { Even } 3 \quad \vdash \text { Even } 0
$$</div>
<p>在第一个repeat'行之后，证明状态包含四个目标：</p>
<div class="math">$$
\vdash \text { Even } 0 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 0
$$</div>
<p>注意所有的合取都已消失。第二个repeat'，它反复应用定理Even.add_two：<span class="math">\(\forall \mathrm{k}\)</span>, Even <span class="math">\(\mathrm{k} \rightarrow\)</span> Even <span class="math">\((\mathrm{k}+2\)</span> )，最终给我们留下了这些目标：</p>
<pre><code>theorem repeat'_first_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        repeat'
            first
            | apply Even.add_two
            | apply Even.zero
</code></pre>
<p>第一个和最后一个目标令人烦恼，因为它们对应于定理 Even.zero。我们可以在应用 Even.add_two 失败时尝试应用 Even.zero 来证明它们。具体实现如下：</p>
<div class="math">$$
\vdash \text { Even } 1 \quad \vdash \text { Even } 1
$$</div>
<p>策略组合子 first <span class="math">\(\mid\)</span> tactic <span class="math">\(_{1}|\cdots|\)</span> tactic <span class="math">\(_{n}\)</span> 首先尝试执行其第一个参数，即策略 <span class="math">\(_{1}\)</span>。如果失败，则尝试策略 <span class="math">\(_{2}\)</span>，依此类推。如果所有指定的策略都失败，则整个组合子失败。在上面的例子中，我们剩下两个无法证明的目标：</p>
<pre><code>theorem all_goals_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        all_goals apply Even.add_two -- fails
</code></pre>
<p>下一个组合子，all_goals tactic，会在每个目标上精确地调用一次策略。只有当策略在所有目标上都成功时，该组合子才会成功。在下面的示例中，它会失败，因为Even.add_two无法应用于目标<span class="math">\(\vdash\)</span> Even <span class="math">\(\omega\)</span>：</p>
<pre><code>theorem all_goals_try_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        all_goals try apply Even.add_two
</code></pre>
<p>为了忽略策略的失败，我们可以将其包裹在try组合子中：</p>
<div class="math">$$
\vdash \text { Even } 2 \quad \vdash \text { Even } 5 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 0
$$</div>
<p>最终的状态是</p>
<p>构造 try tactic 相当于 first | tactic | skip，其中 skip 是一个不执行任何操作但成功的 tactic。因此，try tactic 总是成功。一个相关的 tactic 是 done：如果没有剩余目标，则成功，否则失败。</p>
<pre><code>theorem any_goals_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        any_goals apply Even.add_two
</code></pre>
<p>另一个变体是any_goals策略组合器。它尝试在每个目标上调用策略一次，但与all_goals不同，它在策略在任何目标上成功时即成功。示例</p>
<div class="math">$$
\vdash \text { Even } 2 \quad \vdash \text { Even } 5 \quad \vdash \text { Even } 1 \quad \vdash \text { Even } 0
$$</div>
<p>导致状态</p>
<p>这与前一个示例中的状态相同。一般来说，区别在于any_goals策略可能会失败，而all_goals try策略总是成功。</p>
<pre><code>theorem any_goals_solve_repeat_first_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        repeat' apply And.intro
        any_goals
            solve
            | repeat'
                first
                | apply Even.add_two
                | apply Even.zero
</code></pre>
<p>有时我们希望除非能够完全证明一个目标，否则就将其保留。组合子 solve <span class="math">\(\mid\)</span> tactic <span class="math">\(_{1}|\cdots|\)</span> tactic <span class="math">\(_{n}\)</span> 首先尝试执行其第一个参数，即 tactic <span class="math">\(_{1}\)</span>。如果这未能证明目标，则尝试 tactic <span class="math">\(_{2}\)</span>，依此类推。如果所有指定的策略都未能证明目标，则整个组合子失败。（将此行为与 first <span class="math">\(\mid\)</span> tactic <span class="math">\(_{1}|\cdots|\)</span> tactic <span class="math">\(_{n}\)</span> 的行为进行比较，后者只需要其中一个指定的策略成功，而不需要证明目标。）考虑以下示例：</p>
<div class="math">$$
\vdash \text { Even } 7 \quad \vdash \text { Even } 3
$$</div>

<p>第一个和第四个目标被证明，我们剩下两个无法证明的目标，正如定理陈述中所呈现的那样：</p>

<pre><code>theorem repeat'_Not_example :
    \ Even 1 :=
    by repeat' apply Not.intro
</code></pre>
<p>请注意，repeat' 组合子可能导致无限循环。考虑以下示例：</p>
<p>Not.intro 规则是（<span class="math">\(? \mathrm{a} \rightarrow\)</span> False <span class="math">\() \rightarrow \neg\)</span> ?a，因此它应用一次将目标转换为<span class="math">\(\vdash\)</span> Even <span class="math">\(1 \rightarrow\)</span> False。由于<span class="math">\(\neg\)</span> ?a 被定义为<span class="math">\(? a \rightarrow\)</span> False，该规则再次应用，产生相同的目标。策略进入循环。</p>
<pre><code>by
    induction n &lt;;&gt;
        aesop
</code></pre>
<p>最后，"然后"操作符&lt;; &gt;可用于连接两个策略。左侧策略在第一个目标上执行，右侧策略在每个新出现的子目标上执行（但不在原始的第二目标、第三目标等上执行）。因此，我们可以写成</p>
<pre><code>by
    induction n with
    | zero =&gt; aesop
    | succ n' ih =&gt; aesop
</code></pre>

<p>而不是更冗长的</p>

<pre><code>macro "intro_and_even" : tactic =&gt;
    '(tactic|
        (repeat' apply And.intro
        any_goals
            solve
            | repeat'
                first
                | apply Even.add_two
                | apply Even.zero))
</code></pre>
<h3>8.2 宏</h3>
<p>让我们通过编写一个自定义策略作为宏来进行一些实际的元编程。该策略体现了我们在上面的解决示例中硬编码的行为：</p>
<p>第一行声明intro_and_even为一个属于tactic语法类别的宏。在其余行中，'(tactic| tactic)构造将指定的tactic嵌入到宏中。tactic本身使用标准语法指定。</p>
<pre><code>theorem intro_and_even_example :
    Even 4 ^ Even 7 ^ Even 3 ^ Even 0 :=
    by
        intro_and_even
</code></pre>
<p>一旦我们定义了自定义策略，就可以在证明中调用它：</p>
<p>这将生成子目标</p>
<h3>8.3 元编程单子</h3>
<p>宏是一种可用于编写简单证明自动化的机制。然而，对于大多数元编程任务，我们需要使用元编程单子，即MetaM和TacticM。</p>
<p>MetaM 结合了多种单子的特性：</p>
<ul>
<li>它是一个状态单子，提供对全局上下文（包括所有定义和归纳类型）、符号和属性（例如，@[ simp ] 定理列表）等的访问。</li>
<li>它的行为类似于选项单子。元编程失败表示某个策略已失败。</li>
<li>它支持追踪，因此我们可以使用程序 logInfo 来显示消息。</li>
<li>它支持命令式结构，如 for-in 循环、continue 语句和 return 语句。TacticM 扩展了 MetaM 的目标管理功能：它提供对目标列表的访问。它还允许我们运行 Lean 来填充表达式中的隐式 { } 和类型类 [ ] 参数，扩展宏等。</li>
</ul>
<p>在Lean内部，每个目标都表示为一个元变量?m，代表一个缺失的项（通常是一个证明项）。每个元变量都有一个类型（通常是一个命题）和一个局部上下文，指定了可用于证明与元变量关联的目标的变量和假设。</p>
<pre><code>def traceGoals : TacticM Unit :=
    do
        logInfo m!"Lean version {Lean.versionString}"
        logInfo "All goals:"
        let goals \leftarrow getUnsolvedGoals
        logInfo m!"{goals}"
        match goals with
        | [] =&gt; return
        | _ :: _ =&gt;
            logInfo "First goal's target:"
            let target \leftarrow getMainTarget
            logInfo m!"{target}"
elab "trace_goals" : tactic =&gt;
    traceGoals
</code></pre>
<p>让我们通过定义一个使用TacticM的跟踪功能来显示Lean版本号、目标列表以及第一个目标（Lean称之为主目标）的战术，来将TacticM付诸实践：</p>
<p>代码有许多有趣的特点：</p>
<ul>
<li>第一行声明了一个类型为 TacticM Unit 的函数 traceGoals——返回 Unit（一种基数为一的平凡类型）的策略类型。请注意，元编程函数使用与任何 Lean 函数相同的语法定义。</li>
<li>第二行进入单子。剩下的行是访问 Lean 内部的有副作用操作。- m!"..." 语法指定了一个字符串，其中每个 {term} 的出现（term 是一个 Lean 术语）都会被评估并序列化为字符串。例如，如果 Lean.versionString 是 "v4.14.0"，那么 m!"Lean version {Lean. versionString}" 会评估为字符串 "Lean version v4.14.0"。</li>
<li>最后两行使用 elab 命令，告诉 Lean 的解析器将字符串 "trace_goals" 识别为一个策略。当 Lean 遇到这个策略时，它会运行 elab 命令体中的元编程（这里是 traceGoals）。以下是我们如何使用新策略的示例：</li>
</ul>
<pre><code>theorem Even_18_and_Even_20 ( \(\alpha\) : Type) (a : \(\alpha\) ) :
    Even \(18 \wedge\) Even \(20:=\)
    by
    apply And.intro
    trace_goals
    intro_and_even
</code></pre>
<pre><code>Lean version v4.14.0
All goals:
[case left
\alpha: Type
a : \alpha
\ Even 18,
    case right
\alpha: Type
a : \alpha
\ Even 20]
First goal's target:
Even 18
</code></pre>
<p>输出结果通过悬停在trace_goals上可见，如下所示：</p>
<p>尽管 Lean 使用熟悉的目标语法 C <span class="math">\(\vdash \mathrm{P}\)</span> 来显示目标，但它们实际上是元变量。</p>
<div class="math">$$
\begin{gathered}
\text { logInfo : MessageData } \rightarrow \text { TacticM Unit } \\
\text { getUnsolvedGoals : TacticM (List MVarId) } \\
\text { getMainTarget : TacticM Expr }
\end{gathered}
$$</div>
<p>上述程序中使用的常量具有以下类型：</p>
<p>其中MessageData表示消息，MVarId表示元变量标识符，Expr表示一个项。</p>
<pre><code>def hypothesis : TacticM Unit :=
    withMainContext
        (do

    let target \leftarrow getMainTarget
    let lctx \leftarrow getLCtx
    for ldecl in lctx do
        if ! LocalDecl.isImplementationDetail ldecl then
            let eq \leftarrow isDefEq (LocalDecl.type ldecl) target
            if eq then
                let goal \leftarrow getMainGoal
                MVarId.assign goal (LocalDecl.toExpr ldecl)
                return
    failure)
elab "hypothesis" : tactic =&gt;
    hypothesis
</code></pre>
<h3>8.4 第一个示例：假设策略</h3>
<p>我们的第一个较大示例实现了一个假设策略，类似于预定义的假设策略，它寻找正确类型（即正确命题）的假设并应用它来证明目标：</p>
<p>在假设函数中，我们首先提取第一个目标的目标和局部上下文。为了确保get LCtx获取到当前第一个目标的局部上下文，我们将整个do块传递给withMainContext函数。一般来说，任何TacticM计算都是在赋予表达式中自由变量意义的局部上下文中执行的。withMainContext函数将此局部上下文设置为当前第一个目标的局部上下文。</p>
<p>在do块内部，我们使用方便的monadic构造for-in遍历本地上下文中的所有声明。对于每个不是所谓的实现细节的本地变量或假设<span class="math">\(h\)</span>（即由Lean插入的、对用户不可见的假设），我们检查其类型（通常是其命题）是否在计算和元变量实例化后与目标相等，如果是，则获取与第一个目标关联的元变量?m并赋值?m <span class="math">\(:=h\)</span>，从而证明该目标。最后，我们返回。</p>
<p>由于目标由元变量表示，将项分配给元变量 ?m 是 Lean 底层证明目标的方式。该术语中出现的新元变量对应于必须证明的新子目标。</p>
<pre><code>theorem hypothesis_example {\alpha : Type} {p : \alpha -&gt; Prop} {a : \alpha}
    (hpa : p a) :
    p a :=
    by hypothesis
</code></pre>
<p>一个简单的假设调用如下：</p>
<p>如果我们添加追踪，可以看到在找到匹配的假设hpa并成功应用之前，依次尝试了<span class="math">\(\alpha, \mathrm{p}\)</span>和a。</p>
<pre><code>getLCtx : TacticM LocalContext
LocalDecl.isImplementationDetail : LocalDecl -&gt; Bool
    isDefEq : Expr -&gt; Expr -&gt; TacticM Bool
    LocalDecl.type : LocalDecl -&gt; Expr
        getMainGoal : TacticM MVarId
    MVarId.assign : MVarId -&gt; Expr -&gt; TacticM Unit
    LocalDecl.toExpr : LocalDecl -&gt; Expr
    failure { }\alpha:\text { Type} : TacticM }\alpha
</code></pre>

<p>该示例使用了以下新常量：</p>

<h3>8.5 表达式</h3>
<p>元编程框架围绕表达式或项的Expr类型展开。表达式的重要组成部分是名称，即Name类型。我们从它们开始。</p>
<p>名称可以使用单个反引号来指定。例如，' <span class="math">\(x\)</span> 表示名称 <span class="math">\(x\)</span>，可以将其赋予变量或常量。当引用常量时，我们必须指定完整的名称，包括命名空间；因此，要引用第6章的Even谓词，我们必须写成'LoVe.Even，而不是'Even。</p>
<p>如果我们想引用一个已存在的常量，Lean提供了双反引号语法，它会根据Lean通常的名称解析规则查找名称并将其扩展为完整名称。因此，''Even和''LoVe.Even都指向名称LoVe.Even，如果我们写了一个未声明的名称，例如''EvenIf，Lean会报错。</p>
<pre><code>inductive Expr : Type where
    | const : Name \(\rightarrow\) List Level \(\rightarrow\) Expr
    | sort : Level \(\rightarrow\) Expr
    | fvar : FVarId \(\rightarrow\) Expr
    | mvar : MVarId \(\rightarrow\) Expr
    | app : Expr \(\rightarrow\) Expr \(\rightarrow\) Expr
    | lam : Name \(\rightarrow\) Expr \(\rightarrow\) Expr \(\rightarrow\) BinderInfo \(\rightarrow\) Expr
    | bvar : Nat \(\rightarrow\) Expr
    | forallE : Name \(\rightarrow\) Expr \(\rightarrow\) Expr \(\rightarrow\) BinderInfo \(\rightarrow\) Expr
    | letE : Name \(\rightarrow\) Expr \(\rightarrow\) Expr \(\rightarrow\) Expr \(\rightarrow\) Bool \(\rightarrow\) Expr
    | lit : Literal \(\rightarrow\) Expr
    | mdata : MData \(\rightarrow\) Expr \(\rightarrow\) Expr
    | proj : Name \(\rightarrow\) Nat \(\rightarrow\) Expr \(\rightarrow\) Expr
</code></pre>
<p>类型 Expr 的定义如下：</p>
<p>让我们回顾一下主要的构造函数：</p>
<ul>
<li>
<p>Expr. const name levels 表示一个名为 name 的常量，例如 Nat.add 或 <span class="math">\(\mathbb{N}\)</span>。levels 参数表示宇宙层级，这个概念将在第12章中解释。例如，Expr. const ''Nat.add [] 表示 Nat.add，而 Expr. const ''Nat [] 表示 Nat（即 <span class="math">\(\mathbb{N}\)</span>）。</p>
</li>
<li>
<p>Expr.sort level 用于表示类型的类型。例如，Expr. sort Level. zero 表示 Prop，而 Expr. sort (Level. succ Level. zero) 表示 Type。</p>
</li>
<li>
<p>Expr.fvar id 表示局部上下文中的自由变量（例如，a, h）。id 参数是变量的唯一标识符。</p>
</li>
<li>
<p>Expr.mvar id 表示一个元变量，即带有问号的变量 ?m。id 参数是元变量的唯一标识符。</p>
</li>
<li>
<p>Expr.app t u 表示函数 <span class="math">\(t\)</span> 对参数 <span class="math">\(u\)</span> 的应用。例如，Expr.app (Expr. const ''Nat.succ [](Expr. const ''Nat. zero []) 表示 Nat. succ Nat. zero。</p>
</li>
<li>
<p>Expr.lam name <span class="math">\(\sigma\)</span> t bi 表示一个匿名函数（或 <span class="math">\(\lambda\)</span>-表达式）。name 参数是绑定变量的名称，<span class="math">\(\sigma\)</span> 参数是绑定变量的类型，<span class="math">\(t\)</span> 参数是函数体，bi 参数存储变量是显式（ ）、隐式 { } 还是类型类 [ ] 参数。</p>
</li>
<li>
<p>Expr.bvar i 表示一个绑定变量，使用一种称为德布鲁因索引的表示法。Expr. var <span class="math">\(\theta\)</span> 指的是由最近的绑定器绑定的变量，Expr.var 1 指的是由第二近的绑定器绑定的变量，依此类推。因此，</p>
</li>
</ul>
<pre><code>Expr.lam 'x (Expr.const ''Nat []) (Expr.bvar \(\theta\) )
    BinderInfo.default
</code></pre>
<pre><code>Expr.lam 'x (Expr.const ''Nat [])
    (Expr.lam 'y (Expr.const ''Nat []) (Expr.bvar 1)
        BinderInfo.default)
    BinderInfo.default
</code></pre>
<p>表示函数<span class="math">\(x: \mathbb{N} \mapsto x\)</span>，并且</p>

<p>表示函数 <span class="math">\(x y: \mathbb{N} \mapsto x\)</span>。</p>
<ul>
<li>Expr.forallE 名称 <span class="math">\(\sigma \tau\)</span> bi 表示一个可能依赖的函数类型。名称参数是绑定变量的名称，<span class="math">\(\sigma\)</span> 参数是定义域类型，<span class="math">\(\tau\)</span> 参数是结果类型，bi 与上述 Expr.lam 中的相同。例如，</li>
</ul>

<pre><code>Expr.forallE 'n (Expr.const ''Nat [])
    (Expr.app (Expr.const ''Even []) (Expr.bvar \(\theta\) ))
    BinderInfo.default
</code></pre>
<pre><code>Expr.forallE 'dummy (Expr.const 'Nat [])
    (Expr.const 'Bool []) BinderInfo.default
</code></pre>
<p>表示<span class="math">\((n: \mathbb{N}) \rightarrow\)</span> Even <span class="math">\(n\)</span>（也可写作<span class="math">\(\forall n: \mathbb{N}\)</span>, Even <span class="math">\(n\)</span>），并且</p>
<p>表示 <span class="math">\(\mathbb{N} \rightarrow\)</span> 布尔类型。</p>
<pre><code>theorem abc_a (a b c : Prop) (h : a ^ b ^ c) :
    a :=
    And.left h
theorem abc_b (a b c : Prop) (h : a ^ b ^ c) :
    b :=
    And.left (And.right h)
theorem abc_bc (a b c : Prop) (h : a ^ b ^ c) :
    b ^ c :=
</code></pre>
<h3>8.6 第二个示例：合取消解策略</h3>
<p>在本节及下一节中，我们将定义两个进一步完成明确任务的策略。这两个策略中的第一个，称为destruct_and，用于自动化前提中合取的消除。我们的目标是自动化如下证明：</p>
<pre><code>theorem abc_c (a b c : Prop) (h : a ^ b ^ c) :
    c :=
    And.right (And.right h)
</code></pre>
<p>And.right h</p>
<pre><code>partial def destructAndExpr (hP : Expr) : TacticM Bool :=
    withMainContext
        (do
            let target \leftarrow getMainTarget
            let P \leftarrow inferType hP
            let eq \leftarrow isDefEq P target
            if eq then
                let goal \leftarrow getMainGoal
                MVarId.assign goal hP
                return true
            else
                match Expr.and? P with
            | Option.none =&gt; return false
            | Option.some (Q, R) =&gt;
                let hQ \leftarrow mkAppM ''And.left #[hP]
                let success \leftarrow destructAndExpr hQ
                if success then
                    return true
                else
                    let hR \leftarrow mkAppM ''And.right #[hP]
                    destructAndExpr hR)
</code></pre>
<p>在每种情况下，我们希望通过简单地使用<code>destruct_and h</code>作为证明来书写。我们的策略依赖于一个辅助函数，该函数以证明项<code>hP</code>（最初为假设<code>h</code>）作为参数，从中我们提取合取项：</p>
<p>与假设类似，我们将整个do块传递给withMainContext函数。这确保了inferType和isDefEq在正确的局部上下文中操作。在do块内部，我们首先提取第一个目标的目标和hP的类型（通常是其命题）P。如果它们在计算和元变量实例化后相等，我们通过为其元变量赋值来关闭目标，就像在假设示例中所做的那样，并返回true以表示成功。否则，我们检查hP的命题是否为<span class="math">\(Q \wedge R\)</span>的形式。如果是，我们递归调用辅助函数，使用证明项hQ : = And.left hP，即Q的证明。如果这成功，我们就完成了；否则，我们尝试使用证明项hR : = And.right hP，即R的证明。</p>
<p>注意函数定义开头的关键字partial。这里需要它，因为Lean无法证明函数总是终止。由于该函数仅作为元程序使用，而不是在命题内部，终止是可选的，我们可以通过指定partial来禁用终止检查。</p>
<p>同样值得注意的是mkAppM函数，它用于构造一个将常量应用于参数数组的携带应用。数组与列表类似，但前缀带有符号#（例如，#[1, 2, 3]）。使用mkAppM比多次应用Expr.app构造函数更为方便。此外，mkAppM允许我们省略隐式参数，例如命题<span class="math">\(Q\)</span>和<span class="math">\(R\)</span>，否则我们必须将它们作为参数提供给And.left和And.right。</p>
<pre><code>def destructAnd (name : Name) : TacticM Unit :=
    withMainContext
        (do
            let h \leftarrow getFVarFromUserName name
            let success \leftarrow destructAndExpr h
            if ! success then
                failure)
elab "destruct_and" h:ident : tactic =&gt;
    destructAnd (getId h)
</code></pre>
<p>主函数几乎没有什么需要做的了：</p>

<p>该函数通过getFVarFromUserName获取假设h并调用辅助函数。如果辅助函数返回false，则策略失败。</p>

<pre><code>theorem abc_a_again (a b c : Prop) (h : a \wedge b \wedge c) :
    a :=
    by destruct_and h
theorem abc_b_again (a b c : Prop) (h : a \wedge b \wedge c) :
    b :=
    by destruct_and h
theorem abc_bc_again (a b c : Prop) (h : a \wedge b \wedge c) :
        b \wedge c :=
    by destruct_and h
theorem abc_c_again (a b c : Prop) (h : a \wedge b \wedge c) :
        c :=
    by destruct_and h
</code></pre>
<p>我们现在可以在激励示例中使用我们的新工具：</p>
<div class="math">$$
\begin{gathered}
\text { inferType : Expr } \rightarrow \text { TacticM Expr } \\
\text { Expr. and? : Expr } \rightarrow \text { Option (Expr } \times \text { Expr) } \\
\text { mkAppM : Name } \rightarrow \text { Array Expr } \rightarrow \text { TacticM Expr } \\
\text { getFVarFromUserName : Name } \rightarrow \text { TacticM Expr }
\end{gathered}
$$</div>
<p>在上述元程序中使用了以下新常量：</p>
<h3>8.7 第三个示例：直接证明查找器</h3>
<p>有时我们陈述一个定理，证明它，后来才发现该定理已经存在。通过使用prove_direct可以避免这种情况，这是一种遍历所有可用定理并检查其中是否有定理可以证明当前目标的策略。我们将逐步审查其代码。</p>
<pre><code>def isTheorem : ConstantInfo -&gt; Bool
    | ConstantInfo.axiomInfo _ =&gt; true
    | ConstantInfo.thmInfo _ =&gt; true
    | _ =&gt; false
</code></pre>
<p>第一步是一个函数isTheorem，如果声明是一个公理或定理，则返回true，否则返回false：</p>
<pre><code>def applyConstant (name : Name) : TacticM Unit :=
    do
        let cst \leftarrow mkConstWithFreshMVarLevels name
        liftMetaTactic (fun goal \(\mapsto\) MVarId.apply goal cst)
</code></pre>
<p>我们将使用此函数来过滤掉我们不感兴趣的声明。下一个函数将名为name的定理应用于当前目标：</p>
<p>给定一个名称，mkConstWithFreshMVarLevels 函数会创建一个表示常量的表达式 cst。函数名称中提到的“新鲜元变量级别”将在第12章中变得更加清晰。然后，MVarId.apply（不要与 MVarId.assign 混淆）将常量应用于当前目标，设置 ?m:= cst <span class="math">\(? \mathrm{~m}_{1} \ldots\)</span> ?m <span class="math">\(m_{n}\)</span> 并返回表示 cst 前提的新鲜元变量 <span class="math">\(? \mathrm{~m}_{j}\)</span>。</p>
<p>liftMetaTactic 函数获取第一个目标的标识符，在较低层次的 MetaM 单子中对目标运行给定函数，并将目标替换为函数返回的子目标。</p>
<pre><code>def andThenOnSubgoals (tac
    TacticM Unit :=
    do
        let origGoals \leftarrow getGoals
        let mainGoal \leftarrow getMainGoal
        setGoals [mainGoal]
        tac
        let subgoals
        let mut newGoals := []
        for subgoal in subgoals
            let assigned \leftarrow MVarId.isAssigned subgoal
            if ! assigned then
                setGoals [subgoal]
                tac
                let subgoals }\leftarrow\mathrm{ getUnsolvedGoals
                newGoals := newGoals ++ subgoals
    setGoals (newGoals ++ List.tail origGoals)
</code></pre>
<p>下一个函数实现了一个类似于&lt;; &gt;但可以在元程序中使用的组合子。</p>
<p>TacticM 单子用于跟踪当前需要证明的目标。我们可以使用 getGoals 来检索目标列表，并使用 setGoals 来设置它。设置子目标列表非常有用，如果我们希望策略暂时专注于特定的子目标。</p>
<p>在这里，我们首先关注第一个目标（setGoals [mainGoal]）并调用第一个策略。对于出现的每个子目标，我们专注于它（setGoals [subgoal]）并调用第二个策略。从第二个策略中产生的所有未解决的子子目标都被收集在可变变量newGoals中。由于证明一个目标有时可能会实例化另一个元变量，我们在每次迭代时检查当前子目标元变量是否已分配，如果已分配则跳过该子目标。最后，我们更新目标以包含所有待处理的目标：newGoals中的目标以及origGoals中除第一个目标之外的所有目标，这些目标我们尚未考虑。</p>
<pre><code>def proveDirect : TacticM Unit :=
    do
    let origGoals \leftarrow getUnsolvedGoals
    let goal \leftarrow getMainGoal
    setGoals [goal]
    let env \leftarrow getEnv
    for (name, info)
        in SMap.toList (Environment.constants env) do
        if isTheorem info 66 ! ConstantInfo.isUnsafe info then
        try
            proveUsingTheorem name
            logInfo m!"Proved directly by {name}"
            setGoals (List.tail origGoals)
            return
            catch _ =&gt;
            continue
        failure
elab "prove_direct" : tactic =&gt;
    proveDirect
</code></pre>
<p>一般来说，在策略结束时，我们应该确保目标列表包含所有待证明的目标。否则，我们可能会遇到一些难以理解的错误，例如“声明中存在元变量”。我们还需要一个策略，该策略尝试使用指定名称的定理来证明目标，并调用假设来证明任何出现的子目标：def proveUsingTheorem (name : Name) : TacticM Unit := andThenOnSubgoals (applyConstant name) hypothesis 这是证明应用 name &lt;;&gt; hypothesis 的程序化等价物。最后，我们准备回顾主函数：</p>
<p>我们首先关注第一个目标，然后遍历环境中声明的所有常量。如果该常量是一个定理且不“不安全”（这是一个与我们的不安全规则和策略无关的Lean概念），我们尝试使用辅助函数proveUsingTheorem来应用它。如果成功，我们打印“由名称直接证明”，其中名称是定理的名称，并返回。如果失败，我们继续迭代。如果整个迭代完成仍未成功，我们报告失败。</p>
<pre><code>theorem Nat.symm (x y : N) (h : x = y) :
    y = x :=
    by prove_direct
</code></pre>
<p>以下是该策略的实际应用：</p>
<pre><code>theorem Nat.symm_manual ( \(x\) y : N) (h : x = y) :
    \(y=x:=\)
    by
        apply symm
        hypothesis
</code></pre>
<p>这将打印“通过symm直接证明”。该消息很有帮助，因为我们可以直接应用指定的定理，而不是依赖相对较慢的prove_direct策略。具体来说，我们可以结合假设应用定理symm，如下所示：</p>
<pre><code>mkConstWithFreshMVarLevels : Name \(\rightarrow\) TacticM Expr
    liftMetaTactic : (MVarId \(\rightarrow\) MetaM (List MVarId) ) \(\rightarrow\)
        TacticM Unit
        MVarId.apply : MVarId \(\rightarrow\) Expr \(\rightarrow\) MetaM (List MVarId)
            getGoals : TacticM (List MVarId)
            setGoals : List MVarId \(\rightarrow\) TacticM Unit
        MVarId.isAssigned : MVarId \(\rightarrow\) TacticM Bool
            getEnv : TacticM Environment
            SMap.toList : ConstMap \(\rightarrow\) List (Name \(\times\) ConstantInfo)
        Environment.constants : Environment \(\rightarrow\) ConstMap
        ConstantInfo.isUnsafe : ConstantInfo \(\rightarrow\) Bool
</code></pre>
<p>以下是本示例中出现的新常量列表：</p>
<p>这结束了我们对prove_direct的回顾。在mathlib中，一个类似的策略是apply?。</p>
<h3>8.8 杂项策略</h3>
<p>尽管本章的重点是开发新的策略，但我们遇到了三种预定义的策略。</p>

<h4>skip</h4>
<p>skip 策略在不执行任何操作的情况下成功。在开发自定义策略时，它有时可以作为构建块使用。</p>

<h4>完成</h4>
<p>done 策略会在仍有未完成目标时引发失败；否则，它将成功而不做任何操作。与 skip 类似，它也可以作为构建模块使用。</p>
<h4>apply?</h4>
<p>apply? 策略会在已加载的库中搜索能够精确证明目标的定理。成功后，它会建议一个形式为 exact ... 的策略调用，该调用可以插入到形式化证明中。</p>
<table>
<thead>
<tr>
  <th style="text-align:left">' <span class="math">\(n\)</span>
</th>
  <th style="text-align:left">quotes a literal name</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">''n</td>
  <td style="text-align:left">quotes a literal name with elaboration and checking</td>
</tr>
</tbody>
</table>
<h3>8.9 新引入的Lean结构总结</h3>
<h4>声明</h4>
<h4>引用</h4>
<h4>策略</h4>
<p>apply? 搜索能够证明当前目标的定理done 如果还有目标未完成则失败skip 不执行任何操作</p>

<h4>策略组合器</h4>
<p><span class="math">\(&lt;;&gt;\)</span>
all_goals
any_goals
first | ... | ...
repeat'
solve | ... | ...
try
在第一个策略生成的所有子目标上调用第二个策略 在每个目标上调用一次策略，期望只有成功 在每个目标上调用一次策略，期望至少有一个成功 依次尝试策略，直到一个成功
重复调用策略在所有目标和子目标上，直到失败 尝试使用策略完全证明当前目标 尝试调用策略；失败时不执行任何操作</p>

<h1>第三部分：程序语义</h1>
<h2>第9章：操作语义</h2>
<p>在本章及接下来的两章中，我们将探讨如何使用Lean来指定编程语言的语法和语义，证明语义的性质，并对具体程序进行推理。</p>

<p>本章深受《Concrete Semantics: With Isabelle/HOL》第7章的启发。</p>

<h3>9.1 形式语义</h3>
<p>形式语义允许我们规范和推理一种编程语言以及用该语言编写的单个程序。它可以构成已验证的编译器、解释器、验证器、静态分析器、类型检查器等工具的基础。如果没有形式化证明，这些工具几乎总是错误的。</p>
<p>考虑WebAssembly，这是一种为网络浏览器设计的新型汇编式语言，旨在作为C++和Rust等高级语言编译的可移植目标。研究人员Conrad Watt使用Isabelle/HOL证明助手形式化了其语义和类型系统。他发现了许多问题（我们强调）：</p>
<p>我们完成了WebAssembly语言核心执行语义和类型系统的完整Isabelle机械化。此外，我们还为工作组论文中所述的类型安全性属性创建了机械化证明。为了完成这一证明，规范作者需要根据我们的证明和建模工作发现的官方WebAssembly规范中的若干缺陷进行修正。在某些情况下，这些缺陷意味着类型系统最初是不健全的。我们与工作组的部分成员保持了建设性的对话，随着规范中新增功能，我们对其进行机械化和验证。特别是，工作组原始论文中并未正式指定WebAssembly实现与其宿主环境交互的机制。扩展我们的机械化以建模这一功能时，揭示了WebAssembly规范中的一个缺陷，该缺陷破坏了类型系统的健全性。</p>
<p>Watt的研究只是众多例子中的一个。证明助手在编程语言研究中被广泛使用。每年，在编程语言原理（POPL）会议上展示的论文中，有很大一部分都被形式化了。这是可能的，因为相对来说，启动所需的工具较少。这些证明往往有很多情况，这与计算机非常匹配。此外，证明助手在跟踪随着我们为编程语言添加更多功能而需要更改的内容时非常方便。</p>
<table>
<thead>
<tr>
  <th style="text-align:center">
<span class="math">\(S::=\)</span> skip</th>
  <th style="text-align:center">(no-op)</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><span class="math">\(\mid x:=a\)</span></td>
  <td style="text-align:center">(assignment)</td>
</tr>
<tr>
  <td style="text-align:center"><span class="math">\(\mid S ; S\)</span></td>
  <td style="text-align:center">(sequential composition)</td>
</tr>
<tr>
  <td style="text-align:center">if <span class="math">\(b\)</span> then <span class="math">\(S\)</span> else <span class="math">\(S\)</span>
</td>
  <td style="text-align:center">(conditional statement)</td>
</tr>
<tr>
  <td style="text-align:center">while <span class="math">\(b\)</span> do <span class="math">\(S\)</span>
</td>
  <td style="text-align:center">(while loop)</td>
</tr>
</tbody>
</table>
<h3>9.2 一个极简的命令式语言</h3>
<p>我们介绍WHILE<span class="math">\({ }^{1}\)</span>，一个极简的命令式语言，其语法如下：</p>
<p>其中<span class="math">\(S\)</span>表示语句（也称为命令或程序），<span class="math">\(x\)</span>表示程序变量，<span class="math">\(a\)</span>表示算术表达式，<span class="math">\(b\)</span>表示布尔表达式。</p>
<p>在我们的语法中，我们故意未指定算术和布尔表达式的语法。在Lean中，我们有以下选择：</p>
<ul>
<li>我们可以使用第2.1节中的AExp类型，布尔表达式也类似。</li>
<li>我们可以简单地决定算术表达式是从状态到数字的函数（例如，State <span class="math">\(\rightarrow \mathbb{N}\)</span>），而布尔表达式是状态的谓词（例如，State <span class="math">\(\rightarrow\)</span> Bool 或 State <span class="math">\(\rightarrow\)</span> Prop）。状态是从程序变量到值的映射。因此，<span class="math">\(x+y+1\)</span> 将由函数 fun s : State <span class="math">\(\mapsto \mathrm{s}\)</span> "x" + s "y" + 1 表示，而 <span class="math">\(\mathrm{a} \neq \mathrm{b}\)</span> 将由谓词 fun s : State <span class="math">\(\mapsto \mathrm{s}\)</span> "a" <span class="math">\(\neq \mathrm{s}\)</span> "b" 表示。这两种选择对应于深度嵌入和浅层嵌入之间的区别。某些语法（表达式、公式、程序等）的深度嵌入包括在证明助手中指定的抽象语法树（例如，AExp）及其语义（例如，eval）。相比之下，浅层嵌入只是重用逻辑中的相应机制（例如，函数和谓词）。</li>
</ul>
<p>深度嵌入允许我们推理程序的语法。浅层嵌入更为轻量，因为我们可以直接使用它，而无需定义语义。浅层嵌入本身就是其语义。</p>
<pre><code>inductive Stmt : Type where
    | skip : Stmt
    | assign : String \(\rightarrow\) (State \(\rightarrow \mathbb{N}) \rightarrow\) Stmt
    | seq : Stmt \(\rightarrow\) Stmt \(\rightarrow\) Stmt
    | ifThenElse : (State \(\rightarrow\) Prop) \(\rightarrow\) Stmt \(\rightarrow\) Stmt \(\rightarrow\) Stmt
    | whileDo : (State \(\rightarrow\) Prop) \(\rightarrow\) Stmt \(\rightarrow\) Stmt
</code></pre>
<p>在第7章中，我们使用了带有副作用的程序的浅层嵌入。在这里，我们将使用程序的深层嵌入（我们认为这些程序有趣并希望深入研究）以及算术和布尔表达式的浅层嵌入（我们认为这些表达式不那么有趣）。我们对程序的Lean定义如下：</p>
<p>中缀语法 <span class="math">\(S ; T\)</span> 是 Stmt. seq <span class="math">\(S T\)</span> 的缩写。归纳类型的构造器与 WHILE 语法规则之间的对应关系应该是清晰的。变量由字符串表示。State 类型定义为 String <span class="math">\(\rightarrow \mathbb{N}\)</span>，即从变量名到值的映射。为简单起见，我们的程序变量都是自然数类型，并且所有可能的变量名都存在于状态中并被赋予一个值。</p>
<pre><code>def sillyLoop : Stmt :=
    Stmt.whileDo (fun s \mapsto s "x" &gt; s "y")
        (Stmt.skip;
            Stmt.assign "x" (fun s \mapsto s "x" - 1))
</code></pre>

<p>以下小程序展示了深度嵌入的WHILE语法（及其浅层嵌入的方面）：</p>

<h3>9.3 大步语义</h3>
<p>操作语义对应于一个理想化的解释器。主要有两种变体：大步语义和小步语义。我们将首先为我们的WHILE语言提供一个大步语义。</p>
<p>在大步操作语义（也称为自然语义）中，判断具有形式<span class="math">\((S, s) \Longrightarrow t\)</span>，并具有以下直观解释：</p>
<p>从状态<span class="math">\(s\)</span>开始，执行<span class="math">\(S\)</span>可能会在状态<span class="math">\(t\)</span>终止。对于像WHILE这样的确定性语言，由于程序总是有单一的结果，“可能终止”与“必须终止”或“终止”含义相同。</p>
<div class="math">$$
(x:=x+y ; y:=0,[x \mapsto 3, y \mapsto 5]) \Longrightarrow[x \mapsto 8, y \mapsto 0]
$$</div>
<p>根据WHILE程序的定义，状态<span class="math">\(s\)</span>是一个类型为String <span class="math">\(\rightarrow \mathbb{N}\)</span>的函数。示例如下：</p>
<p>我们使用非正式符号<span class="math">\([x \mapsto 3, y \mapsto 5]\)</span>来表示函数fun <span class="math">\(v \mapsto\)</span>如果<span class="math">\(v=\)</span>“<span class="math">\(x\)</span>”则3否则如果<span class="math">\(v=\)</span>“<span class="math">\(y\)</span>”则5否则0，类似地对于<span class="math">\([x \mapsto 8, y \mapsto 0]\)</span>。直观上，该判断成立。</p>
<div class="math">$$
\begin{aligned}
&amp; \overline{(\text { skip }, s) \Longrightarrow s} \text { SKIP } \\
&amp; \overline{(x:=a, s) \Longrightarrow s[x \mapsto a s]} \text { ASSIGN } \\
&amp; \frac{(S, s) \Longrightarrow t \quad(T, t) \Longrightarrow u}{(S ; T, s) \Longrightarrow u} \text { SEQ } \\
&amp; \frac{(S, s) \Longrightarrow t}{(\text { if } b \text { then } S \text { else } T, s) \Longrightarrow t} \text { IF-TrUE if } b \text { is true }
\end{aligned}
$$</div>
<div class="math">$$
\begin{aligned}
&amp; (T, s) \Longrightarrow t \\
&amp; \text { (if } b \text { then } S \text { else } T, s) \Longrightarrow t \\
&amp; (S, s) \Longrightarrow t \quad \text { (while } b \text { do } S, t) \Longrightarrow u \\
&amp; \text { (while } b \text { do } S, s) \Longrightarrow u \\
&amp; \text { (while } b \text { do } S, s) \Longrightarrow s
\end{aligned}
$$</div>
<p>传统上，指定这种语义的方式是通过形式化的推导规则系统，类似于第1.3节和第4.6节中介绍的类型规则。大步语义判断的推导规则如下所示。这些规则可以看作是WHILE程序的理想化解释器。</p>
<div class="math">$$
s[x \mapsto n]=(f u n v \mapsto i f v=x \text { then } n \text { else } s v)
$$</div>
<p>在规则中，a s 表示状态 <span class="math">\(s\)</span> 下算术表达式 a 的值，同理 <span class="math">\(b \mathrm{~s}\)</span> 也是如此。此外，语法 <span class="math">\(s[x \mapsto n]\)</span> 表示与 <span class="math">\(s\)</span> 相同但将变量 <span class="math">\(x\)</span> 映射到 <span class="math">\(n\)</span> 的状态。正式定义如下：</p>
<p>该语法由LoVelib提供。最复杂的规则无疑是While-True。直观上，可以理解为：</p>
<p>假设条件<span class="math">\(b\)</span>在状态<span class="math">\(s\)</span>下为真。如果 (1) 在状态<span class="math">\(s\)</span>下执行<span class="math">\(S\)</span>导致状态<span class="math">\(t\)</span>，并且 (2) 从状态<span class="math">\(t\)</span>执行 while <span class="math">\(b\)</span> do <span class="math">\(S\)</span> 导致状态<span class="math">\(u\)</span>，那么在状态<span class="math">\(s\)</span>下执行 while b do <span class="math">\(S\)</span> 将导致状态<span class="math">\(u\)</span>。</p>
<p>另一种理解While-True的方式是通过循环展开。如果循环条件为真，while <span class="math">\(b\)</span> do <span class="math">\(S\)</span> 等价于复合语句 <span class="math">\(S\)</span>; while b do S。While-True的两个前提对应于Seq规则实例中的两个前提，即 <span class="math">\(S\)</span>; while b do <span class="math">\(S\)</span>。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { ASSIGN } \\
&amp; (x:=x+y, s) \Longrightarrow t \quad(y:=0, t) \Longrightarrow u \\
&amp; (x:=x+y ; y:=0, s) \Longrightarrow u
\end{aligned}
$$</div>
<p>作为练习，让我们推导上面的示例判断。设<span class="math">\(s:=[x \mapsto 3\)</span>, <span class="math">\(y \mapsto 5], t:=[x \mapsto 8, y \mapsto 5]\)</span>, 以及<span class="math">\(u:=[x \mapsto 8, y \mapsto \theta]\)</span>。然后我们有</p>
<p>推导规则可以直观地理解。考虑Seq规则：如果在状态<span class="math">\(s\)</span>下执行<span class="math">\(S\)</span>会转移到状态<span class="math">\(t\)</span>，并且在状态<span class="math">\(t\)</span>下执行<span class="math">\(T\)</span>会转移到状态<span class="math">\(u\)</span>，那么在状态<span class="math">\(s\)</span>下执行顺序组合<span class="math">\(S ; T\)</span>会转移到状态<span class="math">\(u\)</span>。</p>
<pre><code>inductive BigStep : Stmt \(\times\) State \(\rightarrow\) State \(\rightarrow\) Prop where
    | skip (s) :
        BigStep (Stmt.skip, s) s
    | assign (x a s) :
        BigStep (Stmt.assign x a, s) (s[x \(\mapsto\) a s])
    | seq (S T s t u) (hS : BigStep (S, s) t)
        (hT : BigStep (T, t) u) :
        BigStep (S; T, s) u

    | if_true (B S T s t) (hcond : B s)
        (hbody : BigStep (S, s) t) :
    BigStep (Stmt.ifThenElse B S T, s) t
    | if_false (B S T s t) (hcond : - B s)
        (hbody : BigStep (T, s) t) :
    BigStep (Stmt.ifThenElse B S T, s) t
    | while_true (B S s t u) (hcond : B s)
        (hbody : BigStep (S, s) t)
        (hrest : BigStep (Stmt.whileDo B S, t) u) :
    BigStep (Stmt.whileDo B S, s) u
    | while_false (B S s) (hcond : - B s) :
    BigStep (Stmt.whileDo B S, s) s
</code></pre>
<p>条件（1）和（2）对应于Seq的两个前提。在Lean中，大步语义判断由一个归纳谓词表示，其引入规则紧密遵循上述推导规则：</p>
<pre><code>def eval : Stmt -&gt; State -&gt; State
    | Stmt.skip, s =&gt; s
    | Stmt.assign x a, s =&gt; s[x }-&gt;\mathrm{ a s]
    | Stmt.ifThenElse b S T, s =&gt;
        if b s then eval S s else eval T s
    | S; T, s =&gt; eval T (eval S s)
    | Stmt.whileDo b S, s =&gt;
        if b s then eval (Stmt.whileDo b S) (eval S s) else s
</code></pre>
<p>使用归纳谓词而非递归函数，使我们能够应对非终止（如发散的while循环）以及比WHILE更丰富的语言中的非确定性。此外，这还提供了一种更接近科学文献中传统使用的判定规则的语法。如果我们尝试使用递归定义，例如</p>
<p>我们将面临Stmt. whileDo情况下的非终止问题。实际上，由于程序Stmt. whileDo (fun _ <span class="math">\(\mapsto\)</span> True) Stmt.skip会无限循环，尝试使用eval对其进行求值将永远不会返回。</p>
<pre><code>theorem sillyLoop_from_1_BigStep :
    (sillyLoop, (fun _ }-&gt;\mathrm{ @)["x" }-&gt;\mathrm{ :]) }-&gt;\mathrm{ (fun _ }-&gt;\mathrm{ @) :=
    by
        rw [sillyLoop]
        apply BigStep.while_true
        { simp }
        { apply BigStep.seq
            { apply BigStep.skip }
            { apply BigStep.assign } }
        { simp
            apply BigStep.while_false
            simp }
</code></pre>
<p>配备了大步语义后，我们可以对具体程序进行推理，例如在第9.2节中定义的程序，并证明如下定理：</p>
<h3>9.4 大步语义的性质</h3>
<p>大步语义使我们能够推理具体程序，证明与最终状态和初始状态相关的定理。同样重要的是，它使我们能够证明编程语言的性质，如确定性和非终止性。</p>
<pre><code>theorem BigStep_deterministic \(\{S s 1 \mathrm{r}\} \quad(\mathrm{hl}: S s \Longrightarrow 1)\)
    \((h r: S s \Longrightarrow r)\) :
    \(l=r\)
</code></pre>
<p>我们从确定性开始。它可能看起来是一个微不足道的属性，但很容易在输入规则时出错，从而引入非确定性。例如，在赋值规则中，如果我们错误地写成 BigStep (Stmt. assign x a, s) (s[y <span class="math">\(\mapsto\)</span> a s])，其中使用了 y 而不是 <span class="math">\(x\)</span>，那么我们突然可以使用该规则来修改任何我们想要的变量 <span class="math">\(y\)</span>。换句话说，程序的执行可能会随机修改任何变量。因此，让我们验证我们的 WHILE 语言确实是确定性的：</p>

<p>Lean证明位于本章相关的演示文件中。由于技术原因，对<span class="math">\((S, s)\)</span>由单个变量<span class="math">\(S s\)</span>表示。我们满足于一个非正式的证明草图：</p>


<p>该证明通过对<span class="math">\((S, s) \Longrightarrow 1\)</span>进行规则归纳。CASE SKIP: 为了得到(skip, s) <span class="math">\(\Longrightarrow 1\)</span>，我们需要<span class="math">\(1=\)</span> s。类似地，通过对(skip, s) <span class="math">\(\Longrightarrow r\)</span>进行案例分析，我们得到<span class="math">\(r=s\)</span>。因此，<span class="math">\(l=r\)</span>。</p>

<p>情况 赋值：与跳过情况类似。
情况 序列：我们有假设 <span class="math">\((S, s) \Longrightarrow t,(T, t) \Longrightarrow 1,(S, s)\)</span> <span class="math">\(\Longrightarrow t^{\prime}\)</span>，以及 <span class="math">\(\left(T, t^{\prime}\right) \Longrightarrow r\)</span> 和归纳假设 <span class="math">\(\forall r,(S, s) \Longrightarrow\)</span> <span class="math">\(r \rightarrow t=r\)</span> 和 <span class="math">\(\forall r,(T, t) \Longrightarrow r \rightarrow l=r\)</span>。从第一个归纳假设与 <span class="math">\((S, s) \Longrightarrow t^{\prime}\)</span> 一起，我们得出 <span class="math">\(t=t^{\prime}\)</span>。从第二个归纳假设与 <span class="math">\(\left(T, t^{\prime}\right) \Longrightarrow r\)</span> 一起，我们得出 <span class="math">\(l=r\)</span>。
情况 如果为真：由于 <span class="math">\(b\)</span> s 为真，(如果 <span class="math">\(b\)</span> 则 <span class="math">\(S\)</span> 否则 <span class="math">\(T, s) \Longrightarrow r\)</span> 只能通过如果为真规则推导，因此 <span class="math">\((S, s) \Longrightarrow r\)</span>。归纳假设为 <span class="math">\(\forall r,(S, s) \Longrightarrow r \rightarrow l=r\)</span>。我们可以将 <span class="math">\((S, s) \Longrightarrow r\)</span> 应用于它，得到 <span class="math">\(l=r\)</span>。</p>
<pre><code>theorem BigStep_terminates \(\{S \mathrm{~s}\}:\)
    \(\exists t,(S, s) \Longrightarrow t\)
</code></pre>
<p>CASE IF-FALSE: 类似于 IF-TRUE。CASE WHILE-TRUE: 类似于 SEQ。CASE WHILE-FALSE: 类似于 SKIP。鉴于 WHILE 语言是确定性的，对于大步语义而言，终止将等同于以下情况：</p>
<p>该属性意味着对于每个语句<span class="math">\(S\)</span>和状态<span class="math">\(s\)</span>，存在一个状态<span class="math">\(t\)</span>，使得从<span class="math">\(s\)</span>开始执行<span class="math">\(S\)</span>可能会在<span class="math">\(t\)</span>终止。由于WHILE是确定性的，“可能会终止”意味着“必须终止”。然而，该属性并不成立。</p>
<pre><code>@[simp] theorem BigStep_skip_Iff \(\{s t\}\) :
    (Stmt.skip, s) \(\Longrightarrow t \leftrightarrow t=s\)

@[simp] theorem BigStep_assign_Iff {x a s t} :
    (Stmt.assign x a, s) \(\Longrightarrow \mathrm{t} \leftrightarrow \mathrm{t}=\mathrm{s}[\mathrm{x} \mapsto \mathrm{a} \mathrm{s}\]
@[simp] theorem BigStep_seq_Iff \{S T s u\} :
    \((\mathrm{S} ; \mathrm{T}, \mathrm{s}) \Longrightarrow \mathrm{u} \leftrightarrow(\exists \mathrm{t},(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \wedge(\mathrm{T}, \mathrm{t}) \Longrightarrow \mathrm{u})\)
@[simp] theorem BigStep_if_Iff \{B S T s t\} :
    (Stmt.ifThenElse B S T, s) \(\Longrightarrow \mathrm{t} \leftrightarrow\)
    \((B \mathrm{~s} \wedge(\mathrm{~S}, \mathrm{~s}) \Longrightarrow \mathrm{t}) \vee(\neg \mathrm{B} \mathrm{s} \wedge(\mathrm{T}, \mathrm{s}) \Longrightarrow \mathrm{t})\)
theorem BigStep_while_Iff \{B S s u\} :
    (Stmt.whileDo B S, s) \(\Longrightarrow u \leftrightarrow\)
    \((B \mathrm{~s} \wedge \exists \mathrm{t},(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \wedge\) (Stmt.whileDo B S, t) \(\Longrightarrow \mathrm{u})\)
    \(\vee(\neg \mathrm{B} \mathrm{s} \wedge \mathrm{u}=\mathrm{s})\)
@[simp] theorem BigStep_while_true_Iff \{B S s u\}
        (hcond : B s) :
    (Stmt.whileDo B S, s) \(\Longrightarrow u \leftrightarrow\)
    \((\exists \mathrm{t},(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \wedge(\) stmt.whileDo B S, t) \(\Longrightarrow \mathrm{u})\)
@[simp] theorem BigStep_while_false_Iff \{B S s t\}
        (hcond : \(\neg \mathrm{B} \mathrm{s})\)
    (Stmt.whileDo B S, s) \(\Longrightarrow \mathrm{t} \leftrightarrow \mathrm{t}=\mathrm{s}\)
</code></pre>
<p>在推理归纳谓词时，使用反演规则（第6.5节）通常很方便。因此，我们证明了以下规则：</p>
<p>我们将这些规则添加到simp集合中，除了BigStep_while_Iff，因为它会导致simp循环。</p>
<h3>9.5 小步语义</h3>
<p>大步语义的一个局限是它们不允许我们推理中间状态。从判断<span class="math">\((S, s) \Longrightarrow t\)</span>中，我们只能看到初始状态<span class="math">\(s\)</span>和最终状态<span class="math">\(t\)</span>。这对于推理多线程程序来说过于粗粒度，因为多个进程可能会相互影响彼此的中间状态。此外，对于非确定性语言，大步语义没有提供表达终止的通用方法：一个判断只表示一种可能性（在状态<span class="math">\(s\)</span>中执行<span class="math">\(S\)</span>可能会导致状态<span class="math">\(t\)</span>），而不是必然性。</p>
<p>小步操作语义提供了更细粒度的视角。转移谓词<span class="math">\(\Rightarrow\)</span>的类型为 stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> stmt <span class="math">\(\times\)</span> State <span class="math">\(\rightarrow\)</span> Prop。直观上，<span class="math">\((S, s) \Rightarrow(T\)</span>, <span class="math">\(t\)</span> ) 表示在状态 <span class="math">\(s\)</span> 中执行程序 <span class="math">\(S\)</span> 的一步后，程序 <span class="math">\(T\)</span> 将在状态 <span class="math">\(t\)</span> 中继续执行。如果没有剩余的可执行部分，我们将其置为 skip。</p>
<div class="math">$$
\begin{array}{rlrl}
(x:=x+y ; y:=0, &amp; {[x \mapsto 3, y \mapsto 5])} \\
\Rightarrow(\text { skip } ; y:=0, &amp; &amp; {[x \mapsto 8, y \mapsto 5])} \\
\Rightarrow(y:=0, &amp; &amp; {[x \mapsto 8, y \mapsto 5])} \\
\Rightarrow(\text { skip }, &amp; &amp; {[x \mapsto 8, y \mapsto 0])}
\end{array}
$$</div>
<p>执行是一个有限或无限的链<span class="math">\(\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{1}, s_{1}\right) \Rightarrow \cdots\)</span>，由“小”<span class="math">\(\Rightarrow\)</span>步骤组成。一个对<span class="math">\((S, s)\)</span>被称为配置；如果对于任何<span class="math">\((T, t)\)</span>，不存在形式为<span class="math">\((S, s) \Rightarrow(T, t)\)</span>的转换，则该配置是最终的。一个执行如下：</p>
<p>如果我们以计算机处理器作为类比，配置<span class="math">\((S, s)\)</span>中的<span class="math">\(S\)</span>组件可以被视为程序计数器，它指示接下来应该执行哪些指令。程序的逐步执行类似于在调试器中运行程序，并在每一步设置断点。</p>
<div class="math">$$
\begin{aligned}
&amp; \overline{(x:=a, s) \Rightarrow(\text { skip }, s[x \mapsto a s])} \text { ASSIGN } \\
&amp; \frac{(S, s) \Rightarrow\left(S^{\prime}, s^{\prime}\right)}{\left(S ; T, s\right) \Rightarrow\left(S^{\prime} ; T, s^{\prime}\right)} \text { SEQ-STEP } \\
&amp; \text { (skip; } T, s) \Rightarrow(T, s) \text { SEQ-SKIP } \\
&amp; \text { (if b then } S \text { else } T, s) \Rightarrow(S, s) \text { IF-TrUE if } b \text { is true } \\
&amp; \text { (if b then } S \text { else } T, s) \Rightarrow(T, s) \text { IF-FALSE if } b \text { is false }
\end{aligned}
$$</div>
<p>有效的小步推导规则由推导规则给出：</p>
<p>(while b do S, s) <span class="math">\(\Rightarrow\)</span> (if b then (S; while b do S) else skip, s)这些规则让人联想到第6.1.2节中的网球比赛转换系统。这些规则同样指定了小步骤：从0-0到15-0，再到15-15，依此类推。</p>
<p>与大步语义不同，小步语义中没有关于skip的规则。这是因为形式为(skip, s)的配置被认为是最终的；skip被理解为执行是微不足道的语句。通过检查这些规则，我们可以确信，当且仅当配置的第一个组件是skip时，该配置是最终的。</p>
<p>两条规则涉及顺序组合<span class="math">\(S ; T\)</span>。第一条规则适用于执行<span class="math">\(S\)</span>时能取得进展的情况。但如果<span class="math">\(S\)</span>是skip，则无法取得进展，此时适用第二条规则。</p>
<p>if的规则会检查条件<span class="math">\(b\)</span>，并根据其真值，将then或else分支作为剩余要执行的计算。</p>
<p>对于while循环，有一条无条件规则，它展开循环的一次迭代，引入一个if语句。然后，IF-TRUE和IF-FALSE规则负责处理这个if语句。在IF-TRUE的情况下，我们最终会再次到达while循环。对于无限循环，这种情况可以永远持续下去。</p>
<pre><code>inductive SmallStep : Stmt \(\times\) State \(\rightarrow\) Stmt \(\times\) State \(\rightarrow\) Prop
    where
    | assign (x a s) :
        SmallStep (Stmt.assign x a, s) (Stmt.skip, s[x \(\mapsto\) a s])
    | seq_step (S S' T s s') (hS : SmallStep (S, s) (S', s')) :
        SmallStep (S; T, s) (S'; T, s')
    | seq_skip (T s) :
        SmallStep (Stmt.skip; T, s) (T, s)
    | if_true (B S T s) (hcond : B s) :
        SmallStep (Stmt.ifThenElse B S T, s) (S, s)
    | if_false (B S T s) (hcond : \(\neg\) B s) :
        SmallStep (Stmt.ifThenElse B S T, s) (T, s)
    | whileDo (B S s) :
</code></pre>
<p>在Lean中，小步语义定义如下：</p>
<div class="math">$$
(S, s) \Longrightarrow t \text { if and only if }(S, s) \Rightarrow *(s k i p, t)
$$</div>
<p>SmallStep (Stmt.whileDo B S, s) (Stmt.ifThenElse B (S; Stmt.whileDo B S) Stmt.skip, s) 基于小步语义，我们可以定义大步语义如下：</p>
<p>其中<span class="math">\(p *\)</span>表示二元谓词<span class="math">\(p\)</span>的自反传递闭包（RTC）。或者，如果我们已经定义了大步语义，我们可以通过证明上述等价定理来验证我们的定义。</p>
<div class="math">$$
\text { RTC. head : ?R ?a ?b } \rightarrow \text { RTC ?R ?b ?c } \rightarrow \text { RTC ?R ?a ?c }
$$</div>
<p>小步语义的主要缺点是现在我们有两个谓词，<span class="math">\(\Rightarrow\)</span> 和 <span class="math">\(\Rightarrow *\)</span>，推导规则和证明往往比大步语义更复杂。这在以下示例中显而易见，其中我们需要对每个小步应用该定理</p>
<pre><code>theorem sillyLoop_from_1_SmallStep :
    (sillyLoop, (fun _ }-&gt;\mathrm{ @)["x" }-&gt;\mathrm{ :]) \ \ }
    (Stmt.skip, (fun _ }-&gt;\mathrm{ @)) :=
    by
        rw [sillyLoop]
        apply RTC.head
        { apply SmallStep.whileDo }
        { apply RTC.head
            { apply SmallStep.if_true
                aesop }
            { apply RTC.head
                { apply SmallStep.seq_step
                    apply SmallStep.seq_skip }
                { apply RTC.head
                    { apply SmallStep.seq_step
                        apply SmallStep.assign }
                        { apply RTC.head
                        { apply SmallStep.seq_skip }
                        { apply RTC.head
                        { apply SmallStep.whileDo }
                        { apply RTC.head
                        { apply SmallStep.if_false
                        simp }
                        { simp
                        apply RTC.refl } } } } } } }
</code></pre>
<p>对每个小步骤应用一次该定理：</p>
<h3>9.6 小步语义的性质</h3>
<p>我们可以证明配置 (<span class="math">\(S, s\)</span>) 是最终的当且仅当 <span class="math">\(S=s k i p\)</span>。这样做可以确保我们没有遗漏任何推导规则，从而保证小步语义不会卡住。定理陈述如下：</p>
<div class="math">$$
(\neg \exists T t,(S, s) \Rightarrow(T, t)) \leftrightarrow S=\text { Stmt. skip }
$$</div>
<p>定理 SmallStep_final (S s) :</p>
<pre><code>theorem SmallStep_deterministic {Ss Ll Rr}
    (hl : Ss \Rightarrow Ll) (hr : Ss \Rightarrow Rr) :
Ll = Rr
</code></pre>
<p>证明通过对<span class="math">\(S\)</span>的结构归纳进行。与大步语义类似，小步语义也是确定性的：</p>
<div class="math">$$
\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{0}, s_{0}\right) \Rightarrow \cdots
$$</div>
<p>证明是通过对hl或hr进行规则归纳。对于小步语义，一个配置<span class="math">\(\left(S_{0}, s_{0}\right)\)</span>如果所有从它开始的执行都是有限的，则终止：<span class="math">\(\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{1}, s_{1}\right) \Rightarrow \cdots \Rightarrow\left(S_{n}, s_{n}\right)\)</span>。如果存在一个无限链<span class="math">\(\left(S_{0}, s_{0}\right) \Rightarrow\left(S_{1}, s_{1}\right) \Rightarrow \cdots\)</span>，则它是非终止的。如果且仅当所有配置都终止，整个编程语言才是终止的。通过取<span class="math">\(S_{0}:=\)</span> Stmt. whileDo (fun_ <span class="math">\(\mapsto\)</span> True) Stmt. skip，很容易证明WHILE语言是非终止的。对于任何<span class="math">\(s_{0}\)</span>，我们都有</p>
<pre><code>theorem SmallStep_skip {S s t} :
    \ ((Stmt.skip, s) \Rightarrow (S, t))
@[simp] theorem SmallStep_seq_Iff {S T s Ut} :
    (S; T, s) \(\Rightarrow\) Ut \(\leftrightarrow\)
    \((\exists S^{\prime} t,(S, s) \Rightarrow\left(S^{\prime}, t\right) \wedge U t=\left(S^{\prime} ; T, t\right))\)
    \(\vee(S=\) Stmt.skip \(\wedge \mathrm{Ut}=(T, s))\)
@[simp] theorem SmallStep_if_Iff \{B S T s Us\} :
    (Stmt.ifThenElse B S T, s) \(\Rightarrow\) Us \(\leftrightarrow\)
    \((B \mathrm{~s} \wedge \mathrm{Us}=(S, s)) \vee(\neg B \mathrm{~B} \wedge \mathrm{Us}=(T, s))\)
</code></pre>
<p>我们可以定义关于小步语义的反演规则，例如：</p>
<pre><code>theorem BigStep_Iff_RTC_SmallStep {Ss t} :
    Ss \(\Longrightarrow t \leftrightarrow S s \Rightarrow *\) (Stmt.skip, t)
</code></pre>

<p>一个更基本的结果是大步语义和小步语义之间的等价性：</p>

<p>回想一下，<span class="math">\(\Rightarrow *\)</span>表示小步谓词<span class="math">\(\Rightarrow\)</span>的自反传递闭包。该定理的证明超出了本课程的范围。我们建议参考《具体语义学：使用Isabelle/HOL》的第7章或本章的演示文件。</p>

<h2>第10章：霍尔逻辑</h2>
<p>如果操作语义对应于一个理想化的解释器，那么霍尔逻辑则对应于一个理想化的验证器。霍尔逻辑可以用来指定编程语言的语义，但它特别适合于对具体程序进行推理并证明其正确性。它以发明者查尔斯·安东尼·理查德（托尼）·霍尔的名字命名。霍尔逻辑也被称为公理语义。</p>


<p>本章深受《具体语义学：使用Isabelle/HOL》第12章的启发。</p>

<h3>10.1 霍尔三元组</h3>
<p>霍尔逻辑是一种框架，用于通过一组推导规则以机械化的方式推导出有效的正确性公式。它使我们能够直接对程序的语法进行推理，而无需关注其操作语义。这种方法之所以是机械化的，是因为推导规则的适用性可以很容易地被检查。</p>
<p>我们首先抽象地引入霍尔逻辑，而不与Lean建立任何联系。在第二步中，我们将看到如何将霍尔逻辑的判断嵌入到Lean中。霍尔逻辑的基本判断称为霍尔三元组。它们的形式为<span class="math">\(\{P\} S\{Q\}\)</span>，其中<span class="math">\(S\)</span>是一个WHILE语句，而<span class="math">\(P\)</span>和<span class="math">\(Q\)</span>是关于程序变量的逻辑公式。目前，我们将这些公式想象为使用熟悉的连接词和量词构建的语法对象。霍尔三元组的预期含义如下：</p>
<p>如果前提条件<span class="math">\(P\)</span>在<span class="math">\(S\)</span>执行之前为真，并且执行正常终止，则后置条件Q在终止时为真。</p>
<p>这是一个部分正确性声明：如果程序正常终止，则程序是正确的；否则，程序的行为可能是任意的。对于WHILE程序，唯一无法正常终止的方式是进入无限循环。对于其他编程语言，无限递归和运行时错误（如除以零）也可能导致发散或异常终止。</p>
<div class="math">$$
\begin{gathered}
\{\text { True }\} b:=4\{b=4\} \\
\{a=2\} b:=2 * a\{a=2 \wedge b=4\} \\
\{b \geq 5\} b:=b * 1\{b \geq 6\}
\end{gathered}
$$</div>
<div class="math">$$
\begin{gathered}
\{\text { False }\} \text { skip }\{b=10\} \\
\{\text { True }\} \text { while } i \neq 10 \text { do } i:=i+1\{i=10\}
\end{gathered}
$$</div>
<p>直观上，以下所有霍尔三元组都应该是有效的：</p>
<p>前三个霍尔三元组应该相当自然。第四个三元组是空洞地成立的，因为前提条件False永远无法满足。霍尔三元组定义中的“如果前提条件<span class="math">\(P\)</span>为真”部分始终为假；因此三元组为真。该三元组等价于命题False <span class="math">\(\rightarrow b=10\)</span>，这对于任何<span class="math">\(b\)</span>的值都成立。至于第五个三元组，无法保证控制会退出循环，但如果确实退出了，那么循环的条件在退出时必须为假，因此我们得到后置条件<span class="math">\(i=10\)</span>。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { \{False }\} S\{\text { True }\} \\
&amp; \text { \{False }\} S\{\text { False }\} \\
&amp; \text { \{True }\} S\{\text { True }\} \\
&amp; \text { \{True }\} S\{\text { False }\}
\end{aligned}
$$</div>
<p>以下三元组虽然奇怪但很有趣：</p>
<p>前两个三元组对于任何语句<span class="math">\(S\)</span>都成立（因此是无意义的）：前置条件从未被满足，因此任何后置条件都空洞地成立。第三个三元组也总是成立，无论<span class="math">\(S\)</span>是什么。第四个三元组在<span class="math">\(S\)</span>永不终止时成立（例如，<span class="math">\(S:=\)</span> while True do skip）；否则，它是假的。</p>
<h3>10.2 霍尔规则</h3>
<p>下面我们给出了一套完整的推导规则，用于推理WHILE程序：</p>
<p><img src="img-8.jpeg" alt="img-8.jpeg"></p>
<div class="math">$$
\{Q[a]\} \times:=a\{Q[x]\}
$$</div>
<p>在ASSIGN规则中，表达式<span class="math">\(Q[a / x]\)</span>表示将条件<span class="math">\(Q\)</span>中所有<span class="math">\(x\)</span>的出现替换为a。该规则有时表示为</p>
<div class="math">$$
\{Q[a]\} \times:=a\{Q[x]\}
$$</div>
<div class="math">$$
\text { ASSIGN }
$$</div>
<p>在ASSIGN规则中，表达式<span class="math">\(Q[a / x]\)</span>表示将条件<span class="math">\(Q\)</span>中所有<span class="math">\(x\)</span>的出现替换为a。该规则有时表示为</p>
<p>其中<span class="math">\([x]\)</span>提取了<span class="math">\(Q\)</span>中<span class="math">\(x\)</span>的出现。</p>
<div class="math">$$
\begin{gathered}
\{0=0\} x:=0\{x=0\} \\
\{0=0 \wedge y=5\} x:=0\{x=0 \wedge y=5\} \\
\{x+1 \geq 5\} x:=x+1\{x \geq 5\}
\end{gathered}
$$</div>
<p>ASSIGN规则可能看起来违反直觉，因为它是逆向工作的：从后置条件出发，计算前置条件。然而，它正确地捕捉了赋值语句的语义，如下所示：</p>
<p>通过基础算术，我们可以简化计算出的前置条件；例如，<span class="math">\(0=0\)</span> 等价于 True，而 <span class="math">\(x+1 \geq 5\)</span> 等价于 <span class="math">\(x \geq 4\)</span>。</p>
<table>
<thead>
<tr>
  <th style="text-align:center"><span class="math">\(\{a=2\}\)</span></th>
  <th style="text-align:center"><span class="math">\(b:=a\{b=2\}\)</span></th>
  <th style="text-align:center">ASSIGN</th>
  <th style="text-align:center"><span class="math">\(\{b=2\}\)</span></th>
  <th style="text-align:center"><span class="math">\(c:=b\{c=2\}\)</span></th>
  <th style="text-align:center">ASSIGN</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"></td>
  <td style="text-align:center"><span class="math">\(\{a=2\}\)</span></td>
  <td style="text-align:center"><span class="math">\(b:=a ; c:=b\{c=2\}\)</span></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
  <td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>Seq规则要求我们提出一个中间条件<span class="math">\(R\)</span>，该条件在执行<span class="math">\(S\)</span>之后并在执行<span class="math">\(T\)</span>之前成立。以下是Seq规则的一个示例：</p>
<p>While规则是最复杂的。条件<span class="math">\(P\)</span>被称为不变量。它既是循环本身的前后条件，也是其循环体的前后条件。循环体的前置条件通过<span class="math">\(B\)</span>在执行循环体之前必须为真这一知识得到加强。同样，循环的后置条件通过<span class="math">\(B\)</span>在循环退出时必须为假这一知识得到加强。</p>
<div class="math">$$
\text { P } s_{0} \quad \text { P } s_{1} \wedge B s_{1} \quad \cdots \quad P s_{n-1} \wedge B s_{n-1} \quad P s_{n} \wedge \neg B s_{n}
$$</div>
<p>考虑一个执行<span class="math">\(n\)</span>次迭代的循环。假设初始状态为<span class="math">\(s_{0}\)</span>，且第<span class="math">\(i\)</span>次迭代后的状态为<span class="math">\(s_{i}\)</span>。那么以下条件将成立：</p>
<div class="math">$$
x&gt;8 \rightarrow x&gt;4 \quad \frac{\{x&gt;4\} y:=x\{y&gt;4\}}{\{x&gt;8\} y:=x\{y&gt;0\}} \text { AsGIGN }
$$</div>
<p>如果<span class="math">\(n=0\)</span>，我们立即得到<span class="math">\(\mathrm{P} s_{0} \wedge \neg \mathrm{~B} s_{0}\)</span>并且永远不会进入循环。CONSEQ 是唯一一个在其前提中包含逻辑公式而非Hoare三元组的规则。这些条件必须被消除，无论是使用纸笔还是证明助手。CONSEQ 可用于加强前置条件（即使其更具限制性），减弱后置条件（即使其更少限制性），或两者兼而有之。以下是一个推导示例：</p>
<p>从上到下阅读树结构，我们已将三元组的前置条件从<span class="math">\(x&gt;4\)</span>加强为<span class="math">\(x&gt;8\)</span>，并将后置条件从<span class="math">\(y&gt;4\)</span>弱化为<span class="math">\(y&gt;0\)</span>。我们也可以从下往上阅读树结构：为了证明三元组<span class="math">\(\{x&gt;8\} y:=x\)</span> <span class="math">\(\{y&gt;0\}\)</span>，只需证明<span class="math">\(\{x&gt;4\} y:=x\{y&gt;4\}\)</span>，其中前置条件被弱化，后置条件被加强。</p>
<p>除了CONSEQ规则外，其他规则都是语法驱动的：我们只需检查当前语句，就能知道在每种情况下应该应用哪条规则。对于赋值语句，我们应用ASSIGN规则；对于while循环，我们应用While规则；以此类推。</p>
<div class="math">$$
\begin{aligned}
&amp; \frac{P \rightarrow Q}{\{P\} \text { skip }\{Q\}} \text { Skip' } \\
&amp; \frac{P \rightarrow Q[a / x]}{\{P\} \times:=a\{Q\}} \text { ASSIGN' } \\
&amp; \frac{\{P \wedge B\} S\{P\} \quad P \wedge \neg B \rightarrow Q}{\{P\} \text { while } B \text { do } S\{Q\}} \text { WHILE' }
\end{aligned}
$$</div>
<p>规则 Seq、IF 和 CONSEQ 是双向的：它们的结论形式为 <span class="math">\(\{P\} \ldots\{Q\}\)</span>，其中 <span class="math">\(P, Q\)</span> 是不同的数学变量。这使得它们应用起来更加方便。通过将其他规则与 CONSEQ 结合，我们可以推导出双向的变体：</p>
<p>作为练习，你可以尝试从SKIP、ASSIGN或WHILE规则与CONSEQ规则结合推导出这些规则中的每一个。</p>
<h3>10.3 Hoare逻辑的语义方法</h3>
<p>在Lean中编码Hoare逻辑的一种自然方式是按照我们为大步和小步语义所做的那样：定义一个Hoare三元组的语法概念和一个归纳谓词，每个核心Hoare规则对应一个引入规则；为了表示前置条件和后置条件，使用状态上的谓词（State <span class="math">\(\rightarrow\)</span> Prop）。然后我们可以证明其相对于大步语义的可靠性，即：每当<span class="math">\(\{P\} S\{Q\}\)</span>可推导时，如果<span class="math">\(P s\)</span>且<span class="math">\((S, s) \Longrightarrow t\)</span>，则<span class="math">\(Q t\)</span>。这仅仅是Hoare三元组直观含义的逻辑表达：</p>
<p>如果前置条件<span class="math">\(P\)</span>在<span class="math">\(S\)</span>执行之前为真（即<span class="math">\(P\)</span> s）且执行正常终止（即<span class="math">\((S, s) \Longrightarrow t\)</span>），则后置条件<span class="math">\(Q\)</span>在终止时为真（即<span class="math">\(Q t\)</span>）。</p>
<p>我们不采用这种方法，而是建议在Lean中根据大步语义来定义Hoare三元组，使其在定义上就是正确的。然后我们将Hoare规则作为定理推导出来，而不是将其作为引入规则陈述。结合使用谓词来表示公式，这种方法坚定地采用了语义学的方式。</p>
<pre><code>def PartialHoare (P : State \(\rightarrow\) Prop) (S : Stmt)
    (Q : State \(\rightarrow\) Prop) : Prop :=
    \(\forall \mathrm{s} \mathrm{t}, \mathrm{P} \mathrm{s} \rightarrow(\mathrm{S}, \mathrm{s}) \Longrightarrow \mathrm{t} \rightarrow \mathrm{Q} \mathrm{t}\)
</code></pre>
<p>霍尔三元组（用于部分正确性）定义如下：</p>
<p>我们不写作PartialHoare P S Q，而是引入一些语法糖来允许<span class="math">\(\{* P *\}(S)\{* Q *\}\)</span>，这更接近非正式语法<span class="math">\(\{P\} S\{Q\}\)</span>。</p>
<pre><code>theorem skip_intro {P} :
    {* P *} (Stmt.skip) {* P *}
theorem assign_intro (P) {x a} :
    {* fun s }-&gt;\mathrm{P}(\mathrm{s}[\mathrm{x} \mapsto \mathrm{a} \mathrm{s}]) *}\mathrm{ (Stmt.assign x a) {* P *}
theorem seq_intro {P Q R S T} (hS : {* P *} (S) {* Q *})
    (hT : {* Q *} (T) {* R *}) :
    {* P *} (S; T) {* R *}

theorem if_intro {B P Q S T}
    (hS : {* fun s }-&gt;\mathrm{ P s ^ { \Lambda } B s *} (S) {* Q *})
    (hT : {* fun s }-&gt;\mathrm{ P s ^ { \neg } \neg \mathrm { B } \mathrm { s } *} (T) {* Q *}) :
{* P *} (Stmt.ifThenElse B S T) {* Q *}
theorem while_intro (P) {B S}
    (h : {* fun s }-&gt;\mathrm{ P s ^ { \Lambda } B s *} (S) {* P *}) :
{* P *} (Stmt.whileDo B S) {* fun s }-&gt;\mathrm{ P s ^ { \neg } \neg \mathrm { B } \mathrm { s } *}
theorem consequence {P P' Q Q' S}
    (h : {* P *} (S) {* Q *}) (hp : Vs, P' s -&gt; P s)
    (hq : Vs, Q s -&gt; Q' s) :
{* P' *} (S) {* Q' *}
</code></pre>
<p>核心的霍尔规则如下所述：</p>
<p>上述所有定理的证明都基于大步语义。一些三元组——例如，assign_intro中的前置条件——需要引用状态。然后我们使用一个匿名函数来访问它。回想一下，<span class="math">\(P\)</span>和函数<span class="math">\(s \mapsto P s\)</span>是相等的（通过<span class="math">\(\eta\)</span>-转换）。此外，对于非正式写作的前提<span class="math">\(P \rightarrow Q\)</span>，在Lean中我们必须写成<span class="math">\(\forall s, P s \rightarrow Q s\)</span>。如第9章所述，赋值规则中的语法<span class="math">\(s[x \mapsto n]\)</span>表示与<span class="math">\(s\)</span>相同的状态，只是它将<span class="math">\(x\)</span>映射到<span class="math">\(n\)</span>。</p>
<pre><code>theorem consequence_left (P') {P Q S}
    (h : {* P *} (S) {* Q *}) (hp : Vs, P' s -&gt; P s) :
{* P' *} (S) {* Q *}
theorem consequence_right (Q) {Q' P S}
    (h : {* P *} (S) {* Q *}) (hq : Vs, Q s -&gt; Q' s) :
{* P *} (S) {* Q' *}
theorem skip_intro' {P Q} (h : Vs, P s -&gt; Q s) :
{* P *} (Stmt.skip) {* Q *}
theorem assign_intro' {P Q x a}
    (h : Vs, P s -&gt; Q (s[x }-&gt;\mathrm{ a s}])):
{* P *} (Stmt.assign x a) {* Q *}
theorem seq_intro' {P Q R S T} (hT : {* Q *} (T) {* R *})
    (hS : {* P *} (S) {* Q *}) :
{* P *} (S; T) {* R *}
theorem while_intro' {B P Q S} (I)
    (hS : {* fun s }-&gt;\mathrm{ I s ^ { \Lambda } B s *} (S) {* I *})
    (hP : Vs, P s -&gt; I s)
    (hQ : Vs, ~ B s -&gt; I s -&gt; Q s) :
{* P *} (Stmt.whileDo B S) {* Q *}
</code></pre>
<p>以下便利规则可以从核心规则中推导出来：</p>
<pre><code>theorem assign_intro_forward (P) {x a} :
    {* P *}
    (Stmt.assign x a)
    {* fun s }-&gt;\mp@subsup{\exists}{n}{o},\mathrm{ P }\left(s[x\leftrightarrow n_{0}\right])
        \wedge s x = a (s[x }\mp@subsup{n}{}{\rightarrow}\mathrm{ n
    by
    apply assign_intro'
    intro s hP
    apply Exists.intro (s x)
    simp [*]
</code></pre>
<p>使用双向的assign_intro'，我们可以推导出赋值规则的前向版本：</p>
<p>变量<span class="math">\(n_{0}\)</span>表示赋值前<span class="math">\(x\)</span>的值。因此，在后置条件中，<span class="math">\(s\left[x \mapsto n_{0}\right]\)</span>表示赋值前的状态。由于<span class="math">\(P\)</span>是前置条件，我们有<span class="math">\(P\left(s\left[x \mapsto n_{0}\right]\right)\)</span>。此外，<span class="math">\(x\)</span>的新值由<span class="math">\(s x\)</span>给出，必须等于表达式a在旧状态<span class="math">\(s\left[x \mapsto n_{0}\right]\)</span>中计算的值。</p>
<pre><code>theorem assign_intro_backward (Q) {x a} :
    {* fun s }-&gt;\exists\mathrm{n}^{\prime}, \mathrm{Q}\left(\mathrm{ s[x \mapsto n^{\prime}]}\right) \wedge n^{\prime}=\mathrm{a} \mathrm{ s *}\}
    (Stmt.assign x a)
    {* Q *}
</code></pre>
<p>前向规则不如后向规则方便，因为后置条件包含一个存在量词。可以用类似的风格陈述后向规则，揭示一种隐藏的对称性：</p>
<p>注意，这个存在量词可以使用单点规则（第4.3节）消除。然后我们得到了熟悉的后向规则assign_intro，其中fun s <span class="math">\(\mapsto\)</span> <span class="math">\(P(s[x \mapsto a s])\)</span>作为前置条件。</p>
<pre><code>def SWAP : Stmt :=
    Stmt.assign "t" (fun s }-&gt;\mathrm{ s "a");
    Stmt.assign "a" (fun s }-&gt;\mathrm{ s "b");
    Stmt.assign "b" (fun s }-&gt;\mathrm{ s "t")
</code></pre>
<h3>10.4 第一个程序：交换两个变量</h3>
<p>让我们使用霍尔逻辑来验证我们的第一个程序：一个三行程序，用于交换变量<span class="math">\(a\)</span>和<span class="math">\(b\)</span>的值，并使用<span class="math">\(t\)</span>作为临时存储。该程序定义如下：</p>
<pre><code>theorem SWAP_correct (a b b o : N) :
    {* fun s }-&gt;\mathrm{ s "a" = a b \wedge s "b" = b b *}
    (SWAP)
    {* fun s }-&gt;\mathrm{ s "a" = b b \wedge s "b" = a b *}
</code></pre>
<p>正确性陈述如下：</p>
<p>逻辑变量<span class="math">\(a_{0}\)</span>和<span class="math">\(b_{0}\)</span>“冻结”了程序变量<span class="math">\(a\)</span>和<span class="math">\(b\)</span>的初始值，以便我们可以在后置条件中引用它们。毕竟，使用函数<span class="math">\(s \mapsto s\)</span>“a”<span class="math">\(=s\)</span>“b”<span class="math">\(\wedge s\)</span>“b”<span class="math">\(=s\)</span>“a”作为后置条件是毫无意义的。</p>
<pre><code>apply PartialHoare.seq_intro'
apply PartialHoare.seq_intro'
apply PartialHoare.assign_intro
apply PartialHoare.assign_intro
apply PartialHoare.assign_intro'
aesop
</code></pre>

<p>正确性证明如下：</p>

<pre><code>\foralls : State,
    \(s " a "=a_{0} \wedge s " b "=b_{0} \rightarrow\)
    \(s[" t " \mapsto s " a " \left[" a " \mapsto s[" t " \mapsto s " a " \left[" b "\right]\right.\)
        ["b" \(\mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left.\left.[" a " \mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left[" b "\right]\right] \mathrm{t} " \mathrm{t} " \mathrm{a} "=\mathrm{b}_{0} \wedge\right.\)
    \(s[" t " \mapsto s " a " \left[" a " \mapsto s[" t " \mapsto s " a " \left[" b "\right]\right.\)
        ["b" \(\mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left.\left.[" a " \mapsto \mathrm{s}[" t " \mapsto \mathrm{s} " \mathrm{a} " \left[" b "\right]\right] \mathrm{t} " \mathrm{t} " \mathrm{b} "=\mathrm{a}_{0}\)
</code></pre>
<p>顺序组合和赋值规则的应用由程序的语法指导。程序中有两个顺序组合和三个赋值，因此有相应规则的多次调用。我们最终得到了一个在美学上极具挑战性的子目标：</p>

<p>幸运的是，simp [*] at * 可以显著简化子目标，而 aesop 甚至可以完全自动地证明它。</p>

<pre><code>def ADD : Stmt :=
    Stmt.whileDo (fun s }\mapsto\mathrm{ s "n" \neq \emptyset)
        (Stmt.assign "n" (fun s }\mapsto\mathrm{ s "n" - 1);
        Stmt.assign "m" (fun s }\mapsto\mathrm{ s "m" + 1))
</code></pre>
<h3>10.5 第二个程序：两数相加</h3>
<p>我们的第二个示例计算<span class="math">\(m+n\)</span>，并将结果保留在<span class="math">\(m\)</span>中，仅使用以下基本操作：<span class="math">\(k+1, k-1\)</span>和<span class="math">\(k \neq \emptyset\)</span>（对于任意<span class="math">\(k\)</span>）：</p>
<pre><code>theorem ADD_correct ( }\mathrm{n}_{0}\mathrm{ m}_{0}: \mathbb{N}\mathrm{ ):
    {* fun s }\mapsto\mathrm{ s "n" = n
    (ADD)
    {* fun s }\mapsto\mathrm{ s "n" = 0 \wedge s "m" = n
    PartialHoare.while_intro' (fun s }\mapsto\mathrm{ s "n" + s "m" = n
    (by
        apply PartialHoare.seq_intro'
        { apply PartialHoare.assign_intro }
        { apply PartialHoare.assign_intro'
            aesop })
    (by aesop)
    (by aesop)
</code></pre>
<p>由于存在while循环，证明过程更为复杂：</p>
<p>第一步是应用带有循环不变量的派生while规则。我们的不变量是程序变量<span class="math">\(n\)</span>和<span class="math">\(m\)</span>的和必须等于期望的数学结果<span class="math">\(n_{0}+m_{0}\)</span>，其中<span class="math">\(n_{0}\)</span>和<span class="math">\(m_{0}\)</span>对应于<span class="math">\(n\)</span>和<span class="math">\(m\)</span>的初始值，这是由前置条件所要求的。</p>
<p>我们是如何得出这个不变量的？即使对于一个简单的循环，找到一个合适的不变量也可能具有挑战性。难点在于不变量必须1. 在进入循环时为真；2. 如果在迭代前为真，则在每次迭代后仍然为真；3. 足够强大以隐含所需的循环后条件。</p>
<p>像True这样的不变量满足要求1和2，但通常不满足3。同样，False满足要求2和3，但不满足1。在实践中，不变量往往采用以下形式：已完成的工作 + 剩余的工作 = 期望的结果，其中+代表某个适当的运算符（不一定是加法）。当我们进入循环时，已完成的工作通常为o（或其他适当的“零”值），不变量变为剩余的工作 = 期望的结果。这个等式必须在循环开始时可证明——要么来自前一条语句的后置条件，要么来自整个程序的期望前置条件（如果没有前一条语句）。当我们退出循环时，剩余的工作应该为o（或其变体），不变量变为已完成的工作 = 期望的结果。通常，已完成的工作采用我们累积结果的变量的形式，而剩余的工作类似于期望的结果，但依赖于在循环内值发生变化的程序变量，并考虑已完成的工作。</p>
<p>对于ADD程序的循环，已完成的工作是<span class="math">\(m\)</span>，剩余的工作是<span class="math">\(n\)</span>，期望的结果是<span class="math">\(n_{0}+m_{0}\)</span>。进入循环时，不变量<span class="math">\(m=n=n_{0}+m_{0}\)</span>成立，因为此时<span class="math">\(m=m_{0}\)</span>且<span class="math">\(n=n_{0}\)</span>。（在这个例子中，已完成的工作通常不为o，因为我们重用输入<span class="math">\(m\)</span>作为累加器，作为一种优化。）退出循环时，我们有<span class="math">\(n=0\)</span>，因此不变量变为<span class="math">\(m=n_{0}+m_{0}\)</span>。我们可以从<span class="math">\(m\)</span>中获取结果。</p>
<p>while_intro' 定理被直接用作证明项。它产生了三个子目标。证明不变量由期望的前置条件蕴含以及它蕴含期望的后置条件的证明是简单的：它们由对 aesop 的调用组成。唯一非平凡的子目标是执行循环体时保持不变量的条件。</p>
<p>对于这个例子，霍尔逻辑确实很有帮助。直接基于操作语义进行推理会很不方便，因为我们需要归纳法来推理while循环。而通过霍尔逻辑，这种归纳在while_intro规则的证明中一劳永逸地完成了。</p>
<h3>10.6 验证条件生成器</h3>
<p>验证条件生成器（VCGs）是应用霍尔逻辑规则的程序，生成需要手动证明的验证条件。我们可以将它们视为处理霍尔逻辑事务的机械公务员。作为用户，我们必须在程序中提供足够强大的循环不变式作为注释。数以百计的程序验证工具都基于这些原则。</p>
<p>验证条件生成器（VCG）通常从后置条件开始逆向工作，使用以任意Q作为其后置条件的逆向规则。这种方法效果很好，因为Hoare逻辑的核心规则——赋值规则——是逆向的。</p>
<pre><code>def Stmt.invWhileDo (I B : State \(\rightarrow\) Prop) (S : Stmt) : Stmt :=
    Stmt.whileDo B S
</code></pre>
<p>我们可以使用Lean的元编程框架来定义一个简单的VCG。首先，我们引入一个名为Stmt.invWhileDo的常量，它除了循环条件B和循环体S外，还携带了一个用户提供的循环不变量I：</p>
<pre><code>theorem invWhile_intro \(\{B\) I Q S\}
    \((h S:\{ *\) fun \(s \mapsto I s \wedge B s *\}(S)\{ * I *\})\)
    \((h Q: \forall s, \neg B s \rightarrow I s \rightarrow Q s)\) :
    \(\{* I *\}(\) Stmt.invWhileDo I B S) \{* Q *\} :=
    while_intro' I hS (by aesop) hQ
theorem invWhile_intro' \{B I P Q S\}
    \((h S:\{ *\) fun \(s \mapsto I s \wedge B s *\}(S)\{ * I *\})\)
    \((h P: \forall s, P s \rightarrow I s)(\mathrm{hQ}: \forall s, \neg B s \rightarrow I s \rightarrow Q s)\) :
    \(\{* P *\}(\) Stmt.invWhileDo I B S) \{* Q *\} :=
    while_intro' I hS hP hQ
</code></pre>
<p>我们为该结构提供了两条Hoare规则：一条是后向规则，另一条是双向规则。这两条规则都基于双向的while_intro'规则进行论证。</p>
<p>上述规则仅使用不变式注解作为它们的不变式。在使用该框架时，我们必须小心地为所有while循环标注合适的不变式。如果我们指定了错误的不变式，将会遇到无法证明的子目标，这表明我们必须修正不变式。</p>
<pre><code>def matchPartialHoare : Expr \(\rightarrow\) Option (Expr \(\times\) Expr \(\times\) Expr)
    | (Expr.app (Expr.app (Expr.app
        (Expr.const ''PartialHoare _) P) S) Q) =&gt;
        Option.some (P, S, Q)
    | _ =&gt;
        Option.none
partial def vcg : TacticM Unit :=
    do
        let goals \(\leftarrow\) getUnsolvedGoals
        if goals.length != 0 then
            let target \(\leftarrow\) getMainTarget
            match matchPartialHoare target with
            | Option.none =&gt; return
            | Option.some (P, S, Q) =&gt;
            if Expr.isAppOfArity S ''Stmt.skip 0 then
                if Expr.isMVar P then
                applyConstant ''PartialHoare.skip_intro
                else
                applyConstant ''PartialHoare.skip_intro'
            else if Expr.isAppOfArity S ''Stmt.assign 2 then
                if Expr.isMVar P then
                applyConstant ''PartialHoare.assign_intro
                else

    applyConstant ''PartialHoare.assign_intro'
else if Expr.isAppOfArity S ''Stmt.seq 2 then
    andThenOnSubgoals
        (applyConstant ''PartialHoare.seq_intro') vcg
else if Expr.isAppOfArity S ''Stmt.ifThenElse 3 then
        andThenOnSubgoals
            (applyConstant ''PartialHoare.if_intro) vcg
else if Expr.isAppOfArity S ''Stmt.invWhileDo 3 then
        if Expr.isMVar P then
            andThenOnSubgoals
                (applyConstant ''PartialHoare.invWhile_intro) vcg
            else
                andThenOnSubgoals
                (applyConstant ''PartialHoare.invWhile_intro')
                vcg
            else
                failure
elab "vcg" : tactic =&gt;
vcg
</code></pre>

<p>VCG的代码相当简洁：</p>

<p>VCG提取第一个目标的目标并检查它。如果它是一个Hoare三元组，VCG会检查其前置条件<span class="math">\(P\)</span>和语句<span class="math">\(S\)</span>。如果前置条件是一个元变量（例如，?P），VCG会应用一个后向规则（通过我们在第8.7节中定义的apply Constant函数），如果存在这样的规则，因为它将实例化元变量。否则，使用双向规则，以其前置条件为任意变量，该变量可以与目标的前置条件匹配。对于while循环，我们只考虑使用Stmt.invWhileDo的程序，因为通常我们无法通过编程方式猜测不变式。</p>
<p>VCG对复合语句中新出现的所有子目标递归调用自身（通过我们在第8.7节中定义的andThenOnSubgoals函数）。</p>
<pre><code>theorem ADD_correct_vcg ( }\mp@subsup{n}{0}{}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\mathrm{ m}\)
    (ADD)
    {* fun s \mapsto s "n" = 0 ^ { \pm } \mp@subsup { \pm } { \pm } \mp@subsup { \pm } { \pm } \mathrm { m } " = \mp@subsup { n } { \pm } { \pm } }
    (Stmt.invWhileDo (fun s \mapsto s "n" + s "m" = n }\mp@subsup{n}{0}{}\mathrm{ + m}\mp@subsup{}{0}\)
        (fun s \mapsto s "n" \neq 0)
        (Stmt.assign "n" (fun s \mapsto s "n" - 1);
        Stmt.assign "m" (fun s \mapsto s "m" + 1)))
    {* fun s \mapsto s "n" = 0 ^ { \pm } \mp@subsup { \pm } { \pm } \mp@subsup { \pm } { \pm } " \mathrm { m } " = \mp@subsup { n } { \pm } { \pm } \mp@subsup { \pm } { \pm } } " \mathrm { m } " = \mp@subsup { n } { \pm } { \pm } \mp@subsup { \pm } { \pm } \mathrm { m } " }
    by
    vcg &lt;;&gt;
        aesop
</code></pre>
<h3>10.7 重访第二个程序：两数相加</h3>
<p>使用验证条件生成器，我们可以重新审视上述ADD程序的正确性证明：</p>
<p>首先，我们使用show来为while循环添加一个不变量进行注释。回想一下，show命令以计算等价的方式重新陈述目标。在这里，我们利用这一功能将Stmt. whileDo替换为Stmt. invWhileDo，根据定义，Stmt. invWhileDo等于Stmt. whileDo。除此之外，程序及其前置条件和后置条件与定理陈述中的内容相同。</p>
<p>我们首先调用vcg作为证明步骤。这将应用所有必要的Hoare规则，并留下一些子目标，这些子目标对于aesop来说无法匹配。</p>

<h3>10.8 完全正确性的霍尔三元组</h3>
<p>到目前为止，本章的重点一直是部分正确性。当我们陈述霍尔三元组<span class="math">\(\{P\} S\{Q\}\)</span>时，我们声称如果程序<span class="math">\(S\)</span>终止，最终状态将满足<span class="math">\(Q\)</span>，但当<span class="math">\(S\)</span>不终止时，我们什么也没说。特别是，我们可以为发散程序while True do skip证明任何后置条件。这显然过于宽松：如果你在考试中被要求编写一个排序算法，你当然不应该给出while True do skip作为答案。</p>

<p>完全正确性是一个更强的概念，它在部分正确性的基础上进一步断言程序会正常终止。我们首先关注部分正确性，因为它更简单，而且无论如何它都是完全正确性的必要组成部分。</p>
<p>完全正确性的霍尔三元组具有形式<span class="math">\([P] S[Q]\)</span>，其含义如下：</p>
<p>如果在执行<span class="math">\(S\)</span>之前前置条件<span class="math">\(P\)</span>成立，则执行正常终止，并且在最终状态下后置条件<span class="math">\(Q\)</span>成立。</p>
<p>对于确定性程序，这可以等价地表达为：如果在执行<span class="math">\(S\)</span>之前前提条件<span class="math">\(P\)</span>成立，则存在一个状态，在该状态下执行正常终止且后置条件<span class="math">\(Q\)</span>在该状态中成立。</p>
<div class="math">$$
[i \leq 10] \text { while } i&lt;10 \text { do } i:=i+1[i=10]
$$</div>
<p>以下是一个有效的霍尔三元组示例：</p>
<div class="math">$$
\frac{\left[P \wedge B \wedge v=v_{0}\right] S\left[P \wedge v&lt;v_{0}\right]}{\left[P\right] \text { while } B \text { do } S[P \wedge \neg B]} \text { WHILE-VAR }
$$</div>
<p>对于WHILE语言，部分正确性与完全正确性的区别仅涉及while循环（以及包含它们的程序）。while的Hoare规则现在必须用一个变体v——一个每次迭代减少一个或多个的自然数——来注释：</p>
<p>这里，<span class="math">\(v_{0}\)</span> 是一个逻辑变量，它冻结了 v 的初始值，其作用域是整个前提，而 <span class="math">\(v\)</span> 是一个数学变量（如 <span class="math">\(P, B\)</span> 和 <span class="math">\(S\)</span>）。对于上面的例子，我们可以将 <span class="math">\(10-1\)</span> 作为变体（或 <span class="math">\(50-1\)</span> 或 <span class="math">\(1024-1 * i\)</span>）。</p>
<table>
<thead>
<tr>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{0}\)</span></th>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{1} \wedge \mathrm{BS}_{1}\)</span></th>
  <th style="text-align:center"><span class="math">\(\cdots\)</span></th>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{n-1} \wedge \mathrm{BS}_{n-1}\)</span></th>
  <th style="text-align:center"><span class="math">\(\mathrm{PS}_{n} \wedge \neg \mathrm{BS}_{n}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{0}\)</span></td>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{1}\)</span></td>
  <td style="text-align:center"><span class="math">\(\cdots\)</span></td>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{n-1}\)</span></td>
  <td style="text-align:center"><span class="math">\(\mathrm{~V} \mathrm{~S}_{n}\)</span></td>
</tr>
</tbody>
</table>
<p>考虑一个对应于<span class="math">\(n\)</span>次循环迭代的执行<span class="math">\(s_{0}, s_{1}, \ldots, s_{n-1}, s_{n}\)</span>，如第10.2节所述。以下条件将成立：</p>
<p>完全正确性的霍尔三元组理论在本章的练习表中进行了阐述。</p>
<h2>第11章：指称语义</h2>
<p>我们现在回顾第三种指定编程语言语义的方式：指称语义。指称语义直接将程序的意义指定为一个数学对象。如果操作语义对应于一个理想化的解释器，而霍尔逻辑对应于一个理想化的验证器，那么指称语义则对应于一个理想化的编译器：这个编译器不是将源代码翻译为汇编语言，而是直接翻译为数学。</p>
<p>本章核心内容紧密参照了《具体语义学：使用Isabelle/HOL》的第11章。</p>
<div class="math">$$
\llbracket \rrbracket: \text { syntax } \rightarrow \text { semantics }
$$</div>
<h3>11.1 组合性</h3>
<p>指称语义将每个程序的含义定义为一个数学对象。抽象地看，它可以被视为一个函数</p>
<div class="math">$$
\llbracket S \rrbracket=\{(s, t) \mid(S, s) \Longrightarrow t\}
$$</div>
<p>指称语义的一个关键属性是组合性：复合语句的含义应根据其组件的含义来定义。考虑以下直接定义</p>
<div class="math">$$
\llbracket S \rrbracket=\{s t \mid(S, \text { Prod.fst st }) \Longrightarrow \text { Prod.snd st }\}
$$</div>
<p>根据大步语义（<span class="math">\(\Longrightarrow\)</span>）。实际上，由于Lean只支持在竖线左侧使用变量，我们必须写成</p>
<p>该定义指定了所需的语义，但由于缺乏组合性，它不能算作指称语义：复合语句（顺序组合、if-then-else 和 while）的含义是直接给出的，而没有使用其组件的指称。</p>
<div class="math">$$
\begin{aligned}
&amp; \llbracket S ; T \rrbracket=\ldots \llbracket S \rrbracket \ldots \llbracket T \rrbracket \ldots \\
&amp; \llbracket \text { if } B \text { then } S \text { else } T \rrbracket=\ldots \llbracket S \rrbracket \ldots \llbracket T \rrbracket \ldots \\
&amp; \llbracket \text { while } B \text { do } S \rrbracket=\ldots \llbracket S \rrbracket \ldots
\end{aligned}
$$</div>
<p>完全组合式的定义使我们能够以等式的方式推理程序，这通常比使用<span class="math">\(\Longrightarrow\)</span>的引入、消除和反转原则更为方便。本质上，我们希望得到结构递归的等式形式</p>
<div class="math">$$
\text { eval }: \underbrace{\operatorname{AExp}}_{\text {syntax }} \rightarrow \underbrace{(\operatorname{String} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Z}}_{\text {semantics }}
$$</div>
<p>在右侧不出现<span class="math">\(S\)</span>和<span class="math">\(T\)</span>，除非作为<span class="math">\(\llbracket \rrbracket\)</span>的参数。一个用于算术表达式的求值函数</p>
<div class="math">$$
\text { eval (AExp.add } e_{1} e_{2} \text { ) env = eval } e_{1} \text { env + eval } e_{2} \text { env }
$$</div>

<p>满足诸如</p>

<p>这是一种指称语义，因为AExp.add <span class="math">\(e_{1} e_{2}\)</span>的语义是根据<span class="math">\(e_{1}\)</span>和<span class="math">\(e_{2}\)</span>的语义来定义的。</p>
<p>指称语义学自然适用于算术表达式以及函数式程序。现在我们希望为命令式程序提供一种方便的指称语义。由于while循环不保证终止，我们需要发展一些额外的数学概念，以便能够构建所需的语义。</p>
<h3>11.2 关系式指称语义</h3>
<p>确定性语言的指称语义通常被表示为从前状态到后状态的函数，但关系更为通用且更便于操作。我们提出一种关系式指称语义。</p>
<p>程序的指称语义将是一个类型为Set (State <span class="math">\(\times\)</span> State)的数学对象。关系方法也被用于大步语义，它采用了一个类型为State <span class="math">\(\rightarrow\)</span> State <span class="math">\(\rightarrow\)</span> Prop的谓词。这两种类型是同构的，但Set <span class="math">\(\alpha\)</span>，定义为<span class="math">\(\alpha \rightarrow\)</span> Prop，支持许多有用的操作和符号，如<span class="math">\(\emptyset, \cup, \cap, \in\)</span>，以及<span class="math">\(\{\ldots \mid \ldots\}\)</span>（第7.7节）。</p>
<pre><code>def denote : Stmt \(\rightarrow\) Set (State \(\times\) State)
    | Stmt.skip \(\quad=&gt;\) Id
    | Stmt.assign x a \(\quad=&gt;\)
        \(\{\) st | Prod.snd st \(=\left(\right.\) Prod.fst st) \([x \mapsto\) a (Prod.fst st) \()\}\)
    | Stmt.seq S T \(\quad=&gt;\) denote \(S \bigcirc\) denote T
    | Stmt.ifThenElse B S T =&gt;
        (denote S ; B) \(\cup\) (denote \(\mathrm{T} ;\) (fun \(\mathrm{s} \mapsto \neg \mathrm{B} \mathrm{s}\) ))
</code></pre>
<p>我们的语义称为denote，并用<span class="math">\(\llbracket \rrbracket\)</span>作为语法糖。我们从定义的前四个方程开始，同时将while保留到后面：</p>
<p>跳过语句被解释为状态上的恒等关系，即所有形式为（<span class="math">\(s, s\)</span>）的元组的集合。这捕捉了跳过语句的期望语义：后状态始终与前状态相同。</p>
<p>赋值的语义是那些第二个分量反映了赋值结果的元组集合。</p>
<div class="math">$$
r_{1} \bigcirc r_{2}=\{\mathrm{ac} \mid \exists b,(\text { Prod.fst ac, b }) \in r_{1} \wedge(b, \text { Prod.snd ac }) \in r_{2}\}
$$</div>
<p>顺序组合的语义可以优雅地表示为关系组合<span class="math">\(\bigcirc\)</span>，其由以下方程定义</p>
<div class="math">$$
r_{1} \bigcirc r_{2}=\left\{(a, c) \mid \exists b,(a, b) \in r_{1} \wedge(b, c) \in r_{2}\right\}
$$</div>
<p>这个定义在表达为以下形式时可能更容易理解。</p>
<p>遗憾的是，Lean无法处理这种形式；推导式的左侧部分必须是一个单一变量。</p>
<div class="math">$$
r: P=\{a b \mid a b \in r \wedge P(\text { Prod.fst } a b)\}
$$</div>
<p>if-then-else语句的语义被定义为两个分支语义的并集，限制为仅包含那些第一个分量使布尔条件为真或假的元组，具体取决于分支。限制运算符的定义如下：</p>
<div class="math">$$
r: P=\{(a, b) \mid(a, b) \in r \wedge P a\}
$$</div>
<p>一个更直观的定义应该是</p>
<p>但同样地，Lean 并不支持这一点。注意两种退化情况：如果 <span class="math">\(P:=\)</span> (fun <span class="math">\(\rightarrow \mapsto\)</span> True)，那么 <span class="math">\(r: P=r\)</span>；如果 <span class="math">\(P:=\)</span> (fun_ <span class="math">\(\mapsto\)</span> False)，那么 <span class="math">\(r: P=\emptyset\)</span>。</p>
<pre><code>| Stmt.whileDo B S =&gt;
    ((denote S ○ denote (Stmt.whileDo B S)) : B)
    \cup (Id ; (fun s \mapsto \neg B s))
</code></pre>
<p>当我们尝试定义while循环的语义时，困难就出现了。我们希望能够写成</p>
<div class="math">$$
X=((\text { denote } S \bigcirc X) ; B) \cup(\text { Id } ;(\text { fun } s \mapsto \neg B s))
$$</div>
<p>但由于对Stmt. whileDo B S的递归调用，这是不合理的。我们需要其他东西。我们在右侧寻找的是一个满足方程的项<span class="math">\(X\)</span>。</p>
<pre><code>| Stmt.whileDo B S =&gt;
    lfp (fun X \mapsto((denote S \bigcirc X) ; B)
        \cup (Id ; (fun s \mapsto \neg B s)))
</code></pre>
<p>我们正在寻找数学家所称的不动点。接下来的四个部分将致力于构建一个操作符lfp，该操作符计算给定方程式的不动点。使用lfp，我们将能够通过以下方式定义while循环的语义：</p>
<div class="math">$$
X=f X
$$</div>

<h3>11.3 不动点</h3>
<p>函数<span class="math">\(f\)</span>的不动点（或固定点）是方程<span class="math">\(X\)</span>的解。</p>

<p>一般来说，某些<span class="math">\(f\)</span>可能根本不存在不动点；例如，如果<span class="math">\(f:=\)</span> Nat. succ，那么不存在任何值<span class="math">\(X\)</span>使得<span class="math">\(X=\)</span> Nat. succ <span class="math">\(X\)</span>。也可能存在多个不动点；例如，如果<span class="math">\(f:=(f u n x \mapsto x)\)</span>，那么任何<span class="math">\(X\)</span>都是<span class="math">\(X=(f u n\)</span> <span class="math">\(x \mapsto x) X=X\)</span>的解。在<span class="math">\(f\)</span>满足某些条件的情况下，保证存在唯一的最小不动点和唯一的最大不动点。</p>
<div class="math">$$
X=(\text { fun } n: \mathbb{N} \mapsto n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge X m))
$$</div>
<p>考虑以下不动点方程，其中<span class="math">\(X: \mathbb{N} \rightarrow\)</span> Prop：</p>
<div class="math">$$
X=\overbrace{(\text { fun }(P: \mathbb{N} \rightarrow \text { Prop })(n: \mathbb{N}) \mapsto n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge P m))}^{\mathrm{f}}
$$</div>

<p>该方程是具有正确格式的方程的<span class="math">\(\beta\)</span>-规约变体。</p>

<div class="math">$$
\text { Even } n \leftrightarrow n=\theta \vee(\exists m: \mathbb{N}, n=m+2 \wedge \text { Even } m)
$$</div>
<p>一个解是<span class="math">\(X:=\)</span> Even，即表征偶数自然数的谓词。回想一下，我们在6.5节中证明了逆规则。</p>
<div class="math">$$
X=(\text { fun } P \mapsto P) X
$$</div>
<p>在第6.5节中已经证明。事实证明，Even是唯一的不动点。通常情况下，最小和最大不动点可能不同。考虑方程</p>
<p>对于<span class="math">\(X: \mathbb{N} \rightarrow\)</span> Prop。最小不动点是<span class="math">\(fun \_\mapsto False\)</span>，最大不动点是fun <span class="math">\(\_\)</span> <span class="math">\(\mapsto\)</span> True。按照惯例，我们有False &lt; True，因此(fun _ <span class="math">\(\mapsto\)</span> False) &lt; (fun_ <span class="math">\(\mapsto\)</span> True)。同样地，对于任何有居民的类型<span class="math">\(\alpha\)</span>，<span class="math">\(\emptyset&lt;\varnothing\)</span> Set.univ <span class="math">\(\alpha\)</span>。</p>
<p>对于while循环的语义，<span class="math">\(X\)</span>将具有类型Set (State <span class="math">\(\times\)</span> State)的状态之间的关系，而<span class="math">\(f\)</span>将对应于要么进行一次额外的循环迭代（如果条件B为真），要么是恒等操作（如果B为假）。</p>
<p>我们应该使用哪种不动点来表示while循环的语义？虽然最大不动点也允许循环和发散的执行，但最小不动点只允许有限（但可能无界）的执行。因此我们选择最小不动点。</p>
<h3>11.4 单调函数</h3>
<p>我们之前声称，在<span class="math">\(f\)</span>满足某些条件时，最小和最大不动点是保证存在的。现在是时候更精确地说明这一点了。设<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>为任意类型，每个类型都配备了一个偏序<span class="math">\(\leq\)</span>。如果对于所有的<span class="math">\(a, b\)</span>，<span class="math">\(a \leq b \rightarrow f a \leq f b\)</span>，则函数<span class="math">\(f: \alpha \rightarrow \beta\)</span>是单调的。如果<span class="math">\(f\)</span>是单调的，则函数<span class="math">\(f: \operatorname{Set} \alpha \rightarrow \operatorname{Set} \alpha\)</span>允许存在最小和最大不动点。</p>
<div class="math">$$
f A=(\text { if } A=\emptyset \text { then Set.univ else } \emptyset)
$$</div>
<p>集合上的许多操作（例如，并集<span class="math">\(\cup\)</span>）、关系（例如，复合<span class="math">\(\bigcirc\)</span>）以及函数（例如，恒等函数 fun <span class="math">\(x \mapsto x\)</span>，常数函数 fun <span class="math">\(\_\)</span> <span class="math">\(\mapsto k\)</span>，复合<span class="math">\(\circ\)</span>）都是单调的或保持单调性。当然，并非所有函数都是单调的。以下是一个在 Set <span class="math">\(\alpha\)</span> 上的非单调函数 <span class="math">\(f\)</span> 的示例，其中 <span class="math">\(\subseteq\)</span> 作为偏序：</p>
<p>如果<span class="math">\(\alpha\)</span>是非空的，我们有<span class="math">\(\emptyset \subseteq\)</span> Set.univ 但 <span class="math">\(f \emptyset=\)</span> Set.univ <span class="math">\(\nsubseteq \emptyset=f\)</span> Set.univ。</p>
<div class="math">$$
\bigcap X=\{a \mid \forall A, A \in X \rightarrow a \in A\}
$$</div>
<h3>11.5 完全格</h3>
<p>为了定义集合（包括关系）的lfp，我们需要两个操作：子集<span class="math">\(\subseteq\)</span> : Set <span class="math">\(\alpha \rightarrow\)</span> Set <span class="math">\(\alpha \rightarrow\)</span> Prop和大交集<span class="math">\(\cap\)</span> : Set (Set <span class="math">\(\alpha\)</span> ) <span class="math">\(\rightarrow\)</span> Set <span class="math">\(\alpha\)</span>，它们可以定义为</p>
<p>如果 <span class="math">\(X\)</span> 是一个有限集 <span class="math">\(\left\{A_{1}, \ldots, A_{n}\right\}\)</span>，那么 <span class="math">\(\bigcap X=A_{1} \cap \cdots \cap A_{n}\)</span>。</p>
<p>我们可以更一般地定义lfp，使其不仅适用于集合，还适用于称为完全格的代数结构的任何实例。一个完全格由以下部分组成：</p>
<ol>
<li>一个类型<span class="math">\(\alpha\)</span>；</li>
<li>一个偏序<span class="math">\(\leq: \alpha \rightarrow \alpha \rightarrow\)</span> Prop（即一个自反、反对称和传递的二元谓词）；</li>
<li>一个运算符<span class="math">\(\Pi\)</span> : Set <span class="math">\(\alpha \rightarrow \alpha\)</span>，称为下确界。</li>
</ol>
<p><span class="math">\(\Pi\)</span> 运算符满足以下两个条件：</p>
<ol>
<li>
<span class="math">\(\Pi\)</span> A 是 <span class="math">\(A\)</span> 的下界：对于所有 <span class="math">\(b \in A\)</span>，<span class="math">\(\Pi A \leq b\)</span>；</li>
<li>
<span class="math">\(\Pi\)</span> A 是最大下界：对于所有满足 <span class="math">\(\forall a, a \in A \rightarrow b \leq a\)</span> 的 <span class="math">\(b\)</span>，<span class="math">\(b \leq \Pi\)</span> A。</li>
</ol>
<p>条件1和条件2共同确保了<span class="math">\(\Pi\)</span> A是唯一的最大下界。格算子<span class="math">\(\leq\)</span>和<span class="math">\(\square\)</span>推广了<span class="math">\(\subseteq\)</span>：集合<span class="math">\(\alpha \rightarrow\)</span> 集合<span class="math">\(\alpha \rightarrow\)</span> Prop和<span class="math">\(\square\)</span>：集合（集合<span class="math">\(\alpha\)</span>）<span class="math">\(\rightarrow\)</span> 集合<span class="math">\(\alpha\)</span>。需要注意的是，<span class="math">\(\square\)</span> A不一定在A中。例如，在<span class="math">\(\mathbb{R}\)</span>上的开区间<span class="math">\(] a, b[\)</span>的下确界为<span class="math">\(\left.a \notin\right] a, b[\)</span>。集合的下确界是最小元素概念的推广。</p>
<p>以下是一些完全格的例子：</p>
<ul>
<li>对于所有类型<span class="math">\(\alpha\)</span>，集合<span class="math">\(\alpha\)</span>关于<span class="math">\(\subseteq\)</span>和<span class="math">\(\cap\)</span>；</li>
<li>命题<span class="math">Prop</span>关于<span class="math">\(\rightarrow\)</span>和函数<span class="math">\(A \mapsto \forall a \in A, a\)</span>；</li>
<li>扩展自然数<span class="math">ENat \(:=\mathbb{N} \cup\{\infty\}\)</span>关于<span class="math">\(\leq\)</span>和适当的下确界运算符；</li>
<li>扩展实数<span class="math">EReal \(:=\mathbb{R} \cup\{-\infty, \infty\}\)</span>关于<span class="math">\(\leq\)</span>和适当的下确界运算符。</li>
</ul>
<p>如果<span class="math">\(\alpha\)</span>是一个完全格，那么<span class="math">\(\beta \rightarrow \alpha\)</span>也是一个完全格。如果<span class="math">\(\alpha\)</span>和<span class="math">\(\beta\)</span>都是完全格，那么<span class="math">\(\alpha \times \beta\)</span>也是一个完全格。在这两种情况下，<span class="math">\(\leq\)</span>和<span class="math">\(\square\)</span>都是按分量定义的。</p>
<p>以下是一些非完全格的例子：<span class="math">\(\mathbb{N}, \mathbb{Z}, \mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>关于<span class="math">\(\leq\)</span>。问题在于没有最大元素可以赋值给<span class="math">\(\Pi \emptyset\)</span>。另一个非完全格的例子是ERat <span class="math">\(:=\mathbb{Q} \cup\{-\infty, \infty\}\)</span>，因为<span class="math">\(\Pi\{q \mid 2&lt;q * q\}=\)</span> sqrt 2不在ERat中。</p>
<pre><code>class CompleteLattice ( }\alpha\mathrm{ : Type)
    extends PartialOrder }\alpha\mathrm{ : Type where
    Inf : Set }\alpha\mathrm{ \rightarrow }\alpha
    Inf_le : VA b, b \in A -&gt; Inf A \leq b
    le_Inf : VA b, ( }\forall\mathrm{ a, a \in A -&gt; b \leq a) -&gt; b \leq Inf A
</code></pre>
<p>在 Lean 中，使用类型类来表示完全格是很自然的：</p>
<pre><code>instance Set.CompleteLattice { }\alpha\mathrm{ : Type} :
    CompleteLattice (Set }\alpha\mathrm{ ) :=
    { @Set.PartialOrder }\alpha\mathrm{ with
        Inf := fun X \mapsto {a | \forallA, A \in X -&gt; a \in A}
        Inf_le := by aesop
        le_Inf := by aesop }
</code></pre>
<p>类型 Set <span class="math">\(\alpha\)</span> 是类型类的一个实例：</p>
<div class="math">$$
\lg f=\Pi\{x \mid f x \leq x\}
$$</div>
<h3>11.6 最小不动点</h3>
<p>利用完全格，我们可以定义最小不动点算子：</p>
<pre><code>def lfp { }\alpha\mathrm{ : Type} [CompleteLattice }\alpha\mathrm{ ] (f : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ ) : }\alpha\mathrm{ :=
    CompleteLattice.Inf {a | f a \leq a}
</code></pre>
<p>在Lean中：</p>
<p>克纳斯特-塔斯基定理<span class="math">\({ }^{1}\)</span>，我们在第6.1节中简要提到过，它为我们提供了任何在完全格上的单调函数<span class="math">\(f\)</span>的以下性质：</p>
<ul>
<li>lfp <span class="math">\(f\)</span> 是一个不动点：<span class="math">\(\lg f=f(\lg f)\)</span>；</li>
<li>
<span class="math">\(\lg f\)</span> 小于任何其他不动点：<span class="math">\(X=f X \rightarrow \lg f \leq X\)</span>。</li>
</ul>
<pre><code>| Stmt.whileDo B S \(\quad \Rightarrow&gt;\)
    lfp (fun \(X \mapsto\) ((denote \(S \bigcirc X) ; B\) )
        \(\cup(\) Id \(;(\) fun \(\mathrm{s} \mapsto \neg \mathrm{B} \mathrm{s} \mathrm{)))}\)
</code></pre>
<h3>11.7 关系指称语义学，续</h3>
<p>通过lfp，我们可以兑现承诺，完成WHILE程序的指称语义定义：</p>
<pre><code>theorem denote_Iff_BigStep (S : Stmt) (s t : State) :
    \((s, t) \in \llbracket S \rrbracket \leftrightarrow(s, s) \Longrightarrow t\)
</code></pre>
<p>为了验证我们的定义，我们可以证明指称语义与大步语义之间的以下联系：</p>
<p>对于证明，我们参考《Concrete Semantics: With Isabelle/HOL》的第11章或本章附带的演示文件。</p>
<pre><code>def DenoteEquiv \(\left(\mathrm{S}_{1} \mathrm{~S}_{2}: \mathrm{Stmt}\right)\) : Prop :=
    \(\llbracket \mathrm{S}_{1} \rrbracket=\llbracket \mathrm{S}_{2} \rrbracket\)
</code></pre>
<h3>11.8 程序等价性的应用</h3>
<p>基于指称语义，我们引入程序等价性的概念。如果两个程序具有相同的语义，则它们是等价的：</p>
<p>我们使用<span class="math">\(S_{1} \sim S_{2}\)</span>作为DenoteEquiv <span class="math">\(S_{1} S_{2}\)</span>的缩写。很容易看出这是一个等价关系。</p>
<pre><code>theorem DenoteEquiv.seq_congr \(\left\{S_{1} S_{2} T_{1} T_{2}: \mathrm{Stmt}\right\}\)
    \(\left(h S: S_{1} \sim S_{2}\right)\left(h T: T_{1} \sim T_{2}\right):\)
    \(\mathrm{S}_{1} ; \mathrm{T}_{1} \sim \mathrm{~S}_{2} ; \mathrm{T}_{2}:=\)
    by

    simp [DenoteEquiv, denote] at *
    simp [*]
theorem DenoteEquiv.if_congr {B} {S
    (hS : S
    Stmt.ifThenElse B S, T
    simp [DenoteEquiv, denote] at *
    simp [*]
theorem DenoteEquiv.while_congr {B} {S, S
    (hS : S
    simp [DenoteEquiv, denote] at *
    simp [*]
</code></pre>
<p>程序等价性可用于在较大程序中替换子程序，前提是它们具有相同的语义。这是通过以下同余规则实现的：</p>
<p>同余规则是一个定理，它将某种等价关系提升到某个上下文（在这里，是顺序组合、if-then-else和while）上。</p>
<p>注意指称语义如何通过重写实现简短的证明。这并不令人惊讶，因为它被设计为等式化和组合式的。如果我们使用大步语义作为程序等价的基础，这些证明将会复杂得多。</p>
<pre><code>theorem DenoteEquiv.skip_assign_id {x} :
    Stmt.assign x (fun s }-&gt;\mathrm{ s x) Stmt.skip :=
    by simp [DenoteEquiv, denote, Id]
theorem DenoteEquiv.seq_skip_left {S} :
    Stmt.skip; S S :=
    by simp [DenoteEquiv, denote, Id, comp]
theorem DenoteEquiv.seq_skip_right {S} :
    S; Stmt.skip S :=
    by simp [DenoteEquiv, denote, Id, comp]
</code></pre>
<p>我们现在可以通过等式推理来证明简单程序的等价性：</p>
<pre><code>theorem DenoteEquiv.if_seq_while {B S} :
    Stmt.ifThenElse B (S; Stmt.whileDo B S) Stmt.skip
    Stmt.whileDo B S :=
    by
    simp [DenoteEquiv, denote]
    apply Eq.symm
    apply lfp_eq
    apply Monotone_while_lfp_arg
</code></pre>
<p>我们使用lfp操作符定义了while的语义，但谁能保证单调性——它确保了最小不动点的存在——是否满足？为了消除这些疑虑，我们证明了以下定理：</p>
<pre><code>theorem Monotone_while_lfp_arg (S B) :
    Monotone (fun X \longleftarrow [S] \bigcirc X ; B \cup I d ; (fun s \longleftarrow \neg B s)) :=
    by
        apply Monotone_union
        { apply SorryTheorems.Monotone_restrict
            apply SorryTheorems.Monotone_comp
            { exact Monotone_const _ }
            { exact Monotone_id } }
    { apply SorryTheorems.Monotone_restrict
        exact Monotone_const _ }
</code></pre>
<p>该定理为我们提供了一种便捷的方式来扩展或收缩循环的一次迭代。第二个应用调用了定理 lfp_eq：lfp f = f (lfp f)，表明 lfp 是一个不动点。最后一步应用了一个定理来说服 Lean，lfp 的参数是单调的。该定理的证明相当单调：</p>
<h3>11.9 基于归纳谓词的更简单方法</h3>
<p>Lean的归纳谓词对应于最小不动点，但它们已内置于Lean的逻辑中（归纳构造的演算），而不需要使用像lfp这样的不动点运算符。本节的大部分内容都致力于构造一个lfp运算符。我们是否可以使用归纳谓词来代替，从而省去这部分工作？</p>
<pre><code>inductive Awhile (B : State \(\rightarrow\) Prop)
    (r : Set (State \(\times\) State)) :
    State \(\rightarrow\) State \(\rightarrow\) Prop
    | true \(\{s \mathrm{t} u\) \} (hcond : B s) (hbody : (s, t) \(\in r\) )
        (hrest : Awhile B r t u) :
        Awhile B r s u
    | false \(\{s\}\) (hcond : \(\neg\) B s) :
        Awhile B r s s
</code></pre>
<p>答案是肯定的。首先，回想一下，类型 Set (State <span class="math">\(\times\)</span> State) 和 State <span class="math">\(\rightarrow\)</span> State <span class="math">\(\rightarrow\)</span> Prop 在 Lean 中等效地表示二元关系。因此，我们可以构建以下 Awhile 谓词，它类似于自反传递闭包，但在给定条件 B 变为假时停止：</p>
<pre><code>def denoteAwhile : Stmt -&gt; Set (State \times State)
    \vdots
    | Stmt.whileDo B S =&gt;
    {st | Awhile B (denoteAwhile S) (Prod.fst st)
        (Prod.snd st)}
</code></pre>
<p>有了这个操作符，定义语义的定义就变为</p>
<p>Awhile谓词的引入规则与大步操作语义中的while规则非常相似。在它们不同的表象背后，操作语义和指称语义毕竟并没有那么不同。</p>
<h1>第四部分：数学</h1>
<h2>第12章：数学的逻辑基础</h2>
<p>在本章中，我们将深入探讨Lean的逻辑基础。这里描述的大多数特性对于定义数学对象并证明相关定理尤为重要。如需更多细节，我们建议参考Carneiro的硕士论文。</p>
<div class="math">$$
\text { @And.intro : } \forall \mathrm{a} b, \mathrm{a} \rightarrow \mathrm{~b} \rightarrow \mathrm{a} \wedge \mathrm{~b}
$$</div>
<h3>12.1 宇宙</h3>
<p>在依赖类型理论中，不仅所有项都有类型，而且所有类型本身也有类型。我们已经看到了一些这种情况的发生。PAT 原则告诉我们，将证明视为项，将命题视为类型。例如，定理</p>
<div class="math">$$
\forall a b, a \rightarrow b \rightarrow a \wedge b: \text { Prop }
$$</div>

<p>实际上是一个类型为<span class="math">\(\forall \mathrm{a} b, \mathrm{a} \rightarrow \mathrm{b} \rightarrow \mathrm{a} \wedge \mathrm{b}\)</span>的术语@And.intro，而该类型本身也有一个类型：</p>

<div class="math">$$
\text { Prop : Type }
$$</div>
<p>那么Prop的类型是什么呢？Prop与我们迄今为止构建的几乎所有其他类型具有相同的类型：</p>
<pre><code>Type : Type 1
Type 1 : Type 2
Type 2 : Type 3
</code></pre>
<p>Type的类型是什么？最简单的解决方案是让Type : Type，但这种选择会导致Girard悖论，即类型理论中的Russell悖论。为了避免不一致性，我们需要一个全新的、更大的类型来包含Type，我们称之为Type 1。Type 1本身的类型是Type 2，以此类推：</p>
<div class="math">$$
\text { C } \vdash \text { Sort } u: \text { Sort }(u+1)
$$</div>
<p>实际上，不带参数的 Type 是 Type o 的缩写。如果我们想将 Prop 纳入这个层次结构中，可以使用语法 Sort u，其中 Sort o 是 Prop 的别名，而 Sort ( <span class="math">\(u+1\)</span> ) 是 Type u 的别名。这一层次结构由以下类型判断捕获：</p>
<p>所有这些包含其他类型的类型被称为宇宙，而表达式Sort <span class="math">\(u\)</span>中的<span class="math">\(u\)</span>是一个宇宙层级。尽管宇宙层级看起来像类型为<span class="math">\(\mathbb{N}\)</span>的项，但实际上它们甚至不是项。</p>
<p>与其到处使用 Type，你可以通过书写 Type <span class="math">\(\_\)</span> 来使你的定理稍微更通用，而不必考虑宇宙层级。然后 Lean 会创建一个新的宇宙变量。这有助于维持我们在一个方便的、Type : Type 成立的逻辑中工作的假象，但不会引入任何悖论。实际上，Type <span class="math">\(\omega\)</span> 对于大多数计算机科学和数学来说已经足够大了。</p>
<h3>12.2 Prop的特殊性</h3>
<p>尽管Prop似乎很好地融入了宇宙层级结构，但它在多个方面与其他宇宙有所不同。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { C } \vdash \sigma: \text { Type } u \quad C, x: \sigma \vdash \tau[x]: \text { Type } v \\
&amp; C \vdash(x: \sigma) \rightarrow \tau[x]: \text { Type }(\max u v)
\end{aligned}
$$</div>
<h3>12.2.1 非直谓性</h3>
<p>当从其他类型构造一个新类型时（例如，从<span class="math">\(\alpha\)</span> : Type <span class="math">\(u\)</span> 和 <span class="math">\(\beta\)</span> : Type v 构造 <span class="math">\(\alpha \rightarrow \beta\)</span>），新构造的类型比其每个组件都更复杂，自然应将其放入所涉及的最大宇宙中（例如，<span class="math">\(\alpha \rightarrow\)</span> <span class="math">\(\beta\)</span> : Type (max u v)）。这正是 Lean 所做的。以下类型规则一般地表达了依赖类型的这一思想：</p>
<p>Type宇宙的这种行为被称为谓词性。一般来说，谓词性意味着一个对象不能通过量化该对象本身来定义。</p>
<div class="math">$$
(\mathrm{a}: \text { Type } \mathrm{u}) \rightarrow \mathrm{a} \rightarrow \mathrm{a}: \text { Type }(\mathrm{u}+1)
$$</div>
<p>然而，让Prop表现出不同的行为是方便的。我们希望表达式<span class="math">\(\forall \mathrm{a}: \operatorname{Prop}, \mathrm{a} \rightarrow \mathrm{a}\)</span>的类型为Prop——毕竟，它是一个命题。展开<span class="math">\(\forall\)</span>的语法糖，这个表达式等同于(a : Prop) <span class="math">\(\rightarrow\)</span> a <span class="math">\(\rightarrow\)</span> a。如果我们用Type <span class="math">\(u\)</span>代替Prop，上述类型规则将得出</p>
<div class="math">$$
\frac{\mathrm{C} \vdash \sigma: \text { Sort u } \quad \mathrm{C}, \mathrm{x}: \sigma \vdash \tau[\mathrm{x}]: \text { Prop }}{\mathrm{C} \vdash(\forall \mathrm{x}: \sigma, \tau[\mathrm{x}]): \text { Prop }} \text { ARROW-PROP }
$$</div>
<p>由于 Type <span class="math">\(u\)</span> : Type <span class="math">\((u+1)\)</span> 且 <span class="math">\(\max (u+1)(\max u u)=u+1\)</span>。因此，在类型化此表达式时，宇宙层级增加了一级。为了强制诸如 <span class="math">\(\forall a\)</span> : Prop, <span class="math">\(a \rightarrow a\)</span> 的表达式仍然具有类型 Prop，我们需要一个特殊的类型化规则来处理具有 Prop 主体的 <span class="math">\(\forall\)</span> 表达式：</p>
<div class="math">$$
\forall \mathrm{a}: \text { Prop, } \mathrm{a} \rightarrow \mathrm{a}: \text { Prop }
$$</div>
<p>该规则产生</p>
<div class="math">$$
\begin{aligned}
&amp; \text { C } \vdash \sigma: \text { Sort } u \quad C, x: \sigma \vdash \tau[x]: \text { Sort } v \\
&amp; C \vdash(x: \sigma) \rightarrow \tau[x]: \text { Sort }(i m a x u v)
\end{aligned}
$$</div>
<p>如预期所示。上述两条类型规则可以总结为单一规则</p>
<p>其中 imax <span class="math">\(u \theta=\theta\)</span> 且 imax <span class="math">\(u(v+1)=\max u(v+1)\)</span>。这种行为称为 Prop 的非直谓性。一般而言，非直谓性意味着一个对象可以通过一个量化其自身的量词来定义。</p>
<pre><code>theorem proof_irrel {a : Prop} (h
    h
    by rfl
</code></pre>
<h4>12.2.2 证明无关性</h4>
<p>Prop 和 Type 之间的第二个区别是证明无关性。这意味着同一命题 a 的任意两个证明是相等的：</p>
<p>在 Lean 中，这种等式是计算上的语法等式，允许我们使用 rfl 策略。当将命题视为类型并将证明视为该类型的元素时，证明无关性意味着命题要么是空类型，要么恰好有一个居民。如果命题是空类型，则它是假的。如果命题恰好有一个居民，则它是真的。证明无关性在推理依赖类型时非常有用，我们将在本章后面看到这一点。</p>
<p>在6.3节中，我们看到了一个并排展示Bool和Prop解释的图表。该图表未考虑证明无关性，并显示了同一命题的多个证明。我们现在知道这是不准确的。以下是修订后的图表：</p>
<p><img src="img-9.jpeg" alt="img-9.jpeg"></p>
<p>如果我们在心理上将Bool的两个元素（false和true）与Prop的两个类型（False和True）联系起来，我们会发现Prop几乎与Bool相同，只是根据PAT原则，Prop类型的命题可以存储证明。下表总结了这种情况：</p>
<p>False : Prop
True.intro : True : Prop
false : Bool : Type
true : Bool : Type
为了使证明无关性生效，Lean必须放弃归纳谓词的“无混淆”属性。事实上，同一个命题的各种证明确实应该被“混淆”。这仅涉及归纳谓词（例如，Even），而不涉及一般的归纳类型（例如，List <span class="math">\(\alpha\)</span>）。</p>
<p>其他系统和逻辑学做出了不同的选择。例如，Coq默认是证明相关的，但与证明无关性兼容。同伦类型理论和其他构造性或直觉主义类型理论建立在等式证明的数据基础上，因此与证明无关性不兼容。</p>
<h4>12.2.3 无大消除</h4>
<p>Prop 和 Type 之间的另一个区别是 Prop 不允许大消除：通常不可能从命题的证明中提取信息并在程序（即属于 Type 的类型的值）中使用它。毕竟，由于证明无关性，给定命题的所有证明都是相等的，因此它们不能携带能够区分它们的特定信息。</p>
<pre><code>-- fails
def unsquare (i : Z) (hsq : ヨj, i = j * j) : Z :=
    match hsq with
    | Exists.intro j _ =&gt; j
</code></pre>
<p>想象一下我们可以从程序内部的证明中提取信息。例如，我们可以在函数定义中使用match构造，如下所示：</p>
<pre><code>tactic 'induction' failed, recursor 'Exists.casesOn' can
only eliminate into Prop
</code></pre>

<p>unsquare 函数接收一个平方数 <span class="math">\(i\)</span> 和一个证明 hsq，证明 <span class="math">\(i\)</span> 实际上是一个平方数，并返回平方前的数字 <span class="math">\(j\)</span>，该数字是从证明中提取的。Lean 会抛出错误</p>

<pre><code>hsq \(_{1}:=\) Exists.intro 3 (by linarith)
hsq \(_{2}:=\) Exists.intro (-3) (by linarith)
</code></pre>
<p>如果它接受了这个定义，我们可以如下推导出False。设</p>
<p>成为<span class="math">\(\exists j,(9: \mathbb{Z})=j * j\)</span>的两个证明。注意到它们对<span class="math">\(j\)</span>使用了不同的见证（3 与 -3）。然后我们有 unsquare <span class="math">\(9 \mathrm{hsq}_{1}=3\)</span> 和 unsquare <span class="math">\(9 \mathrm{hsq}_{2}=-3\)</span>。然而，根据证明无关性，<span class="math">\(h s q_{1}=h s q_{2}\)</span>。因此，unsquare <span class="math">\(9 \mathrm{hsq}_{2}\)</span> 等于 3。但我们已经确定它等于 -3。这意味着<span class="math">\(3=-3\)</span>，即一个矛盾。</p>
<p>缺乏大范围消除的一个不幸后果是我们无法通过模式匹配和递归进行规则归纳（第4.8节）。这种归纳依赖于一个“度量”——一个到<span class="math">\(\mathbb{N}\)</span>的函数，它为参数分配一个大小。没有大范围消除，度量就无法有意义地定义。这解释了为什么我们总是使用归纳策略进行规则归纳。</p>
<p>作为一种折衷方案，Lean 允许小规模消除，即仅消除到 Prop 中——而大规模消除可以消除到任意大的宇宙 Type u 中。这意味着我们可以使用 match 来分析证明的结构，提取存在性见证等等，只要 match 表达式本身位于证明中。我们已经在 5.7 和 6.5 节中看到了这样的例子。</p>
<p>作为进一步的妥协，Lean允许对语法单例进行大消除：即在Prop中最多以一种方式证明的类型。例如，False没有证明，而所有<span class="math">\(\wedge\)</span> b的证明都具有And.intro _ _的形式（递归地，可能有多种方式证明a和b）。更准确地说，语法单例是一个最多有一个构造函数的归纳定义，其参数要么是Prop，要么作为结果类型中的直接参数出现。当我们将<span class="math">\(h: a \wedge b\)</span>与And.intro ha hb进行匹配时，不会泄露有关<span class="math">\(h\)</span>的任何信息。</p>
<pre><code>inductive Nonempty ( }\alpha\mathrm{ : Sort u) : Prop
    | intro (val : }\alpha\mathrm{ ) : Nonempty }\alpha
</code></pre>
<h3>12.3 选择公理</h3>
<p>Lean的逻辑包括选择公理，这使得从任何非空类型中获取任意元素成为可能。考虑以下预定义的谓词：</p>
<pre><code>theorem Nat.Nonempty :
    Nonempty N :=
    Nonempty.intro 0
</code></pre>
<p>该谓词声明了<span class="math">\(\alpha\)</span>至少有一个元素。要证明Nonempty <span class="math">\(\alpha\)</span>，我们必须提供一个<span class="math">\(\alpha\)</span>值给Nonempty.intro：</p>
<p>由于Nonempty存在于Prop中，无法进行大规模消除，因此我们无法提取在证明Nonempty <span class="math">\(\alpha\)</span>时使用的元素。</p>
<div class="math">$$
\text { Classical. choice }\{\alpha: \text { Sort u }\}: \text { Nonempty } \alpha \rightarrow \alpha
$$</div>
<p>在Lean中，选择公理的形式是一个函数，该函数在给定Nonempty <span class="math">\(\alpha\)</span>的证明时返回一个任意的<span class="math">\(\alpha\)</span>值：</p>
<p>我们无法知道返回的元素是否与用于证明非空<span class="math">\(\alpha\)</span>的元素相同。它只是<span class="math">\(\alpha\)</span>中的一个任意元素。</p>
<p>常量 Classical.choice 是不可计算的。如果我们使用 #reduce 或 #eval 向 Lean 询问其值，它将拒绝计算。换句话说，证明可能是项，但它们不一定是程序。这是一些逻辑学家倾向于在没有选择公理的情况下工作的原因之一。相比之下，绝大多数数学家对选择公理没有任何异议。</p>
<p>与证明无关性及大、小消除不同，选择公理并未内置于Lean内核中；它只是核心库中的一个公理，我们可以自由选择不使用它。如果定义中使用了Classical.choice来定义Type中的常量，Lean要求我们用noncomputable关键字标记这些定义。</p>
<p>以下工具依赖于Classical.choice：</p>
<ul><li>函数Classical.choose，称为希尔伯特选择算子，帮助我们找到一个见证者<span class="math">\(\exists a: \alpha, p\)</span>，如果我们不关心具体是哪一个。它的伴随函数Classical.choose_spec提供了一个证明，证明该见证者确实是一个见证者。</li></ul>
<div class="math">$$
\begin{aligned}
&amp; \text { Classical.choose : }(\exists \mathrm{a}: \alpha, \mathrm{pa}) \rightarrow \alpha \\
&amp; \text { Classical.choose_spec: } \forall \mathrm{h}:(\exists \mathrm{a}: \alpha, \mathrm{pa}), \mathrm{p}(\text { Classical.choose } \mathrm{h})
\end{aligned}
$$</div>
<p>直观上，选择算子告诉我们：“让我相信存在一个满足<span class="math">\(p\)</span>的元素，我就会给你这样的一个元素。”</p>
<ul><li>我们还可以推导出传统的选择公理：</li></ul>
<div class="math">$$
\begin{aligned}
&amp; \text { Classical.axiomOfChoice }(\alpha \beta: \text { Type })\{\mathrm{R}: \alpha \rightarrow \beta \rightarrow \text { Prop }\}: \\
&amp; (\forall \mathrm{x}: \alpha, \exists \mathrm{y}: \beta, \mathrm{R} \times \mathrm{y}) \rightarrow(\exists \mathrm{f}: \alpha \rightarrow \beta, \forall \mathrm{x}: \alpha, \mathrm{R} \times(\mathrm{f} \times)) \\
&amp; \text { - From the axiom of choice and propositional and functional extensionality } \\
&amp; \text { (propext, funext), we can derive the law of excluded middle: }
\end{aligned}
$$</div>
<p>根据排中律，每个命题都是可判定的。这意味着我们可以基于某个命题是否为真的情况区分来构造证明。</p>
<h3>12.4 子类型</h3>
<p>归纳类型在适用时是一种非常方便的定义机制，但许多数学构造并不符合这种模式。Lean提供了两种替代方案来满足这些需求：子类型和商类型。</p>
<p>子类型是一种从现有类型创建新类型的机制。给定一个关于基础类型元素的谓词，子类型仅包含那些满足该谓词的基础类型元素。更准确地说，子类型包含元素-证明对，这些对结合了基础类型的一个元素以及该元素满足谓词的证明。</p>
<p>下图展示了一个通过保留基类型的五个元素中的两个而创建的子类型：</p>
<p><img src="img-10.jpeg" alt="img-10.jpeg"></p>
<pre><code>inductive Finset ( \(\alpha\) : Type) : Type
    | empty : Finset \(\alpha\)
    | insert : \(\alpha \rightarrow\) Finset \(\alpha \rightarrow\) Finset \(\alpha\)
</code></pre>
<p>子类型对于那些无法定义为归纳类型的类型非常有用。例如，任何尝试按照以下方式定义有限集类型的做法</p>
<pre><code>Finset.insert 1 (Finset.insert 2 Finset.empty)
Finset.insert 2 (Finset.insert 1 Finset.empty)
Finset.insert 1 (Finset.insert 1 (Finset.insert 2 Finset.empty))
</code></pre>
<p>这是注定失败的，因为给定的集合可能有多种表示方式。例如，<span class="math">\(\{1,2\}\)</span>可以用以下任意一种方式表示，甚至更多：</p>
<div class="math">$$
\{\text { variable : base-type // property-applied-to-variable }\}
$$</div>

<p>相反，我们可以将有限集定义为（可能是无限的）集合中那些有限的子类型。通常，子类型的语法为</p>

<p>我们在第4.6节中看到了一个例子，即<span class="math">\(\{\mathrm{i}: \mathbb{N} / / \mathrm{i} \leq n\}\)</span>，它由满足<span class="math">\(i \leq n\)</span>的自然数i组成，其中<span class="math">\(n\)</span>在上下文中是固定的。基类型是<span class="math">\(\mathbb{N}\)</span>，属性是函数<span class="math">\(i \mapsto i \leq n\)</span>。对于同一类型，一个不那么直观但可能不那么令人困惑的语法是@Subtype <span class="math">\(\mathbb{N}\)</span> (fun <span class="math">\(i \mapsto i \leq n\)</span> )。我们的动机示例，即某个类型<span class="math">\(\alpha\)</span>上的有限集合类型，被指定为<span class="math">\(\{\mathrm{A}:\)</span> Set <span class="math">\(\alpha / /\)</span> Set. Finite A}，其中Set. Finite为真当且仅当其参数是有限的。</p>
<pre><code>def FullTree ( }\alpha\mathrm{ : Type) : Type :=
    {t : Tree }\alpha\mathrm{ // IsFull t}
</code></pre>
<h4>12.4.1 第一个示例：满二叉树</h4>
<p>为了说明子类型，我们将基于第5.8节中的Tree类型定义一个满二叉树的类型。在第6.6.3节中，我们引入了一个谓词IsFull，如果树的每个节点有零个或两个子节点，则该谓词为真。基于此类型和此谓词，我们可以构造一个子类型FullTree，仅包含满二叉树，如下所示：</p>
<pre><code>def FullTree ( }\alpha\mathrm{ : Type) : Type :=
    @Subtype (Tree }\alpha\mathrm{ ) IsFull
</code></pre>
<p>这是以下内容的语法糖：</p>
<pre><code>inductive Subtype { }\alpha\mathrm{ : Type} (p : }\alpha\mathrm{ \rightarrow Prop) : Type
    | mk : (x : }\alpha\mathrm{ ) \rightarrow p x \rightarrow Subtype p
</code></pre>
<p>其中子类型定义如下：</p>
<pre><code>def nilFullTree : FullTree N :=
    Subtype.mk Tree.nil IsFull.nil
def fullTree6 : FullTree N :=
    Subtype.mk (Tree.node 6 Tree.nil Tree.nil)
    (by
        apply IsFull.node
        apply IsFull.nil
        apply IsFull.nil
        rfl)
</code></pre>
<p>FullTree的元素本质上是依赖类型的对，其中第一个组件是一棵树<span class="math">\(t\)</span>，第二个组件是证明<span class="math">\(t\)</span>是满的。例如，以下是一个空的满二叉树和一个由标记为6的单个内部节点组成的满二叉树的定义：</p>
<pre><code>\#reduce Subtype.val fullTree6
\#check Subtype.property fullTree6
</code></pre>
<p>给定一个类型为FullTree的值，我们可以通过Subtype.val和Subtype.property来检索它的两个组件。</p>
<p>子类型最具吸引力的方面在于，我们可以将操作从基类型提升到子类型，而不必从头开始构建库，只要这些操作保留了子类型属性。我们只需要在基类型的常量周围定义“包装器”。通常，在基类型的操作<span class="math">\(f\)</span>周围定义这样的包装器涉及三个步骤：</p>
<ol>
<li>从包装器参数中提取基类型的值；</li>
<li>在那些基类型值上调用<span class="math">\(f\)</span>；</li>
<li>使用Subtype.mk封装结果，并附带一个证明，表明生成的基类型值满足子类型属性。使用此过程，如果Tree函数保留了IsFull属性，我们可以将它们提升为FullTree函数。例如，要将镜像操作从类型Tree <span class="math">\(\rightarrow\)</span> Tree提升到类型FullTree <span class="math">\(\rightarrow\)</span> FullTree，我们必须1. 从包装器参数中提取Tree；</li>
<li>在该Tree上调用镜像；</li>
<li>使用Subtype.mk封装结果，并附带一个证明，表明生成的Tree满足IsFull。对于步骤3，我们必须从参数中提取IsFull的证明，并使用第6.6.3节中的定理IsFull_mirror。将所有内容组合在一起，我们得到</li>
</ol>
<pre><code>def FullTree.mirror { }\alpha\mathrm{ : Type} (t : FullTree }\alpha\mathrm{ ) :
    FullTree }\alpha\mathrm{ :=
    Subtype.mk (LoVe.mirror (Subtype.val t))
    (by
        apply IsFull_mirror
        apply Subtype.property t)
</code></pre>
<p>输入是子类型FullTree的一个元素<span class="math">\(t\)</span>。我们将<span class="math">\(t\)</span>分解为Subtype.val t : Tree和Subtype.property t : IsFull t。我们使用之前的mirror函数来反转<span class="math">\(t\)</span>的树组件，并使用定理IsFull_mirror以及<span class="math">\(t\)</span>的属性组件来证明条件IsFull (mirror (Subtype.val t))。</p>
<p>最后，我们使用Subtype.mk构建一个包含结果树和证明该树为满树的配对。Subtype.mk构造函数既可以看作是一个类似配对的构造函数，也可以看作是从Tree到FullTree的转换，其第二个参数保证了转换的安全性。</p>
<pre><code>Subtype.eq : Subtype.val ?a = Subtype.val ?b -&gt; ?a = ?b
</code></pre>
<p>关于子类型的证明，以下定理非常有用：</p>
<pre><code>theorem FullTree.mirror_mirror { }\alpha\mathrm{ : Type}
    (t : FullTree }\alpha\mathrm{ ) :
    (FullTree.mirror (FullTree.mirror t)) = t :=
    by
    apply Subtype.eq
    simp [FullTree.mirror, LoVe.mirror_mirror]
</code></pre>
<p>该定理指出，如果两个子类型值的Subtype.val组件相等，则它们相等。在Lean中，证明无关性至关重要，因为我们不希望子类型中存在仅在证明上不同的虚假重复值。以下是Subtype.eq如何用于证明FullTree的镜像的镜像就是FullTree本身：</p>
<div class="math">$$
\text { mirror (mirror (Subtype.val t)) = Subtype.val t }
$$</div>
<p>应用定理Subtype.eq并展开full_Tree.mirror的定义后，得到子目标</p>
<p>这与第5.8节中的定理mirror_mirror的陈述相符。</p>
<pre><code>def Vector ( }\alpha\mathrm{ : Type) (n : N) : Type :=
    {xs : List }\alpha\mathrm{ // List.length xs = n}
</code></pre>
<h4>12.4.2 第二个示例：向量</h4>
<p>作为第二个示例，考虑以下向量的定义：</p>
<p>向量被定义为一个给定长度的列表。对于列表来说，所有长度的列表只有一种类型。而对于向量，我们为每种长度的向量都定义了一个专门的类型。这种方案的优势在于，诸如向量加法和标量积等操作需要参与的两个向量具有相同的长度。我们在第5.10节中看到了一个不太实用的向量定义。</p>
<pre><code>def vector123 : Vector \mathbb{Z} 3 :=
    Subtype.mk [1, 2, 3] (by rfl)
</code></pre>
<p>向量可以通过使用Subtype.mk从列表构建。</p>
<pre><code>def Vector.neg {n : N} (v : Vector \mathbb{Z} n) : Vector \mathbb{Z n :=
    Subtype.mk (List.map Int.neg (Subtype.val v))
    (by
        rw [List.length_map]
        exact Subtype.property v)
</code></pre>
<p>向量的基本操作可以通过使用Subtype.val和Subtype.property分解向量，操作底层列表，然后使用Subtype.mk重新组合它们来定义。例如，我们可以如下定义整数向量的分量取反操作：</p>
<p>我们使用函数 List.map 来对底层列表的每个元素取反，并使用定理 List.length_map 来证明这不会改变列表的长度。</p>
<pre><code>theorem Vector.neg_neg (n : N) (v : Vector \mathbb{Z} n) :
    Vector.neg (Vector.neg v) = v :=
    by
        apply Subtype.eq
        simp [Vector.neg]
</code></pre>
<p>使用Subtype.eq，我们可以证明以下关于Vector.neg的定理：</p>
<p>应用Subtype.eq将目标简化为展示底层列表上的相应属性。然后我们可以使用simp来完成证明。</p>
<h3>12.5 商类型</h3>
<p>商是数学中一种强大的构造，用于定义<span class="math">\(\mathbb{Z}, \mathbb{R}\)</span>以及许多其他集合。Lean支持商类型，这是类型上的对应概念。与子类型化类似，商类型从现有类型中构造出一个新类型。但与子类型不同，商类型包含基类型的所有元素，只不过在基类型中不同的某些元素在商类型中可能被视为相等。用数学术语来说，商类型与基类型的一个划分是同构的。下图展示了一个由三分区构建的商类型：</p>
<p><img src="img-11.jpeg" alt="img-11.jpeg"></p>
<p>基类型</p>

<p><img src="img-12.jpeg" alt="img-12.jpeg"></p>


<p>子类型</p>

<p><img src="img-13.jpeg" alt="img-13.jpeg"></p>
<p>商类型</p>
<p>所描述的商类型只有三个元素，用灰色椭圆表示。每个元素对应于一个或多个基本类型的元素。</p>
<pre><code>instance \tau.Setoid : Setoid \(\tau:=\)
    \(\{\mathrm{r} \quad:=R\)
        iseqv : \(=\)
            \{ refl := ...
            symm \(:=\)...
            trans \(:=\ldots\}\)
</code></pre>
<p>构造商类型的先决条件是一个基类型<span class="math">\(\tau\)</span>和一个等价关系<span class="math">\(R: \tau \rightarrow \tau \rightarrow\)</span> Prop，该关系指定了基类型中哪些元素在商类型中被视为相等。为了构造商类型，我们首先需要证明<span class="math">\(R\)</span>是<span class="math">\(\tau\)</span>上的等价关系。配备等价关系的类型<span class="math">\(\tau\)</span>称为集合体。在Lean中，Setoid是一个类型类。我们可以使用以下命令声明一个实例</p>
<p>其中省略号代表相应属性的缺失证明。此外，此实例声明引入了表示<span class="math">\(R\)</span> a b的符号<span class="math">\(a \approx b\)</span>。更重要的是，我们现在可以使用商类型Quotient <span class="math">\(\tau\)</span>.Setoid。</p>
<div class="math">$$
\text { Quotient.mk }\{\alpha: \text { Type }\} \rightarrow(\mathrm{s}: \text { Setoid } \alpha) \rightarrow \alpha \rightarrow \text { Quotient } \mathrm{s}
$$</div>
<p>每个元素 a : <span class="math">\(\tau\)</span> 都属于 Quotient <span class="math">\(\tau\)</span>.Setoid 中的某个元素，由 Quotient.mk <span class="math">\(\tau\)</span>.Setoid a 给出，其中</p>
<p>表达式 Quotient.mk <span class="math">\(\tau\)</span>.Setoid a 相当冗长。幸运的是，Lean 允许我们将其缩写为 <span class="math">\(\llbracket a \rrbracket\)</span>。</p>
<div class="math">$$
\text { Quotient. sound }\{\mathrm{a} b: \tau\}: \mathrm{a} \approx \mathrm{~b} \rightarrow \llbracket \mathrm{a} \rrbracket=\llbracket \mathrm{b} \rrbracket
$$</div>
<p>以下公理保证了对于满足<span class="math">\(R\)</span>的元素对，在商类型中确实是相等的：</p>
<div class="math">$$
\text { Quotient. exact }\{\mathrm{a} b: \tau\}: \llbracket \mathrm{a} \rrbracket=\llbracket \mathrm{b} \rrbracket \rightarrow \mathrm{a} \approx \mathrm{~b}
$$</div>
<p>一个定理陈述了其逆命题：</p>
<div class="math">$$
\text { Quotient.lift } f h \llbracket a \rrbracket=f a
$$</div>
<p>最后，我们可以将类型为<span class="math">\(\tau \rightarrow v\)</span>的函数提升到Quotient <span class="math">\(\tau\)</span>.Setoid <span class="math">\(\rightarrow v\)</span>，使用Quotient.lift，它在计算上满足以下语法等式。给定某个<span class="math">\(f: \tau \rightarrow v\)</span>，使得<span class="math">\(h: \forall a b, a \approx\)</span> <span class="math">\(b \rightarrow f a=f b\)</span>，我们有</p>
<p>对于所有 a : <span class="math">\(\tau\)</span>。参数 <span class="math">\(h\)</span> 是证明 <span class="math">\(f\)</span> 与 <span class="math">\(\approx\)</span> 兼容的；换句话说，它不会区分 <span class="math">\(\approx\)</span>-等价的参数。</p>
<h4>12.5.1 第一个示例：整数</h4>
<p>作为商类型的第一个示例，我们将构造整数。一种方便的方法是在自然数对上构造商。其思想是，自然数对<span class="math">\((p, n)\)</span>表示整数<span class="math">\(p-n\)</span>。通过这种方式，我们可以用<span class="math">\((p, \theta)\)</span>表示所有非负整数<span class="math">\(p\)</span>，并用<span class="math">\((\theta, n)\)</span>表示所有负整数-<span class="math">\(n\)</span>。我们还得到了许多相同整数的表示；例如，<span class="math">\((7, \theta),(8,1),(9,2)\)</span>和<span class="math">\((10,3)\)</span>都表示整数7。</p>
<p>首先，我们需要注册我们想要使用的等价关系。我们希望当<span class="math">\(p_{1}-n_{1}\)</span>和<span class="math">\(p_{2}-n_{2}\)</span>得到相同的整数时，两个对<span class="math">\(\left(p_{1}, n_{1}\right)\)</span>和<span class="math">\(\left(p_{2}, n_{2}\right)\)</span>相等。然而，条件<span class="math">\(p_{1}-n_{1}=p_{2}-n_{2}\)</span>不起作用，因为<span class="math">\(\mathbb{N}\)</span>上的减法行为不佳（例如，<span class="math">\(\varphi-1=\theta\)</span>）。相反，我们使用条件<span class="math">\(p_{1}+n_{2}=p_{2}+n_{1}\)</span>，它依赖于加法。</p>
<pre><code>instance Int.Setoid : Setoid ( }\mp@subsup{\mathbb{N}}{\times}{
    {r :=
        fun pn
            Prod.fst pn
                Prod.fst pn
            1
        1
    1
    1
    }
}
    intro pn
        rfl
        symm :=
            by
                intro pn
                rw [h]
            trans :=
            by
                intro pn
                linarith } }
</code></pre>
<p>我们提供了等价关系的定义，随后证明了它是自反的、对称的和传递的：</p>
<pre><code>theorem Int.Setoid_Iff (pn
    pn
    Prod.fst pn
    Prod.fst pn
    by rfl
</code></pre>
<p>我们现在可以用<span class="math">\(\approx\)</span>来表示等价关系：</p>
<pre><code>def Int : Type :=
    Quotient Int.Setoid
</code></pre>

<p>然后我们可以将整数定义为</p>

<pre><code>def Int.zero : Int :=
    \llbracket(\theta, \theta)\rrbracket
</code></pre>

<p>我们可以将整数零定义为</p>

<pre><code>theorem Int.zero_Eq (m : N) :
    Int.zero = \llbracket(m, m)\rrbracket :=
    by
    rw [Int.zero]
    apply Quotient.sound
    rw [Int. Setoid_Iff]
    simp
</code></pre>
<p>事实上，任何形式为<span class="math">\(\llbracket(\mathrm{m}, \mathrm{m}) \rrbracket\)</span>的项都表示零：</p>

<p>接下来，我们在新的整数上定义加法。要在商类型上定义函数，我们不能像对归纳类型那样简单地通过模式匹配来定义。相反，我们首先在基类型上定义函数，然后将定义提升到商类型。为了实现这一点，我们必须证明函数<span class="math">\(f\)</span>的定义不依赖于等价类中选取的代表（即<span class="math">\(a \approx b \rightarrow f a=f b\)</span>）。函数Quotient.lift（用于一元函数）和Quotient.lift<span class="math">\(_{3}\)</span>（用于二元函数）可以用于以这种方式提升函数。</p>

<div class="math">$$
\begin{aligned}
&amp; \llbracket\left(\text { prod.fst } \mathrm{pn}_{1}+\text { prod.fst } \mathrm{pn}_{2} \text {, prod.snd } \mathrm{pn}_{1}+\text { prod.snd } \mathrm{pn}_{2}\right) \rrbracket \\
= &amp; \llbracket\left(\text { prod.fst } \mathrm{pn}_{1}{ }^{\prime}+\text { prod.fst } \mathrm{pn}_{2}{ }^{\prime}, \text { prod.snd } \mathrm{pn}_{1}{ }^{\prime}+\text { prod.snd } \mathrm{pn}_{2}{ }^{\prime}\right) \rrbracket
\end{aligned}
$$</div>
<p>加法可以定义为将自然数对逐分量相加。然后我们需要通过证明<span class="math">\(\mathrm{pn}_{1} \approx \mathrm{pn}_{1}{ }^{\prime}\)</span>和<span class="math">\(\mathrm{pn}_{2} \approx \mathrm{pn}_{2}{ }^{\prime}\)</span>意味着</p>
<pre><code>def Int.add : Int \(\rightarrow\) Int \(\rightarrow\) Int \(:==\)
    Quotient.lift \(_{3}\)
    (fun \(\mathrm{pn}_{1} \mathrm{pn}_{2}: \mathbb{N} \times \mathbb{N} \mapsto\)
        \llbracket(Prod.fst \(\mathrm{pn}_{1}+\) Prod.fst \(\mathrm{pn}_{2}\),
            Prod.snd \(\mathrm{pn}_{1}+\) Prod.snd \(\mathrm{pn}_{2} \rrbracket\) )
    (by
        intro \(\mathrm{pn}_{1} \mathrm{pn}_{2} \mathrm{pn}_{1}{ }^{\prime} \mathrm{pn}_{2}{ }^{\prime} \mathrm{h}_{1} \mathrm{~h}_{2}\)
        apply Quotient.sound
        rw [Int.Setoid_Iff] at *
        linarith)
</code></pre>

<p>形式上：</p>

<pre><code>theorem Int.add_Eq \(\left(\mathrm{p}_{1} \mathrm{n}_{1} \mathrm{p}_{2} \mathrm{n}_{2}: \mathbb{N}\right)\);
    Int.add \(\llbracket\left(\mathrm{p}_{1}, \mathrm{n}_{1}\right) \rrbracket \llbracket\left(\mathrm{p}_{2}, \mathrm{n}_{2}\right) \rrbracket=\)
    \(\llbracket\left(\mathrm{p}_{1}+\mathrm{p}_{2}, \mathrm{n}_{1}+\mathrm{n}_{2}\right) \rrbracket:=\)
    by rfl
</code></pre>
<p>生成的函数 Int. add 具有预期的行为：</p>
<pre><code>-- fails
def Int.add : Int \(\rightarrow\) Int \(\rightarrow\) Int
    | \(\llbracket\left(p_{1}, n_{1}\right) \rrbracket, \llbracket\left(p_{2}, n_{2}\right) \rrbracket=&gt;\llbracket\left(p_{1}+p_{2}, n_{1}+n_{2}\right) \rrbracket\)
</code></pre>
<p>如果 Lean 允许我们在一开始就以这个定理作为 Int. add 的定义来输入，那将非常方便，可能会使用以下语法：</p>
<pre><code>-- fails
def Int.fst : Int \(\rightarrow \mathbb{N}\)
    | \(\llbracket(p, n) \rrbracket=&gt;p\)
</code></pre>
<p>这将是一种简洁直观的语法，但如果没有证明该定义与<span class="math">\(\approx\)</span>兼容，我们可能会定义出无意义的函数并用它们推导出False。例如，我们可以定义</p>
<p>注意，Int.fst <span class="math">\(\llbracket(\theta, \theta) \rrbracket=\theta\)</span> 且 Int.fst <span class="math">\(\llbracket(1,1) \rrbracket=1\)</span>。然而，由于 <span class="math">\(\llbracket(\theta\)</span>, <span class="math">\(\theta) \rrbracket=\llbracket(1,1) \rrbracket\)</span>，我们得到 <span class="math">\(\theta=1\)</span>，这是一个矛盾。</p>
<pre><code>theorem Int.add_zero (i : Int) :
    Int.add Int. zero i = i :=

by
    induction i using Quotient.inductionOn with
    | h pn =&gt;
        cases pn with
        | mk p n =&gt; simp [Int.zero, Int.add]
</code></pre>
<p>我们可以使用特征定理Int.add_Eq来证明关于Int.add的其他定理，例如</p>
<p>我们使用归纳策略，以Quotient.inductionOn作为归纳原理，对<span class="math">\(i\)</span>进行情况区分，将<span class="math">\(i\)</span>替换为<span class="math">\(\llbracket p n \rrbracket\)</span>，其中<span class="math">\(p n\)</span>是基本类型<span class="math">\(\mathbb{N} \times \mathbb{N}\)</span>的任意值。然后我们对pn进行情况区分，得到一对<span class="math">\(p, n\)</span>。最后，我们使用Int.zero的定义和Int.add的特征方程简化目标。</p>
<pre><code>instance UPair.Setoid ( }\alpha\mathrm{ : Type) : Setoid ( }\alpha\times\alpha\mathrm{ :=
{ r :=
    fun ab ab ab : }\alpha\times\alpha\mapsto
        ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ =
        ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ )
    iseqv :=
    { refl := by simp
        symm := by aesop
        trans := by aesop } }
theorem UPair.Setoid_Iff { }\alpha\mathrm{ : Type} (ab ab ab : }\alpha\times\alpha\mathrm{ ):
        ab ab b }
    ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ ) =
    ({Prod.fst ab, Prod.snd ab} : Set }\alpha\mathrm{ :=
    by rfl
def UPair ( }\alpha\mathrm{ : Type) : Type :=
    Quotient (UPair.Setoid }\alpha\mathrm{ )
</code></pre>

<h4>12.5.2 第二个示例：无序对</h4>
<p>无序对是指不对第一个和第二个组件进行区分的对。它们通常写作<span class="math">\(\{a, b\}\)</span>。我们将引入类型 UPair <span class="math">\(\alpha\)</span>，表示基于<span class="math">\(\alpha\)</span>的无序对，作为对<span class="math">\((a, b)\)</span>关于“包含相同元素”关系的商集：</p>

<pre><code>theorem UPair.mk_symm { }\alpha\mathrm{ : Type} (a b : }\alpha\mathrm{ ):
    ( \llbracket(a, b)\rrbracket: UPair }\alpha\mathrm{ ) = \llbracket(b, a)\rrbracket :=
    by
        apply Quotient.sound
        rw [UPair.Setoid_Iff]
        aesop
</code></pre>
<p>很容易证明我们的对确实是无序的：</p>
<pre><code>def Set_of_UPair { }\alpha\mathrm{ : Type} : UPair }\alpha\mathrm{ \rightarrow Set }\alpha\mathrm{ :=
    Quotient.lift (fun ab : }\alpha\times\alpha\mapsto\mathrm{ {Prod.fst ab, Prod.snd ab})
        (by

intro ab \(_{1}\) ab \(_{2}\) h
rw [UPair.Setoid_Iff] at *
exact \(h)\)
</code></pre>
<p>无序对的另一种表示是基数为1或2的集合。以下操作将UPair <span class="math">\(\alpha\)</span> 值转换为该表示形式：</p>
<h4>12.5.3 通过规范化和子类型化的替代定义</h4>
<p>商类型的每个元素对应于基类型的<span class="math">\(\approx\)</span>-等价元素类。如果存在一种系统的方法来为每个<span class="math">\(\approx\)</span>-等价类获取一个规范代表，我们可以使用子类型而不是商类型，仅保留规范代表并过滤掉其他元素。</p>
<pre><code>inductive Int.IsCanonical : \(\mathbb{N} \times \mathbb{N} \rightarrow\) Prop
    | nonpos \(\{n: \mathbb{N}\} \operatorname{:Int.IsCanonical}(0, n)\)
    | nonneg \(\{p: \mathbb{N}\} \operatorname{:Int.IsCanonical}(p, \circ)\)
</code></pre>
<p>考虑上面构造的整数商类型Int。我们观察到<span class="math">\((7, \circ),(8,1),(9,2)\)</span>和<span class="math">\((10,3)\)</span>都表示整数7，但直观上<span class="math">\((7, \circ)\)</span>似乎比其他几个更可取。我们将说，如果p或n为o，则对<span class="math">\((p, n)\)</span>是规范的：</p>
<pre><code>def Int : Type :=
    {pn : N × N // Int.IsCanonical pn}
</code></pre>
<p>整数因此由自然数的规范对组成：</p>
<pre><code>def Int.normalize : N × N -&gt; N × N
    | (p, n) =&gt; if p \geq n then (p - n, o) else (o, n - p)
theorem Int.IsCanonical_normalize (pn : N × N) :
    Int.IsCanonical (Int.normalize pn)
</code></pre>
<p>显然，每个整数都有且仅有一种表示方式。对整数进行的操作，如 + 和 *，必须提供规范的结果。幸运的是，规范化自然数对是容易的：</p>
<pre><code>def UPair.IsCanonical { }\alpha\mathrm{ : Type} [LinearOrder }\alpha\mathrm{ ] :
    \alpha \times \alpha \rightarrow \text { Prop}
    | (a, b) =&gt; a \leq b
def UPair ( }\alpha\mathrm{ : Type) [LinearOrder }\alpha\mathrm{ ] : Type :=
    {ab : }\alpha\times\alpha\mathrm{ // UPair.IsCanonical ab}
</code></pre>
<p>对于无序对，除了总是将较小的元素放在前面（或后面）之外，没有明显的规范形式。这需要在<span class="math">\(\alpha\)</span>上有一个线性顺序<span class="math">\(\leq\)</span>：</p>
<p>回到Int.IsCanonical，我们注意到有两个证明表明( <span class="math">\(\circ, \circ\)</span> )是规范的，分别使用Int.IsCanonical.nonpos或Int.IsCanonical.nonneg。这并不是问题，因为根据证明无关性，这些证明必须相等。</p>
<h3>12.6 新引入的Lean结构总结</h3>
<h4>声明不可计算前缀不可计算声明</h4>
<h4>常量</h4>
<p>Classical.choiceClassical.chooseQuotientQuotient.liftQuotient.lift <span class="math">\({ }_{2}\)</span>SetoidSort <span class="math">\(u\)</span>Subtype.mkSubtype.propertySubtype.val返回非空类型中任意元素的函数根据存在性证明返回见证的函数为给定setoid实例创建商类型的函数将一元函数提升到商类型的函数将二元函数提升到商类型的函数带有等价关系的类型的类型类第u层宇宙构造子类型值的函数从子类型值中提取属性的函数从子类型值中提取基础值的函数</p>
<table>
<thead>
<tr>
  <th style="text-align:left"><span class="math">\(\{x: \alpha / / P[x]\}\)</span></th>
  <th style="text-align:left">subtype of all <span class="math">\(x\)</span> in <span class="math">\(\alpha\)</span> fulfilling <span class="math">\(P[x]\)</span>
</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left"><span class="math">\(\approx\)</span></td>
  <td style="text-align:left">equivalence relation on a setoid (used for quotienting)</td>
</tr>
<tr>
  <td style="text-align:left">Prop</td>
  <td style="text-align:left">abbreviation for Sort <span class="math">\(\theta\)</span>
</td>
</tr>
<tr>
  <td style="text-align:left">Type u</td>
  <td style="text-align:left">abbreviation for Sort <span class="math">\((u+1)\)</span>
</td>
</tr>
</tbody>
</table>

<h4>符号</h4>
<h4>定理</h4>
<p>Classical. axiomOfChoice
传统选择公理
Classical.choose_spec
Quotient.exact 商类型上的等式意味着基类型上的<span class="math">\(\approx\)</span> Quotient. inductionOn 商类型值的归纳原理
Quotient.sound <span class="math">\(\quad \approx\)</span> 基类型上的关系意味着商类型上的等式
Subtype.eq 基类型上的等式意味着子类型的等式</p>

<h2>第13章：基本数学结构</h2>
<p>在本章中，我们将介绍关于基本数学结构（如群、域和线性序）的定义和证明。</p>
<h3>13.1 单一二元运算符上的类型类</h3>
<p>在数学中，群是一个集合<span class="math">\(G\)</span>，带有一个二元运算符<span class="math">\(\cdot: G \times G \rightarrow G\)</span>，满足以下性质，称为群公理：</p>
<ul>
<li>结合律：对于所有<span class="math">\(a, b, c \in G\)</span>，我们有<span class="math">\((a \cdot b) \cdot c=a \cdot(b \cdot c)\)</span>；</li>
<li>单位元：存在一个元素<span class="math">\(e \in G\)</span>，使得对于所有<span class="math">\(a \in G\)</span>，我们有<span class="math">\(e \cdot a=a\)</span>；</li>
<li>逆元：对于每个<span class="math">\(a \in G\)</span>，存在一个逆元，记为<span class="math">\(a^{-1}\)</span>，使得<span class="math">\(a^{-1} \cdot a=e\)</span>。在Lean中，群的类型类可以定义如下：</li>
</ul>
<pre><code>class Group ( }\alpha\mathrm{ : Type) where
    mul : }\alpha\mathrm{ \rightarrow }\alpha\mathrm{ \rightarrow }\alpha
    one : }\alpha
    inv : }\alpha\mathrm{ \rightarrow }\alpha
    mul_assoc : }\forall\mathrm{ a b c, mul (mul a b) c = mul a (mul b c)
    one_mul : }\forall\mathrm{a, mul one a = a
    mul_left_inv : }\forall\mathrm{a, mul (inv a) a = one
</code></pre>
<p>然而，这并不是官方的定义。群是更大代数结构层次的一部分。</p>
<p>群运算可以写成乘法形式（运算符为<span class="math">\(*\)</span>，单位元为1，逆元为<span class="math">\(a^{-1}\)</span>）或加法形式（运算符为+，单位元为0，逆元为<span class="math">\(-a\)</span>）。这就是为什么Lean提供了两种群类型类：乘法群Group和加法群AddGroup。它们在本质上是相同的，但在常量和属性的命名上有所不同。</p>
<pre><code>inductive Int2 : Type
    | zero
</code></pre>
<p>任何满足群公理的类型都可以注册为Group或AddGroup。为了说明这一点，我们将定义模2的整数类型Int2，也称为<span class="math">\(\mathbb{Z} / 2 \mathbb{Z}\)</span>或<span class="math">\(\mathbb{Z}_{2}\)</span>，并将其注册为AddGroup。类型Int2有两个元素：</p>
<pre><code>def Int2.add : Int2 -&gt; Int2 -&gt; Int2
    | Int2.zero, a =&gt; a
    | Int2.one, Int2.zero =&gt; Int2.one
    | Int2.one, Int2.one =&gt; Int2.zero
</code></pre>
<p>| 一
加法定义如下：</p>
<pre><code>                add : \(\alpha \rightarrow \alpha \rightarrow \alpha\)
                zero : \(\alpha\)
                neg : \(\alpha \rightarrow \alpha\)
            add_assoc : \Va b c, add (add a b) c = add a (add b c)
                zero_add : \Va, add zero a = a
                add_zero: \Va, add a zero = a
    neg_add_cancel : \Va, add (neg a) a = zero
        nsmul : \(\mathbb{N} \rightarrow \alpha \rightarrow \alpha\)
        zsmul : \(\mathbb{Z} \rightarrow \alpha \rightarrow \alpha\)
</code></pre>
<p>要实例化AddGroup，我们需要提供以下常量和属性：</p>
<p>常量AddGroup.add、AddGroup.zero和AddGroup.neg分别对应二元运算符、单位元和逆元。属性AddGroup.add_assoc、AddGroup.zero_add和AddGroup.neg_add_cancel对应群论的三个公理。由于技术原因，我们还必须证明冗余属性AddGroup.add_zero，并提供<span class="math">\(n\)</span>重加法的定义AddGroup.nsmul和AddGroup.zsmul。</p>
<pre><code>instance Int2.AddGroup : AddGroup Int2 :=
    { add := Int2.add
        zero := Int2.zero
        neg := fun a }\mapsto\mathrm{ a
        add_assoc :=
            by
                intro a b c
                cases a &lt;;&gt;
                    cases b &lt;;&gt;
                    cases c &lt;;&gt;
                rfl
    zero_add :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    add_zero :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    neg_add_cancel :=

    by
        intro a
        cases a &lt;;&gt;
            rfl
nsmul :=
    @nsmulRec Int2 (Zero.mk Int2.zero) (Add.mk Int2.add)
zsmul :=
    @zsmulRec Int2 (Zero.mk Int2.zero) (Add.mk Int2.add)
        (Neg.mk (fun a \hookrightarrow a))
        (@nsmulRec Int2 (Zero.mk Int2.zero) (Add.mk Int2.add)) }
</code></pre>
<p>Int2类型可以按如下方式注册为群：</p>
<p>对于AddGroup.nsmul和AddGroup.zsmul，我们使用mathlib提供的默认定义。</p>
<pre><code>\#reduce Int2.one + $\theta-\theta-$ Int2.one
</code></pre>
<p>得益于上述类型类实例，我们现在可以编写<span class="math">\(\theta,+,-,\)</span> 等符号：</p>
<table>
<thead>
<tr>
  <th style="text-align:left">Type class</th>
  <th style="text-align:left">Properties</th>
  <th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">Semigroup</td>
  <td style="text-align:left">associativity of +</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">Monoid</td>
  <td style="text-align:left">Semigroup with unit 1</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">LeftCancelSemigroup</td>
  <td style="text-align:left">Semigroup with c <span class="math">\(*\)</span> a <span class="math">\(=\mathrm{c} * \mathrm{~b} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">RightCancelSemigroup</td>
  <td style="text-align:left">Semigroup with a <span class="math">\(*\)</span> c <span class="math">\(=\mathrm{b} * \mathrm{c} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">Group</td>
  <td style="text-align:left">Monoid with inverse -1</td>
  <td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>代数层次结构包含具有一个二元运算符的更多类型类。主要类型类如下所示：</p>
<table>
<thead>
<tr>
  <th style="text-align:left">Type class</th>
  <th style="text-align:left">Properties</th>
  <th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">AddSemigroup</td>
  <td style="text-align:left">associativity of +</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">AddMonoid</td>
  <td style="text-align:left">AddSemigroup with unit <span class="math">\(\theta\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">AddLeftCancelSemigroup</td>
  <td style="text-align:left">AddSemigroup with</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left"></td>
  <td style="text-align:left">c <span class="math">\(*\)</span> a <span class="math">\(=\mathrm{c}+\mathrm{b} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">AddRightCancelSemigroup</td>
  <td style="text-align:left">AddSemigroup with</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left"></td>
  <td style="text-align:left">a <span class="math">\(*\)</span> c <span class="math">\(=\mathrm{b}+\mathrm{c} \rightarrow \mathrm{a}=\mathrm{b}\)</span>
</td>
  <td style="text-align:left"></td>
</tr>
<tr>
  <td style="text-align:left">AddGroup</td>
  <td style="text-align:left">AddMonoid with inverse -</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}\)</span></td>
</tr>
</tbody>
</table>
<p>对于大多数这些结构，可交换的版本（其中对于所有元素<span class="math">\(a, b\)</span>，<span class="math">\(a \cdot b=b \cdot a\)</span>）是可用的：CommSemigroup、CommMonoid、CommGroup。这些结构也都有以Add为前缀的加法对应版本：</p>
<p>尽管加法类型类仅仅是其乘法对应物的副本，但在构建具有多个二元运算符（如环和域）的代数结构时，它们至关重要。为了避免基于乘法类型类的所有定理和定义的重复，复制过程通过元程序自动化完成。</p>
<pre><code>instance List.AddMonoid {\alpha: Type} : AddMonoid (List \alpha) :=
    { zero := []

add := fun xs ys }-&gt;\mathrm{ xs ++ ys
add_assoc := List.append_assoc
zero_add := List.nil_append
add_zero := List.append_nil
nsmul :=
    @nsmulRec (List }\alpha\mathrm{ ) (Zero.mk [])
    (Add.mk (fun xs ys }-&gt;\mathrm{ xs ++ ys))}
</code></pre>
<p>AddMonoid 的一个示例实例是类型 List <span class="math">\(\alpha\)</span>，其中空列表 [ ] 作为零，追加运算符 ++ 作为加法：</p>
<p>我们可以继续将 List <span class="math">\(\alpha\)</span> 与 [] 和 ++ 注册为 AddLeftCancelSemigroup 和 AddRightCancelSemigroup。</p>
<p>下图展示了这些类型类之间的关系。在本图及后续图中，从<span class="math">\(X\)</span>指向<span class="math">\(Y\)</span>的箭头表示“<span class="math">\(X\)</span>继承了<span class="math">\(Y\)</span>的所有常量和属性”。</p>
<p><img src="img-14.jpeg" alt="img-14.jpeg"></p>
<h3>13.2 基于两个二元运算符的类型类</h3>
<p>加法和乘法结构被合并以形成基于两个二元运算符的更复杂结构。其中之一是域。一个域<span class="math">\(F\)</span>由以下属性定义：</p>
<ul>
<li>
<span class="math">\(F\)</span>在运算符+下形成一个交换群，称为加法，其单位元为0。</li>
<li>
<span class="math">\(F \backslash\{0\}\)</span>在运算符<span class="math">\(=\)</span>下形成一个交换群，称为乘法。</li>
<li>乘法对加法具有分配性，即对于所有<span class="math">\(a, b, c \in F\)</span>，<span class="math">\(a=(b+c)=a \circ b+a \circ c\)</span>。通过运行#print Field，我们可以显示Field所需的所有常量和属性。同样，由于类型类的构造，它包含了一些冗余的属性和定义。</li>
</ul>
<pre><code>def Int2.mul : Int2 -&gt; Int2 -&gt; Int2
    | Int2.one, a =&gt; a
    | Int2.zero, _ =&gt; Int2.zero
</code></pre>
<p>我们现在将通过使用Int2实例化Field类型类来证明Int2是一个域。首先，我们必须定义Int2上的乘法：</p>
<pre><code>theorem Int2.mul_assoc (a b c : Int2) :
    Int2.mul (Int2.mul a b) c = Int2.mul a (Int2.mul b c) :=
    by
    cases a &lt;;&gt;
        cases b &lt;;&gt;
        cases c &lt;;&gt;
        rfl
instance Int2.Field : Field Int2 :=
    { Int2.AddGroup with
        one := Int2.one
        mul := Int2.mul
        inv := fun a -&gt; a
    add_comm :=
        by
            intro a b
            cases a &lt;;&gt;
            cases b &lt;;&gt;
            rfl
    exists_pair_ne :=
        by
            apply Exists.intro Int2.zero
            apply Exists.intro Int2.one
            simp
    zero_mul :=
        by
            intro a
            rfl
    mul_zero :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    one_mul :=
        by
            intro a
            rfl
    mul_one :=
        by
            intro a
            cases a &lt;;&gt;
                rfl
    mul_inv_cancel :=
        by
            intro a h
            cases a
            { apply False.elim
                apply h
                rfl }

        { rfl }
inv_zero := by rfl
mul_assoc := Int2.mul_assoc
mul_comm :=
    by
        intro a b
        cases a &lt;;&gt;
            cases b &lt;;&gt;
            rfl
left_distrib :=
    by
        intro a b c
        cases a &lt;;&gt;
            cases b &lt;;&gt;
            rfl
right_distrib :=
    by
        intro a b c
        cases a &lt;;&gt;
            cases b &lt;;&gt;
            cases c &lt;;&gt;
            rfl
nnqsmul := _
nnqsmul_def :=
    by
        intro a b
        rfl
qsmul := _
qsmul_def :=
    by
        intro a b
        rfl
nnratCast_def :=
    by
        intro q
        rfl }
</code></pre>
<p>要将Int2声明为一个域，我们可以重用之前使用Int2.AddGroup语法定义的Int2.AddGroup实例。我们可以如下证明其余属性：</p>
<p>（为了绕过Lean的限制，Field.mul_assoc字段被证明为一个单独的定理。）</p>
<pre><code>\#reduce (1 : Int2) * 0 / (0 - 1)
</code></pre>
<p>通过这种类型类的实例化，我们现在可以使用符号1、*、/等：</p>
<pre><code>\#reduce (3 : Int2)
</code></pre>
<p>此命令打印 Int2. zero。类型注释 : Int2 在这里是必要的，用于告诉 Lean 我们希望在 Int2 中计算，而不是在默认的 <span class="math">\(\mathbb{N}\)</span> 中。我们甚至可以在 Int2 中使用任意数字。例如，数字 3 被解释为 <span class="math">\(1+1+1\)</span>，在 Int2 中与 1 相同：</p>
<table>
<thead>
<tr>
  <th style="text-align:left">Type class</th>
  <th style="text-align:left">Properties</th>
  <th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left">Semiring</td>
  <td style="text-align:left">Monoid and AddCommMonoid with distributivity</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">CommSemiring</td>
  <td style="text-align:left">Semiring with commutativity of <span class="math">\(*\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">Ring</td>
  <td style="text-align:left">Monoid and AddCommGroup with distributivity</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">CommRing</td>
  <td style="text-align:left">Ring with commutativity of <span class="math">\(*\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}, \mathbb{Z}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">DivisionRing</td>
  <td style="text-align:left">Ring with multiplicative inverse</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}\)</span></td>
</tr>
<tr>
  <td style="text-align:left">Field</td>
  <td style="text-align:left">DivisionRing with commutativity of <span class="math">\(*\)</span>
</td>
  <td style="text-align:left"><span class="math">\(\mathbb{R}, \mathbb{Q}\)</span></td>
</tr>
</tbody>
</table>
<p>该命令输出Int2. one。除了Field之外，还有许多其他用于具有两个二元运算符的结构的类型类。以下是主要的几种：</p>

<p>下图展示了这些类型类之间的关系。</p>

<p><img src="img-15.jpeg" alt="img-15.jpeg"></p>
<p>Field类型类要求属性<span class="math">\(\forall a, a / \theta=\theta\)</span>。这只是为了使除法成为一个全函数的约定。数学家会将除法视为一个偏函数。以这种方式将偏函数全函数化并无害处。</p>
<pre><code>theorem ring_example (a b : Int2) :
    \((a \cdot b) \wedge 3=a \wedge 3+3 * a \wedge 2 * b+3 * a * b \wedge 2 * b \wedge 3\)
    \(:=\)
    by ring
</code></pre>
<p>一旦我们用特定类型实例化了类型类，我们就可以使用环策略来规范化包含该类型操作符的项。例如：</p>
<p>该策略适用于任何被声明为域或更一般地声明为交换半环的类型。</p>
<pre><code>theorem neg_mul_neg_Nat \((n: \mathbb{N})(z: \mathbb{Z}):\)
    \((-z) *(-\mathrm{n})=z * n:=\)
    by simp
</code></pre>
<h3>13.3 强制类型转换</h3>
<p>当在同一定理中组合来自<span class="math">\(\mathbb{N}, \mathbb{Z}, \mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>的数字时，我们可能希望将一种类型转换为另一种类型。例如，给定一个自然数，我们可能需要将其转换为整数。考虑以下定理，并注意乘法参数的类型：</p>
<p>令人惊讶的是，尽管取反 - n 在 <span class="math">\(n: \mathbb{N}\)</span> 上未定义，且 <span class="math">\(z: \mathbb{Z}\)</span> 和 <span class="math">\(n: \mathbb{N}\)</span> 的乘法也未定义，但该语句并未导致错误。</p>
<pre><code>neg_mul_neg_Nat : V (n : N)(z : Z), -z * -\n = z * \n
</code></pre>
<p>诊断命令 #check neg_mul_neg_Nat 告诉我们发生了什么：</p>
<p>Lean 有一种机制可以在必要时引入强制转换，表示为 <span class="math">\(\div\)</span> 或 coe。此强制转换运算符可以设置为在任意类型之间提供隐式转换。许多强制转换已经就位，包括以下这些：</p>
<ul>
<li>coe : <span class="math">\(\mathbb{N} \rightarrow \alpha\)</span> 将 <span class="math">\(\mathbb{N}\)</span> 转换为另一个半环 <span class="math">\(\alpha\)</span>；</li>
<li>coe : <span class="math">\(\mathbb{Z} \rightarrow \alpha\)</span> 将 <span class="math">\(\mathbb{Z}\)</span> 转换为另一个环 <span class="math">\(\alpha\)</span>；</li>
<li>coe : <span class="math">\(\mathbb{Q} \rightarrow \alpha\)</span> 将 <span class="math">\(\mathbb{Q}\)</span> 转换为另一个除环 <span class="math">\(\alpha\)</span>。</li>
</ul>
<pre><code>theorem neg_Nat_mul_neg (n : N) (z : Z) :
    (- n : Z) * (- z) = n * z :=
    by simp
</code></pre>
<p>我们可以提供类型注解来记录我们的意图或帮助Lean确定在哪里放置强制转换，如下例所示：</p>
<pre><code>theorem Eq_coe_int_imp_Eq_Nat (m n : N)
    (h : (m : Z) = (n : Z)) :
    m}=\textrm{n}:=\mathrm{o
    by norm_cast at h
</code></pre>
<p>在涉及强制类型转换的证明中，norm_cast策略可能会非常方便。它有助于处理诸如<span class="math">\(\vdash \mathrm{m} \mathrm{n}: \mathbb{N}, \mathrm{h}: \leq \mathrm{m}=\leq \mathrm{n} \vdash \mathrm{m}=\mathrm{n}\)</span>的目标。</p>
<pre><code>theorem Nat_coe_Int_add_eq_add_Nat_coe_Int (m n : N) :
    (m : Z) + (n : Z) = ((m + n : N) : Z) :=
    by norm_cast
</code></pre>
<p>同样地，它有助于处理目标<span class="math">\(\vdash \mathrm{m} \mathrm{n}: \mathbb{N} \vdash \leq \mathrm{m}+\leq \mathrm{n}=\leq(\mathrm{m}+\mathrm{n})\)</span>。</p>
<div class="math">$$
\begin{aligned}
&amp; \text { Nat.cast_add : Va b : } \mathbb{N}, \leq(\mathrm{a}+\mathrm{b})=\leq \mathrm{a}+\leq \mathrm{b} \\
&amp; \text { Int.cast_add : Va b : } \mathbb{Z}, \leq(\mathrm{a}+\mathrm{b})=\leq \mathrm{a}+\leq \mathrm{b} \\
&amp; \text { Rat.cast_add : Va b : } \mathbb{Q}, \leq(\mathrm{a}+\mathrm{b})=\leq \mathrm{a}+\leq \mathrm{b}
\end{aligned}
$$</div>

<p>norm_cast 策略依赖于以下定理：</p>

<h3>13.4 归一化策略</h3>
<p>代数策略 ring 和强制策略 norm_cast 通过归一化工作：它们重写表达式，希望这些表达式在语法上变得相等，此时等式的证明就变得微不足道。与 rw 和 simp 类似，当它们取得一些进展但未能完全证明目标时，它们会产生一个子目标。</p>
<p>可选的位置参数与重写策略（第3.5节）中的相同。</p>
<h4>ring</h4>
<p>ring [在指定位置] ring策略通过规范化表达式并在语法上比较结果，来证明交换环和半环（如<span class="math">\(\mathbb{N}, \mathbb{Z}, \mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>）上的等式。</p>
<h4>norm_cast</h4>
<p>norm_cast [位于位置] norm_cast 策略将强制转换推向表达式的外部，作为一种简化形式。</p>
<h3>13.5 列表、多重集与有限集</h3>
<p>在前面的章节中，我们已经看到了许多使用列表的示例。但在进行新定义或陈述新定理时，我们也应当考虑诸如多重集和有限集等替代方案。</p>
<pre><code>def List.elems : Tree N -&gt; List N
    | Tree.nil =&gt; []
    | Tree.node a l r =&gt; a :: List.elems l ++ List.elems r
</code></pre>
<p>考虑以下基于我们在第5.8节中介绍的二叉树的定义：</p>
<p>该函数返回树中所有元素的列表。它以深度优先、从左到右的方式遍历树。但对于某些应用，我们可能并不关心元素的顺序。</p>
<pre><code>def Multiset.elems : Tree N -&gt; Multiset N
    | Tree.nil =&gt; 0
    | Tree.node a l r =&gt;
        {a} \ Multiset.elems l \ Multiset.elems r
</code></pre>
<p>这就是多重集发挥作用的地方。对于多重集，我们有<span class="math">\(\{3,2,1,2\}=\)</span> <span class="math">\(\{1,2,2,3\}\)</span>，而两个列表<span class="math">\([3,2,1,2]\)</span>和<span class="math">\([1,2,2,3]\)</span>是不同的。多重集被定义为列表在重新排序下的商类型。我们可以使用多重集重新定义上述内容如下：</p>
<p>使用这一定义，我们可以证明 Multiset.elems <span class="math">\(t=\)</span> Multiset.elems (mirror t)，而 List.elems <span class="math">\(t=\)</span> List.elems (mirror <span class="math">\(t\)</span> ) 通常不成立。</p>
<pre><code>def Finset.elems : Tree N -&gt; Finset N
    | Tree.nil =&gt; 0
    | Tree.node a l r =&gt; {a} \ Finset.elems l \ Finset.elems r
</code></pre>
<p>对于某些应用，我们可能希望更进一步，不仅忽略顺序，还忽略每个元素在树中出现的次数，只区分出现与未出现。这就是有限集（或称为finsets）发挥作用的地方。在finsets上，我们有<span class="math">\(\{3,2,1,2\}=\{1,2,3\}\)</span>。Finsets被定义为不包含任何重复元素的多重集的子类型。（另一种可能的定义是将其定义为有限集的子类型。）我们可以使用finsets重新定义上述内容如下：</p>
<pre><code>Reval List.sum [2, 3, 4]
Reval Multiset.sum ({2, 3, 4} : Multiset N)
Reval List.prod [2, 3, 4]
Reval Multiset.prod ({2, 3, 4} : Multiset N)
</code></pre>
<p>对于列表和多集，Lean提供了求和与乘积运算符来对所有元素进行相加或相乘。下面，前两个命令输出9，最后两个命令输出24：</p>
<p>这些操作符要求元素的类型被声明为AddMonoid的实例以进行求和，或Monoid的实例以进行乘积。Multiset版本还需要声明AddCommMonoid或CommMonoid的实例，因为结果不能依赖于元素的加法或乘法顺序。</p>
<pre><code>inductive Nat.le : \(\mathbb{N} \rightarrow \mathbb{N} \rightarrow\) Prop
    | refl : Va : N, Nat.le a a
    | step : Va b : N, Nat.le a b \(\rightarrow\) Nat.le a (b + 1 )
</code></pre>
<h3>13.6 序类型类</h3>
<p>上面介绍的许多结构都可以被排序。例如，自然数上的熟悉顺序可以定义为</p>
<p>这是一个线性序的例子。线性序（或全序）是一种二元关系<span class="math">\(\leq\)</span>，使得对于所有<span class="math">\(a, b\)</span>和<span class="math">\(c\)</span>，以下性质成立：</p>
<ul>
<li>自反性：<span class="math">\(a \leq a\)</span>；</li>
<li>传递性：如果<span class="math">\(a \leq b\)</span>且<span class="math">\(b \leq c\)</span>，则<span class="math">\(a \leq c\)</span>；</li>
<li>反对称性：如果<span class="math">\(a \leq b\)</span>且<span class="math">\(b \leq a\)</span>，则<span class="math">\(a=b\)</span>；</li>
<li>全序性：<span class="math">\(a \leq b\)</span>或<span class="math">\(b \leq a\)</span>。</li>
</ul>
<p>如果一个关系具有前三个性质，则它是一个偏序。一个例子是集合、有限集合或多重集合上的子集关系<span class="math">\(\subseteq\)</span>。如果一个关系具有前两个性质，则它是一个预序。一个例子是通过长度比较列表。</p>
<div class="math">$$
\begin{gathered}
\text { le : } \alpha \rightarrow \alpha \rightarrow \text { Prop } \\
\text { le_refl : } \forall \mathrm{a}: \alpha, \text { le a a } \\
\text { le_trans: } \forall \mathrm{a} b \mathrm{c}: \alpha, \text { le a b } \rightarrow \text { le b c } \rightarrow \text { le a c }
\end{gathered}
$$</div>
<p>在Lean中，有不同类型的类型类来表示顺序：LinearOrder、PartialOrder和Preorder。Preorder类有一个常量和两个属性：</p>
<div class="math">$$
\text { le_antisymm : } \forall \mathrm{a} b: \alpha, \text { le a b } \rightarrow \text { le b a } \rightarrow \mathrm{a}=\mathrm{b}
$$</div>
<p>PartialOrder类具有额外的属性</p>
<div class="math">$$
\text { le_total : } \forall \mathrm{a} b: \alpha, \text { le a b } \vee \text { le b a }
$$</div>

<p>而LinearOrder具有额外的属性</p>

<pre><code>instance List.length.Preorder {\alpha: Type} : Preorder (List \alpha):=
    { le :=
        fun xs ys }-&gt;\mathrm{ List.length xs \leq List.length ys
    lt :=
        fun xs ys }-&gt;\mathrm{ List.length xs &lt; List.length ys
    le_refl :=
        by
            intro xs
            apply Nat.le_refl
    le_trans :=
        by
            intro xs ys zs
            exact Nat.le_trans
    lt_iff_le_not_le :=
        by

intro a b
exact Nat.lt_iff_le_not_le }
</code></pre>
<p>我们可以声明在列表 <span class="math">\(\alpha\)</span> 上通过长度比较的预序如下：</p>
<pre><code>theorem list.length.Preorder_example :&gt;[] :=
    by decide
</code></pre>
<p>这种类型类实例提供了对中缀语法<span class="math">\(\leq\)</span>以及相应的关系<span class="math">\(\geq,&lt;\)</span>和<span class="math">\(&gt;\)</span>的访问：</p>
<p>该证明采用了一种新的策略，decide，它依赖于类型类推断来证明可判定的简单目标。</p>
<p>我们在第11章讨论的完全格被形式化为另一个类型类CompleteLattice，它扩展了PartialOrder。</p>
<p><img src="img-16.jpeg" alt="img-16.jpeg"></p>
<p>最后，Lean 提供了一些结合了序和代数结构的类型类：OrderedCancelCommMonoid、OrderedCommGroup、OrderedSemiring、LinearOrderedSemiring、LinearOrderedCommRing、LinearOrderedEvent。所有这些数学结构通过单调性规则（例如，<span class="math">\(a \leq b \rightarrow c \leq d \rightarrow a \star c \leq b \star d\)</span>）和消去规则（例如，<span class="math">\(c \star\)</span> <span class="math">\(a \leq c \star b \rightarrow a \leq b)\)</span>）将 <span class="math">\(\leq\)</span> 和 <span class="math">\(&lt;\)</span> 与常量 <span class="math">\(\circ, 1, \star\)</span> 以及 <span class="math">\(\star\)</span> 联系起来。</p>
<h3>13.7 决策策略</h3>
<h4>decide</h4>
<p>decide策略可用于证明为真的可判定目标。可判定性通过检查是否属于Decidable类型类来确定。与rfl不同，decide不仅限于证明等式。</p>
<h3>13.8 新引入的Lean结构总结</h3>
<h4>符号</h4>
<p><span class="math">\(\uparrow \quad\)</span> 强制转换操作符 coe</p>
<h4>策略</h4>
<p>decide
norm_cast
ring
证明可判定真理（例如，一个可执行的真实表达式）
规范化强制转换
规范化环表达式</p>
<h2>第14章：有理数与实数</h2>
<p>在前几章中，我们已经了解了如何将自然数<span class="math">\(\mathbb{N}\)</span>定义为归纳类型，以及如何将整数<span class="math">\(\mathbb{Z}\)</span>定义为<span class="math">\(\mathbb{N} \times \mathbb{N}\)</span>上的商。在本章中，我们将回顾有理数<span class="math">\(\mathbb{Q}\)</span>和实数<span class="math">\(\mathbb{R}\)</span>的构造。用于这些构造的工具包括归纳类型、子类型和商。</p>
<p>以下过程可用于构造具有特定属性的类型：</p>
<ol>
<li>创建一个新类型，该类型足够大以表示所有元素，但不一定以唯一的方式表示。</li>
<li>对此表示进行商运算，根据需要将元素等同起来。</li>
<li>通过从基类型提升函数来定义商类型上的运算符，并证明它们与商关系兼容。我们在第12.5.1节中使用了这种方法来构造类型<span class="math">\(\mathbb{Z}\)</span>。它也可以用于<span class="math">\(\mathbb{Q}\)</span>和<span class="math">\(\mathbb{R}\)</span>。</li>
</ol>
<pre><code>structure Fraction where
    num : \(\mathbb{Z}\)
    denom : \(\mathbb{Z}\)
    denom_Neq_zero : denom \(\neq 0\)
</code></pre>
<h3>14.1 有理数</h3>
<p>有理数是可以表示为整数<span class="math">\(n\)</span>和<span class="math">\(d\)</span>的分数<span class="math">\(n / d\)</span>的数，其中<span class="math">\(d \neq 0\)</span>：</p>
<p>数字<span class="math">\(n\)</span>被称为分子，数字<span class="math">\(d\)</span>被称为分母。有理数作为分数的表示并不唯一。例如，有理数<span class="math">\(1 / 2,2 / 4\)</span>和<span class="math">\(-1 /-2\)</span>都是相等的。这种分数的表示将作为我们取商的基础类型。</p>
<pre><code>instance Setoid : Setoid Fraction :=
    { r :=
        fun a b : Fraction }-&gt;\mathrm{ num a * denom b = num b * denom a
        iseqv :=
            { refl := by aesop
                symm := by aesop
                trans :=
                    by
                        intro a b c heq_ab heq_bc
                        apply Int.eq_of_mul_eq_mul_right (denom_Neq_zero b)
                        calc
                            num a * denom c * denom b
                            = num a * denom b * denom c :=
                            by ac_rfl
                            _ = num b * denom a * denom c :=
                            by rw [heq_ab]
                            _ = num b * denom c * denom a :=
                            by ac_rfl
                            _ = num c * denom b * denom a :=
                            by rw [heq_bc]
                            _ = num c * denom a * denom b :=
                            by ac_rfl
    } }
theorem Setoid_Iff (a b : Fraction) :
        a \approx b \leftrightarrow num a * denom b = num b * denom a :=
    by rfl
end Fraction
</code></pre>
<p>如果分子与分母的比例相同，则两个分数<span class="math">\(n_{1} / d_{1}\)</span>和<span class="math">\(n_{2} / d_{2}\)</span>表示相同的有理数：<span class="math">\(n_{1} \approx d_{2}=n_{2} \approx d_{1}\)</span>。为了在这种关系上构造Fraction类型的商，我们证明该关系是一个等价关系。这是通过将Fraction声明为Setoid类型类的实例来实现的：</p>
<pre><code>def Rat : Type :=
    Quotient Fraction.Setoid
</code></pre>
<p>然后我们可以将有理数的类型定义为在这个集合上的商：</p>
<pre><code>instance Add : Add Fraction :=
    { add := fun a b : Fraction }-&gt;
        { num := num a * denom b + num b * denom a
            denom := denom a * denom b
            denom_Neq_zero := by simp [denom_Neq_zero] } }
</code></pre>
<p>为了定义零、一、加法、乘法以及其他运算，我们首先在Fraction类型上定义它们。要将两个分数相加，我们将它们转换为一个共同的分母并相加分子。使用的最简单的共同分母就是两个分母的乘积：namespace Fraction</p>
<pre><code>@[simp] theorem add_num (a b : Fraction) :
    num (a + b) = num a * denom b + num b * denom a :=
    by rfl
@[simp] theorem add_denom (a b : Fraction) :
    denom (a * b) = denom a * denom b :=
    by rfl
theorem Setoid_add {a a' b b' : Fraction} (ha : a \approx a')
        (hb : b \approx b') :
    a + b \approx a' + b' :=
    by
    simp [Setoid_Iff, add_denom, add_num] at *
    calc
        (num a * denom b + num b * denom a)
            * (denom a' * denom b')
        = num a * denom a' * denom b * denom b'
            + num b * denom b' * denom a * denom a' :=
            by
                simp [add_mul, mul_add]
                ac_rfl
            _ = num a' * denom a * denom b * denom b'
                + num b' * denom b * denom a * denom a' :=
            by simp [*]
            _ = (num a' * denom b' + num b' * denom a')
                * (denom a * denom b) :=
            by
                simp [add_mul, mul_add]
                ac_rfl
end Fraction
</code></pre>
<p>我们将这些操作注册为诸如Add等语法类型类的实例，以便能够在Fraction上使用诸如+的便捷符号。同样，我们将零定义为<span class="math">\(0:=0 / 1\)</span>，一定义为<span class="math">\(1:=1 / 1\)</span>，并将乘法定义为分子和分母的逐对相乘。为了将这些操作提升到有理数类型Rat，我们必须证明它们与<span class="math">\(\approx\)</span>兼容：</p>
<pre><code>namespace Rat
instance Add : Add Rat :=
    { add := Quotient.lift2 (fun a b : Fraction \mapsto mk (a + b))
        (by
            intro a b a' b' ha hb
            apply Quotient.sound
            exact Fraction.Setoid_add ha hb) }
end Rat
</code></pre>
<p>然后我们可以使用Quotient.<span class="math">\(\operatorname{lift}\left({ }_{2}\right)\)</span>来定义Rat操作，并且我们可以实例化相关的语法类型类，例如</p>
<p>从这里开始，我们可以继续并证明所有使 Rat 成为 Field 实例所需的属性。</p>
<pre><code>def Rat.IsCanonical (a : Fraction) : Prop :=
    Fraction.denom a &gt; 0
    \ Nat.Coprime (Int.natAbs (Fraction.num a))
        (Int.natAbs (Fraction.denom a))
def Rat : Type :=
    {a : Fraction // Rat.IsCanonical a}
</code></pre>
<p>有理数的替代定义 在mathlib中，另一种方法被用来定义有理数。类型Rat被定义为Fraction的子类型，要求分母为正，并且分子和分母互质（即它们除了1和-1之外没有其他公约数）：</p>
<p>这是第12.5.3节中描述的一般策略的一个实例。通过这种方法，不需要商，计算更加高效，并且更多属性在计算上是语法相等的。缺点是函数定义由于需要规范化分数而变得更加复杂。</p>
<div class="math">$$
\begin{aligned}
&amp; a_{0}=1 \\
&amp; a_{1}=1.4 \\
&amp; a_{2}=1.41 \\
&amp; a_{3}=1.414 \\
&amp; a_{4}=1.4142 \\
&amp; \quad \vdots
\end{aligned}
$$</div>
<h3>14.2 实数</h3>
<p>一些有理数序列似乎收敛，因为序列中的数越来越接近，但却不收敛于一个有理数。序列</p>
<p>其中<span class="math">\(a_{n}\)</span>是小数点后有<span class="math">\(n\)</span>位数且满足<span class="math">\(a_{n}^{2}&lt;2\)</span>的最大数，这样的序列就是其中之一。它似乎收敛，因为每个<span class="math">\(a_{n}\)</span>与后续数字的差距最多为<span class="math">\(10^{-n}\)</span>，但极限是<span class="math">\(\sqrt{2} \notin \mathbb{Q}\)</span>。从这个意义上说，有理数是不完备的，而实数是它们的完备化。为了构造实数，我们需要填补这些看似收敛但实际上不收敛的序列所揭示的空白。</p>
<p>柯西序列捕捉了看似收敛的序列的概念。一个序列<span class="math">\(a_{0}, a_{1}, \ldots\)</span>是柯西的，如果对于任意<span class="math">\(\varepsilon&gt;0\)</span>，存在一个<span class="math">\(N \in \mathbb{N}\)</span>，使得对于所有<span class="math">\(m \geq N\)</span>，我们有<span class="math">\(\left|a_{N}-a_{m}\right|&lt;\varepsilon\)</span>。换句话说，无论我们选择多小的<span class="math">\(\varepsilon\)</span>，我们总能找到序列中的一个点，从该点开始，所有后续数与它的偏差都小于<span class="math">\(\varepsilon\)</span>。</p>
<pre><code>def IsCauchySeq (f : N -&gt; Q) : Prop :=
    V\varepsilon &gt; 0, \existsN, \forallm \geq N, abs(f N - f m) &lt; \varepsilon
</code></pre>
<p>我们将有理数序列形式化为函数<span class="math">\(f: \mathbb{N} \rightarrow \mathbb{Q}\)</span>，并用abs表示绝对值<span class="math">\(|\mid\)</span>。这得到了以下Lean中柯西序列的定义：</p>
<pre><code>theorem id_Not_CauchySeq :
    \(\neg\) IsCauchySeq (fun \(n: \mathbb{N} \mapsto(n: \mathbb{Q})):=
    by
        rw [IsCauchySeq]
        intro h
        cases h 1 zero_lt_one with
        | intro i hi =&gt;
            have hi_succi :=
                hi (i + 1) (by simp)
            simp [ \--sub_sub] at hi_succi
</code></pre>
<p>并非每个序列都是柯西序列：</p>
<pre><code>def CauchySeq : Type :=
    {f : N -&gt; Q // IsCauchySeq f}
</code></pre>
<p>我们将一种柯西序列定义为一个子类型：</p>
<pre><code>def seqOf (f : CauchySeq) : N -&gt; Q :=
    Subtype.val f
</code></pre>
<p>拥有一个从CauchySeq中提取实际序列的辅助函数将会很方便。</p>
<p>构造的基本思想是通过柯西序列来表示实数。每个柯西序列表示其极限的实数；例如，序列<span class="math">\(a_{n}=1 / n\)</span>表示实数0，而序列<span class="math">\(1,1.4,1.41, \ldots\)</span>表示实数<span class="math">\(\sqrt{2}\)</span>。</p>
<pre><code>namespace CauchySeq
instance Setoid : Setoid CauchySeq :=
{ r :=
    fun f g : CauchySeq \mapsto
        \forall \varepsilon&gt;\emptyset, \exists N, \forall m \geq N, \text { abs (seqOf f m - seqOf g m) &lt; } \varepsilon
    iseqv :=
        { refl :=
            by
                intro f \varepsilon h
                apply Exists.intro
                aesop
            symm :=
            by
                intro f g hfg \varepsilon h
                cases hfg \varepsilon hE with
                | intro N hN =&gt;
                apply Exists.intro N
                intro m hm

            rw [abs_sub_comm]
            apply hN m hm
trans :=
    by
        intro f g h hfg hgh \varepsilon h
        cases hfg ( \varepsilon / 2) (by linarith) with
        | intro N
            cases hgh ( \varepsilon / 2) (by linarith) with
            | intro N
                apply Exists.intro (max N
                intro m hm
                calc
                    abs (seqOf f m - seqOf h m)
                    \leq abs (seqOf f m - seqOf g m)
                    + abs (seqOf g m - seqOf h m) :=
                    by apply abs_sub_le
                _ &lt; \varepsilon / 2 + \varepsilon / 2 :=
                    add_lt_add (hN
                    (hN
                    by_simp } }
theorem Setoid_iff (f g : CauchySeq) :
    f \leqq g \leftrightarrow
    \forall \varepsilon&gt;\emptyset, \exists N, \forall m \geq N, \text { abs (seqOf f m - seqOf g m) &lt; \varepsilon :=}
    by rfl
end CauchySeq
</code></pre>
<p>两个不同的柯西序列可以表示同一个实数；例如，序列<span class="math">\(a_{n}=1 / n\)</span>和常数序列<span class="math">\(b_{n}=0\)</span>都表示0。因此，我们需要对表示相同实数的序列进行商运算。当两个序列的差收敛于零时，它们表示同一个实数：</p>
<pre><code>def Real : Type :=
  Quotient CauchySeq. Setoid
</code></pre>
<p>使用这个Setoid实例，我们现在可以定义实数：</p>
<pre><code>namespace CauchySeq
def const (q : Q) : CauchySeq :=
Subtype.mk (fun _ : $\mathbb{N} \mapsto \mathrm{q}$ )
(by
rw [IsCauchySeq]
intro $\varepsilon$ h $\varepsilon$
aesop)
end CauchySeq
</code></pre>
<p>与有理数类似，我们需要定义零、一、加法、乘法以及其他运算符。我们首先在CauchySeq上定义它们，然后将它们提升到Real。对于常量<span class="math">\(\varnothing\)</span>和1，我们可以简单地将它们定义为常量序列。任何常量序列都是柯西序列：</p>
<pre><code>namespace Real
instance Zero : Zero Real :=
    { zero := [CauchySeq. const 0] }
instance One : One Real :=
    { one := [CauchySeq. const 1] }
end Real
</code></pre>
<p>我们可以声明语法类型类zero和One的Real实例：</p>
<pre><code>instance Add : Add CauchySeq :=
    { add := fun f g : CauchySeq }
        Subtype.mk (fun n : N}-&gt;\mathrm{ seqOf f n + seqOf g n) sorry }
</code></pre>
<p>定义实数的加法需要稍多的努力。我们通过逐对相加序列中的元素来定义柯西序列上的加法：namespace CauchySeq</p>
<p>该定义需要证明在给定<span class="math">\(f\)</span>和<span class="math">\(g\)</span>为柯西序列的情况下，结果也是一个柯西序列。此证明被省略，因此使用了sorry。</p>
<pre><code>theorem Setoid_add {f f' g g' : CauchySeq} (hf : f \ f')
        (hg : g \ g') :
        f + g \ f' + g' :=
    by
        intro \(\varepsilon_{0}\) h \(\varepsilon_{0}\)
        simp [Setoid_iff]
        cases hf ( \(\varepsilon_{0} / 2\) ) (by linarith) with
        | intro Nf hNf =&gt;
            cases hg ( \(\varepsilon_{0} / 2\) ) (by linarith) with
            | intro Ng hNg =&gt;
                apply Exists.intro (max Nf Ng)
                intro m hm
                calc
                    abs (seqOf (f + g) m - seqOf (f' + g') m)
                    = abs ((seqOf f m + seqOf g m)
                    - (seqOf f' m + seqOf g' m)) :=
                    by rfl
            _ = abs ((seqOf f m - seqOf f' m)
                    + (seqOf g m - seqOf g' m)) :=
                    by
                        have arg_eq :
                        seqOf f m + seqOf g m
                            - (seqOf f' m + seqOf g' m) =
                            seqOf f m - seqOf f' m
                            + (seqOf g m - seqOf g' m) :=
                            by linarith
                            rw [arg_eq]
    _ \ abs (seqOf f m - seqOf f' m)
                            + abs (seqOf g m - seqOf g' m) :=
                            by apply abs_add

    &lt; \varepsilon0 / 2 + \varepsilon0 / 2 :=
    add_lt_add (hNf m (le_of_max_le_left hm))
        (hNg m (le_of_max_le_right hm))
    _=\varepsilon0:=
    by simp
end CauchySeq
</code></pre>
<p>接下来，我们需要证明这种加法与<span class="math">\(\approx\)</span>是兼容的：</p>
<div class="math">$$
\forall m, m \geq N \rightarrow \operatorname{abs}(\operatorname{seqOf}(f+g) m-\operatorname{seqOf}\left(f^{\prime}+g^{\prime}\right) m)&lt;\varepsilon_{0}
$$</div>
<p>为了证明<span class="math">\(f+g \approx f^{\prime}+g^{\prime}\)</span>，我们给定一个<span class="math">\(\varepsilon_{0}&gt;\theta\)</span>，并且必须证明存在一个数<span class="math">\(N\)</span>使得</p>
<div class="math">$$
\operatorname{abs}(\operatorname{seqOf}(f+g) m-\operatorname{seqOf}\left(f^{\prime}+g^{\prime}\right) m)&lt;\varepsilon_{0}
$$</div>
<p>为了得到N，我们使用<span class="math">\(f \approx f^{\prime}\)</span>和<span class="math">\(g \approx g^{\prime}\)</span>。等价关系<span class="math">\(f \approx f^{\prime}\)</span>为我们提供了对于任何<span class="math">\(\varepsilon&gt;\)</span> <span class="math">\(\theta\)</span>，存在一个数Nf，使得对于所有<span class="math">\(m \geq N f\)</span>，abs (seqOf f m - seqOf <span class="math">\(f^{\prime} m\)</span> ) &lt; 成立。事实<span class="math">\(g \approx g^{\prime}\)</span>为我们提供了一个具有类似性质的数Ng。为了使最终的计算成立，我们取Nf和Ng为<span class="math">\(\varepsilon:=\varepsilon_{0} / 2\)</span>。然后我们选择N为Nf和Ng的最大值，以便对于任何<span class="math">\(m \geq N\)</span>，我们得到不等式。证明末尾的计算块确立了对于所有<span class="math">\(m \geq N\)</span>，</p>
<pre><code>namespace Real
instance Add : Add Real :=
{ add := Quotient.lift 2 (fun a b : CauchySeq \(\mapsto\llbracket a+b \rrbracket\) )
    (by
        intro a b a' b' ha hb
        apply Quotient.sound
        exact CauchySeq.Setoid_add ha hb) }
end Real
</code></pre>
<p>既然我们已经证明了柯西序列上的加法与<span class="math">\(\approx\)</span>兼容，我们就可以在实数上定义加法：</p>
<p>我们可以继续这样定义乘法和其他运算符。总之，实数被定义为柯西序列的商，而柯西序列又被定义为<span class="math">\(\mathbb{N} \rightarrow \mathbb{Q}\)</span>的子类型。</p>
<p>在mathlib中，实数的构造基本上如上所述。一些定义以更一般的方式陈述，以便允许构造其他代数结构，例如<span class="math">\(p\)</span>-进数。</p>
<p>或者，实数可以通过戴德金分割来定义。一个数<span class="math">\(r: \mathbb{R}\)</span>被表示为满足<span class="math">\(x&lt;r\)</span>的有理数<span class="math">\(x: \mathbb{Q}\)</span>的集合。另一种不依赖于<span class="math">\(\mathbb{Q}\)</span>的方法是使用二进制序列<span class="math">\(\mathbb{N} \rightarrow\)</span> Bool来定义<span class="math">\(\mathbb{R}\)</span>。序列的元素表示数字的位数。如果我们只需要实数区间<span class="math">\([0,1]\)</span>，这种方法尤其有效。</p>
<h3>14.3 最后的劝诫</h3>
<p>我们现在已经到达了本指南的结尾。你现在已经掌握了交互式定理证明的基本理论和技术，以及一些应用领域。尽管我们使用了Lean，但你所学的知识应该可以迁移到其他系统，特别是那些基于简单或依赖类型理论的系统。你应该能够阅读该领域的大多数科学论文。</p>
<p>即使您不选择从事定理证明的职业，作者也希望您能随身携带证明助手，并在合适的时候使用它们，无论是因为它们的高度可信性，还是因为它们便于跟踪复杂的证明目标。</p>
<p>If you continue using Lean, the natural next step would be to familiarize yourself with mathlib and its documentation. If you use Lean outside a class context, you will often find yourself looking up definitions and theorems. You will surely find the #find command useful. <span class="math">\({ }^{1}\)</span> And most Lean users use the Lean Zulip chat. <span class="math">\({ }^{2}\)</span></p>
</div>
</body>